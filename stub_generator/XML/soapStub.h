/* soapStub.h
   Generated by gSOAP 2.8.32 for CyberSourceTransaction_xml_1.129.h

gSOAP XML Web services tools
Copyright (C) 2000-2016, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#include <deque>
#include <list>
#include <vector>
#include <set>
#define SOAP_NAMESPACE_OF_wsc	"http://docs.oasis-open.org/ws-sx/ws-secureconversation/200512"
#define SOAP_NAMESPACE_OF_ns2	"urn:schemas-cybersource-com:transaction-data-1.129"

#ifndef soapStub_H
#define soapStub_H
#include "stdsoap2.h"
#if GSOAP_VERSION != 20832
# error "GSOAP VERSION 20832 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumeration Types                                                          *
 *                                                                            *
\******************************************************************************/


/* wsu.h:66 */
#ifndef SOAP_TYPE_wsu__tTimestampFault
#define SOAP_TYPE_wsu__tTimestampFault (11)
/* wsu:tTimestampFault */
enum wsu__tTimestampFault {
	wsu__MessageExpired = 0
};
#endif

/* wsse.h:100 */
#ifndef SOAP_TYPE_wsse__FaultcodeEnum
#define SOAP_TYPE_wsse__FaultcodeEnum (14)
/* wsse:FaultcodeEnum */
enum wsse__FaultcodeEnum {
	wsse__UnsupportedSecurityToken = 0,
	wsse__UnsupportedAlgorithm = 1,
	wsse__InvalidSecurity = 2,
	wsse__InvalidSecurityToken = 3,
	wsse__FailedAuthentication = 4,
	wsse__FailedCheck = 5,
	wsse__SecurityTokenUnavailable = 6
};
#endif

/* wsc.h:62 */
#ifndef SOAP_TYPE_wsc__FaultCodeType
#define SOAP_TYPE_wsc__FaultCodeType (89)
/* wsc:FaultCodeType */
enum wsc__FaultCodeType {
	wsc__BadContextToken = 0,
	wsc__UnsupportedContextToken = 1,
	wsc__UnknownDerivationSource = 2,
	wsc__RenewNeeded = 3,
	wsc__UnableToRenew = 4
};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes, Structs and Unions                                                *
 *                                                                            *
\******************************************************************************/

struct _wsu__Timestamp;	/* wsu.h:76 */
struct wsse__EncodedString;	/* wsse.h:57 */
struct _wsse__UsernameToken;	/* wsse.h:128 */
struct _wsse__BinarySecurityToken;	/* wsse.h:139 */
struct _wsse__Reference;	/* wsse.h:149 */
struct _wsse__Embedded;	/* wsse.h:157 */
struct _wsse__KeyIdentifier;	/* wsse.h:166 */
struct _wsse__SecurityTokenReference;	/* wsse.h:176 */
struct ds__SignatureType;	/* ds.h:46 */
struct _c14n__InclusiveNamespaces;	/* c14n.h:24 */
struct ds__TransformType;	/* ds.h:73 */
struct ds__KeyInfoType;	/* ds.h:48 */
struct ds__SignedInfoType;	/* ds.h:46 */
struct ds__CanonicalizationMethodType;	/* ds.h:59 */
struct ds__SignatureMethodType;	/* ds.h:62 */
struct ds__ReferenceType;	/* ds.h:65 */
struct ds__TransformsType;	/* ds.h:68 */
struct ds__DigestMethodType;	/* ds.h:79 */
struct ds__KeyValueType;	/* ds.h:85 */
struct ds__RetrievalMethodType;	/* ds.h:86 */
struct ds__X509DataType;	/* wsse.h:179 */
struct ds__X509IssuerSerialType;	/* ds.h:102 */
struct ds__DSAKeyValueType;	/* ds.h:123 */
struct ds__RSAKeyValueType;	/* ds.h:126 */
struct xenc__EncryptionPropertyType;	/* xenc.h:84 */
struct xenc__EncryptedType;	/* xenc.h:53 */
struct xenc__EncryptionMethodType;	/* xenc.h:56 */
struct xenc__CipherDataType;	/* xenc.h:59 */
struct xenc__CipherReferenceType;	/* xenc.h:62 */
struct xenc__TransformsType;	/* xenc.h:65 */
struct xenc__AgreementMethodType;	/* xenc.h:74 */
struct xenc__ReferenceType;	/* xenc.h:77 */
struct xenc__EncryptionPropertiesType;	/* xenc.h:80 */
struct __xenc__union_ReferenceList;	/* xenc.h:238 */
struct _xenc__ReferenceList;	/* xenc.h:89 */
struct xenc__EncryptedDataType;	/* xenc.h:68 */
struct xenc__EncryptedKeyType;	/* xenc.h:71 */
struct wsc__SecurityContextTokenType;	/* wsc.h:87 */
union _wsc__union_DerivedKeyTokenType;	/* wsc.h:125 */
struct __wsc__DerivedKeyTokenType_sequence;	/* wsc.h:116 */
struct wsc__DerivedKeyTokenType;	/* wsc.h:109 */
struct wsc__PropertiesType;	/* wsc.h:113 */
struct _wsse__Security;	/* wsse.h:191 */
struct _wsse__Password;	/* wsse.h:129 */
class ns2__Item;	/* CyberSourceTransaction_xml_1.129.h:153 */
class ns2__CCAuthService;	/* CyberSourceTransaction_xml_1.129.h:156 */
class ns2__OCTService;	/* CyberSourceTransaction_xml_1.129.h:159 */
class ns2__VerificationService;	/* CyberSourceTransaction_xml_1.129.h:162 */
class ns2__CCSaleService;	/* CyberSourceTransaction_xml_1.129.h:165 */
class ns2__CCSaleCreditService;	/* CyberSourceTransaction_xml_1.129.h:168 */
class ns2__CCSaleReversalService;	/* CyberSourceTransaction_xml_1.129.h:171 */
class ns2__CCIncrementalAuthService;	/* CyberSourceTransaction_xml_1.129.h:174 */
class ns2__CCCaptureService;	/* CyberSourceTransaction_xml_1.129.h:177 */
class ns2__CCCreditService;	/* CyberSourceTransaction_xml_1.129.h:180 */
class ns2__CCAuthReversalService;	/* CyberSourceTransaction_xml_1.129.h:183 */
class ns2__CCAutoAuthReversalService;	/* CyberSourceTransaction_xml_1.129.h:186 */
class ns2__CCDCCService;	/* CyberSourceTransaction_xml_1.129.h:189 */
class ns2__ServiceFeeCalculateService;	/* CyberSourceTransaction_xml_1.129.h:192 */
class ns2__ECDebitService;	/* CyberSourceTransaction_xml_1.129.h:195 */
class ns2__ECCreditService;	/* CyberSourceTransaction_xml_1.129.h:198 */
class ns2__ECAuthenticateService;	/* CyberSourceTransaction_xml_1.129.h:201 */
class ns2__PayerAuthEnrollService;	/* CyberSourceTransaction_xml_1.129.h:204 */
class ns2__PayerAuthValidateService;	/* CyberSourceTransaction_xml_1.129.h:207 */
class ns2__TaxService;	/* CyberSourceTransaction_xml_1.129.h:210 */
class ns2__DMEService;	/* CyberSourceTransaction_xml_1.129.h:213 */
class ns2__AFSService;	/* CyberSourceTransaction_xml_1.129.h:216 */
class ns2__DAVService;	/* CyberSourceTransaction_xml_1.129.h:219 */
class ns2__ExportService;	/* CyberSourceTransaction_xml_1.129.h:222 */
class ns2__FXRatesService;	/* CyberSourceTransaction_xml_1.129.h:225 */
class ns2__BankTransferService;	/* CyberSourceTransaction_xml_1.129.h:228 */
class ns2__BankTransferRefundService;	/* CyberSourceTransaction_xml_1.129.h:231 */
class ns2__BankTransferRealTimeService;	/* CyberSourceTransaction_xml_1.129.h:234 */
class ns2__DirectDebitMandateService;	/* CyberSourceTransaction_xml_1.129.h:237 */
class ns2__DirectDebitService;	/* CyberSourceTransaction_xml_1.129.h:240 */
class ns2__DirectDebitRefundService;	/* CyberSourceTransaction_xml_1.129.h:243 */
class ns2__DirectDebitValidateService;	/* CyberSourceTransaction_xml_1.129.h:246 */
class ns2__PaySubscriptionCreateService;	/* CyberSourceTransaction_xml_1.129.h:249 */
class ns2__PaySubscriptionUpdateService;	/* CyberSourceTransaction_xml_1.129.h:252 */
class ns2__PaySubscriptionEventUpdateService;	/* CyberSourceTransaction_xml_1.129.h:255 */
class ns2__PaySubscriptionRetrieveService;	/* CyberSourceTransaction_xml_1.129.h:258 */
class ns2__PaySubscriptionDeleteService;	/* CyberSourceTransaction_xml_1.129.h:261 */
class ns2__PayPalPaymentService;	/* CyberSourceTransaction_xml_1.129.h:264 */
class ns2__PayPalCreditService;	/* CyberSourceTransaction_xml_1.129.h:267 */
class ns2__PayPalEcSetService;	/* CyberSourceTransaction_xml_1.129.h:270 */
class ns2__PayPalEcGetDetailsService;	/* CyberSourceTransaction_xml_1.129.h:273 */
class ns2__PayPalEcDoPaymentService;	/* CyberSourceTransaction_xml_1.129.h:276 */
class ns2__PayPalDoCaptureService;	/* CyberSourceTransaction_xml_1.129.h:279 */
class ns2__PayPalAuthReversalService;	/* CyberSourceTransaction_xml_1.129.h:282 */
class ns2__PayPalRefundService;	/* CyberSourceTransaction_xml_1.129.h:285 */
class ns2__PayPalEcOrderSetupService;	/* CyberSourceTransaction_xml_1.129.h:288 */
class ns2__PayPalAuthorizationService;	/* CyberSourceTransaction_xml_1.129.h:291 */
class ns2__PayPalUpdateAgreementService;	/* CyberSourceTransaction_xml_1.129.h:294 */
class ns2__PayPalCreateAgreementService;	/* CyberSourceTransaction_xml_1.129.h:297 */
class ns2__PayPalDoRefTransactionService;	/* CyberSourceTransaction_xml_1.129.h:300 */
class ns2__VoidService;	/* CyberSourceTransaction_xml_1.129.h:303 */
class ns2__PinlessDebitService;	/* CyberSourceTransaction_xml_1.129.h:306 */
class ns2__PinlessDebitValidateService;	/* CyberSourceTransaction_xml_1.129.h:309 */
class ns2__PinlessDebitReversalService;	/* CyberSourceTransaction_xml_1.129.h:312 */
class ns2__PinDebitPurchaseService;	/* CyberSourceTransaction_xml_1.129.h:315 */
class ns2__PinDebitCreditService;	/* CyberSourceTransaction_xml_1.129.h:318 */
class ns2__PinDebitReversalService;	/* CyberSourceTransaction_xml_1.129.h:321 */
class ns2__PayPalButtonCreateService;	/* CyberSourceTransaction_xml_1.129.h:324 */
class ns2__PayPalPreapprovedPaymentService;	/* CyberSourceTransaction_xml_1.129.h:327 */
class ns2__PayPalPreapprovedUpdateService;	/* CyberSourceTransaction_xml_1.129.h:330 */
class ns2__ChinaPaymentService;	/* CyberSourceTransaction_xml_1.129.h:333 */
class ns2__ChinaRefundService;	/* CyberSourceTransaction_xml_1.129.h:336 */
class ns2__BoletoPaymentService;	/* CyberSourceTransaction_xml_1.129.h:339 */
class ns2__PersonalId;	/* CyberSourceTransaction_xml_1.129.h:342 */
class ns2__Address;	/* CyberSourceTransaction_xml_1.129.h:345 */
class ns2__APInitiateService;	/* CyberSourceTransaction_xml_1.129.h:348 */
class ns2__APCheckStatusService;	/* CyberSourceTransaction_xml_1.129.h:351 */
class ns2__RiskUpdateService;	/* CyberSourceTransaction_xml_1.129.h:354 */
class ns2__FraudUpdateService;	/* CyberSourceTransaction_xml_1.129.h:357 */
class ns2__CaseManagementActionService;	/* CyberSourceTransaction_xml_1.129.h:360 */
class ns2__EncryptPaymentDataService;	/* CyberSourceTransaction_xml_1.129.h:363 */
class ns2__InvoiceHeader;	/* CyberSourceTransaction_xml_1.129.h:366 */
class ns2__BusinessRules;	/* CyberSourceTransaction_xml_1.129.h:369 */
class ns2__BillTo;	/* CyberSourceTransaction_xml_1.129.h:372 */
class ns2__ShipTo;	/* CyberSourceTransaction_xml_1.129.h:375 */
class ns2__ShipFrom;	/* CyberSourceTransaction_xml_1.129.h:378 */
class ns2__Card;	/* CyberSourceTransaction_xml_1.129.h:381 */
class ns2__Check;	/* CyberSourceTransaction_xml_1.129.h:384 */
class ns2__BML;	/* CyberSourceTransaction_xml_1.129.h:387 */
class ns2__OtherTax;	/* CyberSourceTransaction_xml_1.129.h:390 */
class ns2__Aft;	/* CyberSourceTransaction_xml_1.129.h:393 */
class ns2__Wallet;	/* CyberSourceTransaction_xml_1.129.h:396 */
class ns2__PurchaseTotals;	/* CyberSourceTransaction_xml_1.129.h:399 */
class ns2__FundingTotals;	/* CyberSourceTransaction_xml_1.129.h:402 */
class ns2__GECC;	/* CyberSourceTransaction_xml_1.129.h:405 */
class ns2__UCAF;	/* CyberSourceTransaction_xml_1.129.h:408 */
class ns2__FundTransfer;	/* CyberSourceTransaction_xml_1.129.h:411 */
class ns2__BankInfo;	/* CyberSourceTransaction_xml_1.129.h:414 */
class ns2__RecurringSubscriptionInfo;	/* CyberSourceTransaction_xml_1.129.h:417 */
class ns2__PaySubscriptionEvent;	/* CyberSourceTransaction_xml_1.129.h:420 */
class ns2__Subscription;	/* CyberSourceTransaction_xml_1.129.h:423 */
class ns2__PaymentNetworkToken;	/* CyberSourceTransaction_xml_1.129.h:426 */
class ns2__DecisionManager;	/* CyberSourceTransaction_xml_1.129.h:429 */
class ns2__DecisionManagerTravelData;	/* CyberSourceTransaction_xml_1.129.h:432 */
class ns2__DecisionManagerTravelLeg;	/* CyberSourceTransaction_xml_1.129.h:435 */
class ns2__Batch;	/* CyberSourceTransaction_xml_1.129.h:438 */
class ns2__PayPal;	/* CyberSourceTransaction_xml_1.129.h:441 */
class ns2__JPO;	/* CyberSourceTransaction_xml_1.129.h:444 */
class ns2__Token;	/* CyberSourceTransaction_xml_1.129.h:447 */
class ns2__AP;	/* CyberSourceTransaction_xml_1.129.h:450 */
class ns2__APDevice;	/* CyberSourceTransaction_xml_1.129.h:453 */
class ns2__APAuthService;	/* CyberSourceTransaction_xml_1.129.h:456 */
class ns2__APAuthReversalService;	/* CyberSourceTransaction_xml_1.129.h:459 */
class ns2__APCaptureService;	/* CyberSourceTransaction_xml_1.129.h:462 */
class ns2__APOptionsService;	/* CyberSourceTransaction_xml_1.129.h:465 */
class ns2__APRefundService;	/* CyberSourceTransaction_xml_1.129.h:468 */
class ns2__APSaleService;	/* CyberSourceTransaction_xml_1.129.h:471 */
class ns2__APCheckOutDetailsService;	/* CyberSourceTransaction_xml_1.129.h:474 */
class ns2__APTransactionDetailsService;	/* CyberSourceTransaction_xml_1.129.h:477 */
class ns2__APConfirmPurchaseService;	/* CyberSourceTransaction_xml_1.129.h:480 */
class ns2__PayPalGetTxnDetailsService;	/* CyberSourceTransaction_xml_1.129.h:483 */
class ns2__PayPalTransactionSearchService;	/* CyberSourceTransaction_xml_1.129.h:486 */
class ns2__Recipient;	/* CyberSourceTransaction_xml_1.129.h:489 */
class ns2__Sender;	/* CyberSourceTransaction_xml_1.129.h:492 */
class ns2__RequestMessage;	/* CyberSourceTransaction_xml_1.129.h:495 */
class ns2__VC;	/* CyberSourceTransaction_xml_1.129.h:498 */
class ns2__DecryptVisaCheckoutDataService;	/* CyberSourceTransaction_xml_1.129.h:501 */
class ns2__DCC;	/* CyberSourceTransaction_xml_1.129.h:504 */
class ns2__Promotion;	/* CyberSourceTransaction_xml_1.129.h:507 */
class ns2__PromotionGroup;	/* CyberSourceTransaction_xml_1.129.h:510 */
class ns2__PromotionGroupReply;	/* CyberSourceTransaction_xml_1.129.h:513 */
class ns2__CCAuthReply;	/* CyberSourceTransaction_xml_1.129.h:516 */
class ns2__OCTReply;	/* CyberSourceTransaction_xml_1.129.h:519 */
class ns2__VerificationReply;	/* CyberSourceTransaction_xml_1.129.h:522 */
class ns2__CCSaleReply;	/* CyberSourceTransaction_xml_1.129.h:525 */
class ns2__CCSaleCreditReply;	/* CyberSourceTransaction_xml_1.129.h:528 */
class ns2__CCSaleReversalReply;	/* CyberSourceTransaction_xml_1.129.h:531 */
class ns2__CCIncrementalAuthReply;	/* CyberSourceTransaction_xml_1.129.h:534 */
class ns2__CCCaptureReply;	/* CyberSourceTransaction_xml_1.129.h:537 */
class ns2__ServiceFeeCalculateReply;	/* CyberSourceTransaction_xml_1.129.h:540 */
class ns2__CCCreditReply;	/* CyberSourceTransaction_xml_1.129.h:543 */
class ns2__PinDebitPurchaseReply;	/* CyberSourceTransaction_xml_1.129.h:546 */
class ns2__PinDebitCreditReply;	/* CyberSourceTransaction_xml_1.129.h:549 */
class ns2__PinDebitReversalReply;	/* CyberSourceTransaction_xml_1.129.h:552 */
class ns2__CCAuthReversalReply;	/* CyberSourceTransaction_xml_1.129.h:555 */
class ns2__CCAutoAuthReversalReply;	/* CyberSourceTransaction_xml_1.129.h:558 */
class ns2__ECDebitReply;	/* CyberSourceTransaction_xml_1.129.h:561 */
class ns2__ECCreditReply;	/* CyberSourceTransaction_xml_1.129.h:564 */
class ns2__ECAuthenticateReply;	/* CyberSourceTransaction_xml_1.129.h:567 */
class ns2__PayerAuthEnrollReply;	/* CyberSourceTransaction_xml_1.129.h:570 */
class ns2__PayerAuthValidateReply;	/* CyberSourceTransaction_xml_1.129.h:573 */
class ns2__TaxReplyItem;	/* CyberSourceTransaction_xml_1.129.h:576 */
class ns2__TaxReply;	/* CyberSourceTransaction_xml_1.129.h:579 */
class ns2__DeviceFingerprint;	/* CyberSourceTransaction_xml_1.129.h:582 */
class ns2__AFSReply;	/* CyberSourceTransaction_xml_1.129.h:585 */
class ns2__DAVReply;	/* CyberSourceTransaction_xml_1.129.h:588 */
class ns2__DeniedPartiesMatch;	/* CyberSourceTransaction_xml_1.129.h:591 */
class ns2__ExportReply;	/* CyberSourceTransaction_xml_1.129.h:594 */
class ns2__FXQuote;	/* CyberSourceTransaction_xml_1.129.h:597 */
class ns2__FXRatesReply;	/* CyberSourceTransaction_xml_1.129.h:600 */
class ns2__BankTransferReply;	/* CyberSourceTransaction_xml_1.129.h:603 */
class ns2__BankTransferRealTimeReply;	/* CyberSourceTransaction_xml_1.129.h:606 */
class ns2__DirectDebitMandateReply;	/* CyberSourceTransaction_xml_1.129.h:609 */
class ns2__BankTransferRefundReply;	/* CyberSourceTransaction_xml_1.129.h:612 */
class ns2__DirectDebitReply;	/* CyberSourceTransaction_xml_1.129.h:615 */
class ns2__DirectDebitValidateReply;	/* CyberSourceTransaction_xml_1.129.h:618 */
class ns2__DirectDebitRefundReply;	/* CyberSourceTransaction_xml_1.129.h:621 */
class ns2__PaySubscriptionCreateReply;	/* CyberSourceTransaction_xml_1.129.h:624 */
class ns2__PaySubscriptionUpdateReply;	/* CyberSourceTransaction_xml_1.129.h:627 */
class ns2__PaySubscriptionEventUpdateReply;	/* CyberSourceTransaction_xml_1.129.h:630 */
class ns2__PaySubscriptionRetrieveReply;	/* CyberSourceTransaction_xml_1.129.h:633 */
class ns2__PaySubscriptionDeleteReply;	/* CyberSourceTransaction_xml_1.129.h:636 */
class ns2__PayPalPaymentReply;	/* CyberSourceTransaction_xml_1.129.h:639 */
class ns2__PayPalCreditReply;	/* CyberSourceTransaction_xml_1.129.h:642 */
class ns2__VoidReply;	/* CyberSourceTransaction_xml_1.129.h:645 */
class ns2__PinlessDebitReply;	/* CyberSourceTransaction_xml_1.129.h:648 */
class ns2__PinlessDebitValidateReply;	/* CyberSourceTransaction_xml_1.129.h:651 */
class ns2__PinlessDebitReversalReply;	/* CyberSourceTransaction_xml_1.129.h:654 */
class ns2__PayPalButtonCreateReply;	/* CyberSourceTransaction_xml_1.129.h:657 */
class ns2__PayPalPreapprovedPaymentReply;	/* CyberSourceTransaction_xml_1.129.h:660 */
class ns2__PayPalPreapprovedUpdateReply;	/* CyberSourceTransaction_xml_1.129.h:663 */
class ns2__PayPalEcSetReply;	/* CyberSourceTransaction_xml_1.129.h:666 */
class ns2__PayPalEcGetDetailsReply;	/* CyberSourceTransaction_xml_1.129.h:669 */
class ns2__PayPalEcDoPaymentReply;	/* CyberSourceTransaction_xml_1.129.h:672 */
class ns2__PayPalDoCaptureReply;	/* CyberSourceTransaction_xml_1.129.h:675 */
class ns2__PayPalAuthReversalReply;	/* CyberSourceTransaction_xml_1.129.h:678 */
class ns2__PayPalRefundReply;	/* CyberSourceTransaction_xml_1.129.h:681 */
class ns2__PayPalEcOrderSetupReply;	/* CyberSourceTransaction_xml_1.129.h:684 */
class ns2__PayPalAuthorizationReply;	/* CyberSourceTransaction_xml_1.129.h:687 */
class ns2__PayPalUpdateAgreementReply;	/* CyberSourceTransaction_xml_1.129.h:690 */
class ns2__PayPalCreateAgreementReply;	/* CyberSourceTransaction_xml_1.129.h:693 */
class ns2__PayPalDoRefTransactionReply;	/* CyberSourceTransaction_xml_1.129.h:696 */
class ns2__RiskUpdateReply;	/* CyberSourceTransaction_xml_1.129.h:699 */
class ns2__FraudUpdateReply;	/* CyberSourceTransaction_xml_1.129.h:702 */
class ns2__CaseManagementActionReply;	/* CyberSourceTransaction_xml_1.129.h:705 */
class ns2__RuleResultItem;	/* CyberSourceTransaction_xml_1.129.h:708 */
class ns2__RuleResultItems;	/* CyberSourceTransaction_xml_1.129.h:711 */
class ns2__DecisionReply;	/* CyberSourceTransaction_xml_1.129.h:714 */
class ns2__AdditionalFields;	/* CyberSourceTransaction_xml_1.129.h:717 */
class ns2__Field;	/* CyberSourceTransaction_xml_1.129.h:720 */
class ns2__DMEReply;	/* CyberSourceTransaction_xml_1.129.h:723 */
class ns2__ProfileReply;	/* CyberSourceTransaction_xml_1.129.h:726 */
class ns2__CCDCCReply;	/* CyberSourceTransaction_xml_1.129.h:729 */
class ns2__CCDCCUpdateReply;	/* CyberSourceTransaction_xml_1.129.h:732 */
class ns2__ChinaPaymentReply;	/* CyberSourceTransaction_xml_1.129.h:735 */
class ns2__ChinaRefundReply;	/* CyberSourceTransaction_xml_1.129.h:738 */
class ns2__BoletoPaymentReply;	/* CyberSourceTransaction_xml_1.129.h:741 */
class ns2__APInitiateReply;	/* CyberSourceTransaction_xml_1.129.h:744 */
class ns2__APCheckStatusReply;	/* CyberSourceTransaction_xml_1.129.h:747 */
class ns2__APReply;	/* CyberSourceTransaction_xml_1.129.h:750 */
class ns2__APAuthReply;	/* CyberSourceTransaction_xml_1.129.h:753 */
class ns2__APAuthReversalReply;	/* CyberSourceTransaction_xml_1.129.h:756 */
class ns2__APCaptureReply;	/* CyberSourceTransaction_xml_1.129.h:759 */
class ns2__APOptionsReply;	/* CyberSourceTransaction_xml_1.129.h:762 */
class ns2__APOptionsOption;	/* CyberSourceTransaction_xml_1.129.h:765 */
class ns2__APRefundReply;	/* CyberSourceTransaction_xml_1.129.h:768 */
class ns2__APSaleReply;	/* CyberSourceTransaction_xml_1.129.h:771 */
class ns2__APCheckOutDetailsReply;	/* CyberSourceTransaction_xml_1.129.h:774 */
class ns2__APTransactionDetailsReply;	/* CyberSourceTransaction_xml_1.129.h:777 */
class ns2__APConfirmPurchaseReply;	/* CyberSourceTransaction_xml_1.129.h:780 */
class ns2__ReplyMessage;	/* CyberSourceTransaction_xml_1.129.h:783 */
class ns2__FaultDetails;	/* CyberSourceTransaction_xml_1.129.h:786 */
class ns2__AirlineData;	/* CyberSourceTransaction_xml_1.129.h:789 */
class ns2__Leg;	/* CyberSourceTransaction_xml_1.129.h:792 */
class ns2__AncillaryData;	/* CyberSourceTransaction_xml_1.129.h:795 */
class ns2__Service;	/* CyberSourceTransaction_xml_1.129.h:798 */
class ns2__LodgingData;	/* CyberSourceTransaction_xml_1.129.h:801 */
class ns2__Pos;	/* CyberSourceTransaction_xml_1.129.h:804 */
class ns2__EncryptedPayment;	/* CyberSourceTransaction_xml_1.129.h:807 */
class ns2__Installment;	/* CyberSourceTransaction_xml_1.129.h:810 */
class ns2__MerchantDefinedData;	/* CyberSourceTransaction_xml_1.129.h:816 */
class ns2__MerchantSecureData;	/* CyberSourceTransaction_xml_1.129.h:819 */
class ns2__ReplyReserved;	/* CyberSourceTransaction_xml_1.129.h:822 */
class ns2__RequestReserved;	/* CyberSourceTransaction_xml_1.129.h:825 */
class ns2__PayPalGetTxnDetailsReply;	/* CyberSourceTransaction_xml_1.129.h:828 */
class ns2__PayPalTransactionSearchReply;	/* CyberSourceTransaction_xml_1.129.h:831 */
class ns2__PaypalTransaction;	/* CyberSourceTransaction_xml_1.129.h:834 */
class ns2__CCDCCUpdateService;	/* CyberSourceTransaction_xml_1.129.h:837 */
class ns2__ServiceFee;	/* CyberSourceTransaction_xml_1.129.h:840 */
class ns2__EmvRequest;	/* CyberSourceTransaction_xml_1.129.h:843 */
class ns2__EmvReply;	/* CyberSourceTransaction_xml_1.129.h:846 */
class ns2__OriginalTransaction;	/* CyberSourceTransaction_xml_1.129.h:849 */
class ns2__HostedDataCreateService;	/* CyberSourceTransaction_xml_1.129.h:852 */
class ns2__HostedDataRetrieveService;	/* CyberSourceTransaction_xml_1.129.h:855 */
class ns2__HostedDataCreateReply;	/* CyberSourceTransaction_xml_1.129.h:858 */
class ns2__HostedDataRetrieveReply;	/* CyberSourceTransaction_xml_1.129.h:861 */
class ns2__AutoRentalData;	/* CyberSourceTransaction_xml_1.129.h:864 */
class ns2__VCReply;	/* CyberSourceTransaction_xml_1.129.h:867 */
class ns2__VCCardArt;	/* CyberSourceTransaction_xml_1.129.h:870 */
class ns2__VCCustomData;	/* CyberSourceTransaction_xml_1.129.h:873 */
class ns2__DecryptVisaCheckoutDataReply;	/* CyberSourceTransaction_xml_1.129.h:876 */
class ns2__EncryptPaymentDataReply;	/* CyberSourceTransaction_xml_1.129.h:879 */
class ns2__BinLookupService;	/* CyberSourceTransaction_xml_1.129.h:882 */
class ns2__BinLookupReply;	/* CyberSourceTransaction_xml_1.129.h:885 */
class ns2__issuer;	/* CyberSourceTransaction_xml_1.129.h:888 */
class ns2__MDDField;	/* CyberSourceTransaction_xml_1.129.h:813 */
struct __ns1__runTransaction;	/* CyberSourceTransaction_xml_1.129.h:10712 */

/* wsu.h:76 */
#ifndef SOAP_TYPE__wsu__Timestamp
#define SOAP_TYPE__wsu__Timestamp (12)
/* complex XSD type 'wsu:Timestamp': */
struct _wsu__Timestamp {
      public:
        /** Optional attribute 'wsu:Id' of XSD type 'xsd:string' */
        char *wsu__Id;
        /** Optional element 'wsu:Created' of XSD type 'xsd:string' */
        char *Created;
        /** Optional element 'wsu:Expires' of XSD type 'xsd:string' */
        char *Expires;
      public:
        /** Return unique type id SOAP_TYPE__wsu__Timestamp */
        int soap_type() const { return SOAP_TYPE__wsu__Timestamp; }
        /** Constructor with member initializations */
        _wsu__Timestamp()
        {
          wsu__Id = (char *)0;
          Created = (char *)0;
          Expires = (char *)0;
        }
        /** Friend allocator used by soap_new__wsu__Timestamp(struct soap*, int) */
        friend SOAP_FMAC1 _wsu__Timestamp * SOAP_FMAC2 soap_instantiate__wsu__Timestamp(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:57 */
#ifndef SOAP_TYPE_wsse__EncodedString
#define SOAP_TYPE_wsse__EncodedString (13)
/* simple XSD type 'wsse:EncodedString': */
struct wsse__EncodedString {
      public:
        /** Simple content of XSD type 'xsd:string' wrapped by this struct */
        char *__item;
        /** Optional attribute 'EncodingType' of XSD type 'xsd:string' */
        char *EncodingType;
        /** Optional attribute 'wsu:Id' of XSD type 'xsd:string' */
        char *wsu__Id;
      public:
        /** Return unique type id SOAP_TYPE_wsse__EncodedString */
        int soap_type() const { return SOAP_TYPE_wsse__EncodedString; }
        /** Constructor with member initializations */
        wsse__EncodedString()
        {
          __item = (char *)0;
          EncodingType = (char *)0;
          wsu__Id = (char *)0;
        }
        /** Friend allocator used by soap_new_wsse__EncodedString(struct soap*, int) */
        friend SOAP_FMAC1 wsse__EncodedString * SOAP_FMAC2 soap_instantiate_wsse__EncodedString(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:128 */
#ifndef SOAP_TYPE__wsse__UsernameToken
#define SOAP_TYPE__wsse__UsernameToken (15)
/* complex XSD type 'wsse:UsernameToken': */
struct _wsse__UsernameToken {
      public:
        /** Optional element 'wsse:Username' of XSD type 'xsd:string' */
        char *Username;
        /** Optional element 'wsse:Password' of XSD type 'wsse:Password' */
        struct _wsse__Password *Password;
        /** Optional element 'wsse:Nonce' of XSD type 'wsse:EncodedString' */
        struct wsse__EncodedString *Nonce;
        /** Optional element 'wsu:Created' of XSD type 'xsd:string' */
        char *wsu__Created;
        /** Optional attribute 'wsu:Id' of XSD type 'xsd:string' */
        char *wsu__Id;
      public:
        /** Return unique type id SOAP_TYPE__wsse__UsernameToken */
        int soap_type() const { return SOAP_TYPE__wsse__UsernameToken; }
        /** Constructor with member initializations */
        _wsse__UsernameToken()
        {
          Username = (char *)0;
          Password = (struct _wsse__Password *)0;
          Nonce = (struct wsse__EncodedString *)0;
          wsu__Created = (char *)0;
          wsu__Id = (char *)0;
        }
        /** Friend allocator used by soap_new__wsse__UsernameToken(struct soap*, int) */
        friend SOAP_FMAC1 _wsse__UsernameToken * SOAP_FMAC2 soap_instantiate__wsse__UsernameToken(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:139 */
#ifndef SOAP_TYPE__wsse__BinarySecurityToken
#define SOAP_TYPE__wsse__BinarySecurityToken (19)
/* simple XSD type 'wsse:BinarySecurityToken': */
struct _wsse__BinarySecurityToken {
      public:
        /** Simple content of XSD type 'xsd:string' wrapped by this struct */
        char *__item;
        /** Optional attribute 'wsu:Id' of XSD type 'xsd:string' */
        char *wsu__Id;
        /** Optional attribute 'ValueType' of XSD type 'xsd:string' */
        char *ValueType;
        /** Optional attribute 'EncodingType' of XSD type 'xsd:string' */
        char *EncodingType;
      public:
        /** Return unique type id SOAP_TYPE__wsse__BinarySecurityToken */
        int soap_type() const { return SOAP_TYPE__wsse__BinarySecurityToken; }
        /** Constructor with member initializations */
        _wsse__BinarySecurityToken()
        {
          __item = (char *)0;
          wsu__Id = (char *)0;
          ValueType = (char *)0;
          EncodingType = (char *)0;
        }
        /** Friend allocator used by soap_new__wsse__BinarySecurityToken(struct soap*, int) */
        friend SOAP_FMAC1 _wsse__BinarySecurityToken * SOAP_FMAC2 soap_instantiate__wsse__BinarySecurityToken(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:149 */
#ifndef SOAP_TYPE__wsse__Reference
#define SOAP_TYPE__wsse__Reference (20)
/* complex XSD type 'wsse:Reference': */
struct _wsse__Reference {
      public:
        /** Optional attribute 'URI' of XSD type 'xsd:string' */
        char *URI;
        /** Optional attribute 'ValueType' of XSD type 'xsd:string' */
        char *ValueType;
      public:
        /** Return unique type id SOAP_TYPE__wsse__Reference */
        int soap_type() const { return SOAP_TYPE__wsse__Reference; }
        /** Constructor with member initializations */
        _wsse__Reference()
        {
          URI = (char *)0;
          ValueType = (char *)0;
        }
        /** Friend allocator used by soap_new__wsse__Reference(struct soap*, int) */
        friend SOAP_FMAC1 _wsse__Reference * SOAP_FMAC2 soap_instantiate__wsse__Reference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:157 */
#ifndef SOAP_TYPE__wsse__Embedded
#define SOAP_TYPE__wsse__Embedded (21)
/* complex XSD type 'wsse:Embedded': */
struct _wsse__Embedded {
      public:
        /** Optional attribute 'wsu:Id' of XSD type 'xsd:string' */
        char *wsu__Id;
        /** Optional attribute 'ValueType' of XSD type 'xsd:string' */
        char *ValueType;
      public:
        /** Return unique type id SOAP_TYPE__wsse__Embedded */
        int soap_type() const { return SOAP_TYPE__wsse__Embedded; }
        /** Constructor with member initializations */
        _wsse__Embedded()
        {
          wsu__Id = (char *)0;
          ValueType = (char *)0;
        }
        /** Friend allocator used by soap_new__wsse__Embedded(struct soap*, int) */
        friend SOAP_FMAC1 _wsse__Embedded * SOAP_FMAC2 soap_instantiate__wsse__Embedded(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:166 */
#ifndef SOAP_TYPE__wsse__KeyIdentifier
#define SOAP_TYPE__wsse__KeyIdentifier (22)
/* simple XSD type 'wsse:KeyIdentifier': */
struct _wsse__KeyIdentifier {
      public:
        /** Simple content of XSD type 'xsd:string' wrapped by this struct */
        char *__item;
        /** Optional attribute 'wsu:Id' of XSD type 'xsd:string' */
        char *wsu__Id;
        /** Optional attribute 'ValueType' of XSD type 'xsd:string' */
        char *ValueType;
        /** Optional attribute 'EncodingType' of XSD type 'xsd:string' */
        char *EncodingType;
      public:
        /** Return unique type id SOAP_TYPE__wsse__KeyIdentifier */
        int soap_type() const { return SOAP_TYPE__wsse__KeyIdentifier; }
        /** Constructor with member initializations */
        _wsse__KeyIdentifier()
        {
          __item = (char *)0;
          wsu__Id = (char *)0;
          ValueType = (char *)0;
          EncodingType = (char *)0;
        }
        /** Friend allocator used by soap_new__wsse__KeyIdentifier(struct soap*, int) */
        friend SOAP_FMAC1 _wsse__KeyIdentifier * SOAP_FMAC2 soap_instantiate__wsse__KeyIdentifier(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:176 */
#ifndef SOAP_TYPE__wsse__SecurityTokenReference
#define SOAP_TYPE__wsse__SecurityTokenReference (23)
/* complex XSD type 'wsse:SecurityTokenReference': */
struct _wsse__SecurityTokenReference {
      public:
        /** Optional element 'wsse:Reference' of XSD type 'wsse:Reference' */
        struct _wsse__Reference *Reference;
        /** Optional element 'wsse:KeyIdentifier' of XSD type 'wsse:KeyIdentifier' */
        struct _wsse__KeyIdentifier *KeyIdentifier;
        /** Optional element 'wsse:Embedded' of XSD type 'wsse:Embedded' */
        struct _wsse__Embedded *Embedded;
        /** Optional element 'ds:X509Data' of XSD type 'ds:X509DataType' */
        struct ds__X509DataType *ds__X509Data;
        /** Optional attribute 'wsu:Id' of XSD type 'xsd:string' */
        char *wsu__Id;
        /** Optional attribute 'wsc:Instance' of XSD type 'xsd:string' */
        char *wsc__Instance;
        /** Optional attribute 'Usage' of XSD type 'xsd:string' */
        char *Usage;
      public:
        /** Return unique type id SOAP_TYPE__wsse__SecurityTokenReference */
        int soap_type() const { return SOAP_TYPE__wsse__SecurityTokenReference; }
        /** Constructor with member initializations */
        _wsse__SecurityTokenReference()
        {
          Reference = (struct _wsse__Reference *)0;
          KeyIdentifier = (struct _wsse__KeyIdentifier *)0;
          Embedded = (struct _wsse__Embedded *)0;
          ds__X509Data = (struct ds__X509DataType *)0;
          wsu__Id = (char *)0;
          wsc__Instance = (char *)0;
          Usage = (char *)0;
        }
        /** Friend allocator used by soap_new__wsse__SecurityTokenReference(struct soap*, int) */
        friend SOAP_FMAC1 _wsse__SecurityTokenReference * SOAP_FMAC2 soap_instantiate__wsse__SecurityTokenReference(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:46 */
#ifndef SOAP_TYPE_ds__SignatureType
#define SOAP_TYPE_ds__SignatureType (30)
/* complex XSD type 'ds:SignatureType': */
struct ds__SignatureType {
      public:
        /** Optional element 'ds:SignedInfo' of XSD type 'ds:SignedInfoType' */
        struct ds__SignedInfoType *SignedInfo;
        /** Optional element 'ds:SignatureValue' of XSD type 'ds:SignatureValue' */
        char *SignatureValue;
        /** Optional element 'ds:KeyInfo' of XSD type 'ds:KeyInfoType' */
        struct ds__KeyInfoType *KeyInfo;
        /** Optional attribute 'Id' of XSD type 'xsd:string' */
        char *Id;
      public:
        /** Return unique type id SOAP_TYPE_ds__SignatureType */
        int soap_type() const { return SOAP_TYPE_ds__SignatureType; }
        /** Constructor with member initializations */
        ds__SignatureType()
        {
          SignedInfo = (struct ds__SignedInfoType *)0;
          SignatureValue = (char *)0;
          KeyInfo = (struct ds__KeyInfoType *)0;
          Id = (char *)0;
        }
        /** Friend allocator used by soap_new_ds__SignatureType(struct soap*, int) */
        friend SOAP_FMAC1 ds__SignatureType * SOAP_FMAC2 soap_instantiate_ds__SignatureType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* c14n.h:24 */
#ifndef SOAP_TYPE__c14n__InclusiveNamespaces
#define SOAP_TYPE__c14n__InclusiveNamespaces (40)
/* complex XSD type 'c14n:InclusiveNamespaces': */
struct _c14n__InclusiveNamespaces {
      public:
        /** Optional attribute 'PrefixList' of XSD type 'xsd:string' */
        char *PrefixList;
      public:
        /** Return unique type id SOAP_TYPE__c14n__InclusiveNamespaces */
        int soap_type() const { return SOAP_TYPE__c14n__InclusiveNamespaces; }
        /** Constructor with member initializations */
        _c14n__InclusiveNamespaces()
        {
          PrefixList = (char *)0;
        }
        /** Friend allocator used by soap_new__c14n__InclusiveNamespaces(struct soap*, int) */
        friend SOAP_FMAC1 _c14n__InclusiveNamespaces * SOAP_FMAC2 soap_instantiate__c14n__InclusiveNamespaces(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:73 */
#ifndef SOAP_TYPE_ds__TransformType
#define SOAP_TYPE_ds__TransformType (41)
/* complex XSD type 'ds:TransformType': */
struct ds__TransformType {
      public:
        /** Optional element 'c14n:InclusiveNamespaces' of XSD type 'c14n:InclusiveNamespaces' */
        struct _c14n__InclusiveNamespaces *c14n__InclusiveNamespaces;
        char *__any;
        /** Optional attribute 'Algorithm' of XSD type 'xsd:string' */
        char *Algorithm;
      public:
        /** Return unique type id SOAP_TYPE_ds__TransformType */
        int soap_type() const { return SOAP_TYPE_ds__TransformType; }
        /** Constructor with member initializations */
        ds__TransformType()
        {
          c14n__InclusiveNamespaces = (struct _c14n__InclusiveNamespaces *)0;
          __any = (char *)0;
          Algorithm = (char *)0;
        }
        /** Friend allocator used by soap_new_ds__TransformType(struct soap*, int) */
        friend SOAP_FMAC1 ds__TransformType * SOAP_FMAC2 soap_instantiate_ds__TransformType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:48 */
#ifndef SOAP_TYPE_ds__KeyInfoType
#define SOAP_TYPE_ds__KeyInfoType (33)
/* complex XSD type 'ds:KeyInfoType': */
struct ds__KeyInfoType {
      public:
        /** Optional element 'ds:KeyName' of XSD type 'xsd:string' */
        char *KeyName;
        /** Optional element 'ds:KeyValue' of XSD type 'ds:KeyValueType' */
        struct ds__KeyValueType *KeyValue;
        /** Optional element 'ds:RetrievalMethod' of XSD type 'ds:RetrievalMethodType' */
        struct ds__RetrievalMethodType *RetrievalMethod;
        /** Optional element 'ds:X509Data' of XSD type 'ds:X509DataType' */
        struct ds__X509DataType *X509Data;
        /** Optional element 'wsse:SecurityTokenReference' of XSD type 'wsse:SecurityTokenReference' */
        struct _wsse__SecurityTokenReference *wsse__SecurityTokenReference;
        /** Optional attribute 'Id' of XSD type 'xsd:string' */
        char *Id;
      public:
        /** Return unique type id SOAP_TYPE_ds__KeyInfoType */
        int soap_type() const { return SOAP_TYPE_ds__KeyInfoType; }
        /** Constructor with member initializations */
        ds__KeyInfoType()
        {
          KeyName = (char *)0;
          KeyValue = (struct ds__KeyValueType *)0;
          RetrievalMethod = (struct ds__RetrievalMethodType *)0;
          X509Data = (struct ds__X509DataType *)0;
          wsse__SecurityTokenReference = (struct _wsse__SecurityTokenReference *)0;
          Id = (char *)0;
        }
        /** Friend allocator used by soap_new_ds__KeyInfoType(struct soap*, int) */
        friend SOAP_FMAC1 ds__KeyInfoType * SOAP_FMAC2 soap_instantiate_ds__KeyInfoType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:46 */
#ifndef SOAP_TYPE_ds__SignedInfoType
#define SOAP_TYPE_ds__SignedInfoType (31)
/* complex XSD type 'ds:SignedInfoType': */
struct ds__SignedInfoType {
      public:
        /** Required element 'ds:CanonicalizationMethod' of XSD type 'ds:CanonicalizationMethodType' */
        struct ds__CanonicalizationMethodType *CanonicalizationMethod;
        /** Required element 'ds:SignatureMethod' of XSD type 'ds:SignatureMethodType' */
        struct ds__SignatureMethodType *SignatureMethod;
        /** Sequence of elements 'ds:Reference' of XSD type 'ds:ReferenceType' stored in dynamic array Reference of length __sizeReference */
        int __sizeReference;
        struct ds__ReferenceType **Reference;
        /** Optional attribute 'Id' of XSD type 'xsd:string' */
        char *Id;
      public:
        /** Return unique type id SOAP_TYPE_ds__SignedInfoType */
        int soap_type() const { return SOAP_TYPE_ds__SignedInfoType; }
        /** Constructor with member initializations */
        ds__SignedInfoType()
        {
          CanonicalizationMethod = (struct ds__CanonicalizationMethodType *)0;
          SignatureMethod = (struct ds__SignatureMethodType *)0;
          __sizeReference = 0;
          Reference = NULL;
          Id = (char *)0;
        }
        /** Friend allocator used by soap_new_ds__SignedInfoType(struct soap*, int) */
        friend SOAP_FMAC1 ds__SignedInfoType * SOAP_FMAC2 soap_instantiate_ds__SignedInfoType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:59 */
#ifndef SOAP_TYPE_ds__CanonicalizationMethodType
#define SOAP_TYPE_ds__CanonicalizationMethodType (36)
/* complex XSD type 'ds:CanonicalizationMethodType': */
struct ds__CanonicalizationMethodType {
      public:
        /** Required attribute 'Algorithm' of XSD type 'xsd:string' */
        char *Algorithm;
        /** Optional element 'c14n:InclusiveNamespaces' of XSD type 'c14n:InclusiveNamespaces' */
        struct _c14n__InclusiveNamespaces *c14n__InclusiveNamespaces;
      public:
        /** Return unique type id SOAP_TYPE_ds__CanonicalizationMethodType */
        int soap_type() const { return SOAP_TYPE_ds__CanonicalizationMethodType; }
        /** Constructor with member initializations */
        ds__CanonicalizationMethodType()
        {
          Algorithm = (char *)0;
          c14n__InclusiveNamespaces = (struct _c14n__InclusiveNamespaces *)0;
        }
        /** Friend allocator used by soap_new_ds__CanonicalizationMethodType(struct soap*, int) */
        friend SOAP_FMAC1 ds__CanonicalizationMethodType * SOAP_FMAC2 soap_instantiate_ds__CanonicalizationMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:62 */
#ifndef SOAP_TYPE_ds__SignatureMethodType
#define SOAP_TYPE_ds__SignatureMethodType (37)
/* complex XSD type 'ds:SignatureMethodType': */
struct ds__SignatureMethodType {
      public:
        /** Optional element 'ds:HMACOutputLength' of XSD type 'xsd:int' */
        int *HMACOutputLength;
        /** Required attribute 'Algorithm' of XSD type 'xsd:string' */
        char *Algorithm;
      public:
        /** Return unique type id SOAP_TYPE_ds__SignatureMethodType */
        int soap_type() const { return SOAP_TYPE_ds__SignatureMethodType; }
        /** Constructor with member initializations */
        ds__SignatureMethodType()
        {
          HMACOutputLength = (int *)0;
          Algorithm = (char *)0;
        }
        /** Friend allocator used by soap_new_ds__SignatureMethodType(struct soap*, int) */
        friend SOAP_FMAC1 ds__SignatureMethodType * SOAP_FMAC2 soap_instantiate_ds__SignatureMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:65 */
#ifndef SOAP_TYPE_ds__ReferenceType
#define SOAP_TYPE_ds__ReferenceType (38)
/* complex XSD type 'ds:ReferenceType': */
struct ds__ReferenceType {
      public:
        /** Optional element 'ds:Transforms' of XSD type 'ds:TransformsType' */
        struct ds__TransformsType *Transforms;
        /** Required element 'ds:DigestMethod' of XSD type 'ds:DigestMethodType' */
        struct ds__DigestMethodType *DigestMethod;
        /** Required element 'ds:DigestValue' of XSD type 'xsd:string' */
        char *DigestValue;
        /** Optional attribute 'Id' of XSD type 'xsd:string' */
        char *Id;
        /** Optional attribute 'URI' of XSD type 'xsd:string' */
        char *URI;
        /** Optional attribute 'Type' of XSD type 'xsd:string' */
        char *Type;
      public:
        /** Return unique type id SOAP_TYPE_ds__ReferenceType */
        int soap_type() const { return SOAP_TYPE_ds__ReferenceType; }
        /** Constructor with member initializations */
        ds__ReferenceType()
        {
          Transforms = (struct ds__TransformsType *)0;
          DigestMethod = (struct ds__DigestMethodType *)0;
          DigestValue = (char *)0;
          Id = (char *)0;
          URI = (char *)0;
          Type = (char *)0;
        }
        /** Friend allocator used by soap_new_ds__ReferenceType(struct soap*, int) */
        friend SOAP_FMAC1 ds__ReferenceType * SOAP_FMAC2 soap_instantiate_ds__ReferenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:68 */
#ifndef SOAP_TYPE_ds__TransformsType
#define SOAP_TYPE_ds__TransformsType (39)
/* complex XSD type 'ds:TransformsType': */
struct ds__TransformsType {
      public:
        /** Sequence of elements 'ds:Transform' of XSD type 'ds:TransformType' stored in dynamic array Transform of length __sizeTransform */
        int __sizeTransform;
        struct ds__TransformType *Transform;
      public:
        /** Return unique type id SOAP_TYPE_ds__TransformsType */
        int soap_type() const { return SOAP_TYPE_ds__TransformsType; }
        /** Constructor with member initializations */
        ds__TransformsType()
        {
          __sizeTransform = 0;
          Transform = NULL;
        }
        /** Friend allocator used by soap_new_ds__TransformsType(struct soap*, int) */
        friend SOAP_FMAC1 ds__TransformsType * SOAP_FMAC2 soap_instantiate_ds__TransformsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:79 */
#ifndef SOAP_TYPE_ds__DigestMethodType
#define SOAP_TYPE_ds__DigestMethodType (44)
/* complex XSD type 'ds:DigestMethodType': */
struct ds__DigestMethodType {
      public:
        /** Required attribute 'Algorithm' of XSD type 'xsd:string' */
        char *Algorithm;
      public:
        /** Return unique type id SOAP_TYPE_ds__DigestMethodType */
        int soap_type() const { return SOAP_TYPE_ds__DigestMethodType; }
        /** Constructor with member initializations */
        ds__DigestMethodType()
        {
          Algorithm = (char *)0;
        }
        /** Friend allocator used by soap_new_ds__DigestMethodType(struct soap*, int) */
        friend SOAP_FMAC1 ds__DigestMethodType * SOAP_FMAC2 soap_instantiate_ds__DigestMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:85 */
#ifndef SOAP_TYPE_ds__KeyValueType
#define SOAP_TYPE_ds__KeyValueType (45)
/* complex XSD type 'ds:KeyValueType': */
struct ds__KeyValueType {
      public:
        /** Optional element 'ds:DSAKeyValue' of XSD type 'ds:DSAKeyValueType' */
        struct ds__DSAKeyValueType *DSAKeyValue;
        /** Optional element 'ds:RSAKeyValue' of XSD type 'ds:RSAKeyValueType' */
        struct ds__RSAKeyValueType *RSAKeyValue;
      public:
        /** Return unique type id SOAP_TYPE_ds__KeyValueType */
        int soap_type() const { return SOAP_TYPE_ds__KeyValueType; }
        /** Constructor with member initializations */
        ds__KeyValueType()
        {
          DSAKeyValue = (struct ds__DSAKeyValueType *)0;
          RSAKeyValue = (struct ds__RSAKeyValueType *)0;
        }
        /** Friend allocator used by soap_new_ds__KeyValueType(struct soap*, int) */
        friend SOAP_FMAC1 ds__KeyValueType * SOAP_FMAC2 soap_instantiate_ds__KeyValueType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:86 */
#ifndef SOAP_TYPE_ds__RetrievalMethodType
#define SOAP_TYPE_ds__RetrievalMethodType (47)
/* complex XSD type 'ds:RetrievalMethodType': */
struct ds__RetrievalMethodType {
      public:
        /** Optional element 'ds:Transforms' of XSD type 'ds:TransformsType' */
        struct ds__TransformsType *Transforms;
        /** Optional attribute 'URI' of XSD type 'xsd:string' */
        char *URI;
        /** Optional attribute 'Type' of XSD type 'xsd:string' */
        char *Type;
      public:
        /** Return unique type id SOAP_TYPE_ds__RetrievalMethodType */
        int soap_type() const { return SOAP_TYPE_ds__RetrievalMethodType; }
        /** Constructor with member initializations */
        ds__RetrievalMethodType()
        {
          Transforms = (struct ds__TransformsType *)0;
          URI = (char *)0;
          Type = (char *)0;
        }
        /** Friend allocator used by soap_new_ds__RetrievalMethodType(struct soap*, int) */
        friend SOAP_FMAC1 ds__RetrievalMethodType * SOAP_FMAC2 soap_instantiate_ds__RetrievalMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:179 */
#ifndef SOAP_TYPE_ds__X509DataType
#define SOAP_TYPE_ds__X509DataType (27)
/* complex XSD type 'ds:X509DataType': */
struct ds__X509DataType {
      public:
        /** Optional element 'ds:X509IssuerSerial' of XSD type 'ds:X509IssuerSerialType' */
        struct ds__X509IssuerSerialType *X509IssuerSerial;
        /** Optional element 'ds:X509SKI' of XSD type 'xsd:string' */
        char *X509SKI;
        /** Optional element 'ds:X509SubjectName' of XSD type 'xsd:string' */
        char *X509SubjectName;
        /** Optional element 'ds:X509Certificate' of XSD type 'xsd:string' */
        char *X509Certificate;
        /** Optional element 'ds:X509CRL' of XSD type 'xsd:string' */
        char *X509CRL;
      public:
        /** Return unique type id SOAP_TYPE_ds__X509DataType */
        int soap_type() const { return SOAP_TYPE_ds__X509DataType; }
        /** Constructor with member initializations */
        ds__X509DataType()
        {
          X509IssuerSerial = (struct ds__X509IssuerSerialType *)0;
          X509SKI = (char *)0;
          X509SubjectName = (char *)0;
          X509Certificate = (char *)0;
          X509CRL = (char *)0;
        }
        /** Friend allocator used by soap_new_ds__X509DataType(struct soap*, int) */
        friend SOAP_FMAC1 ds__X509DataType * SOAP_FMAC2 soap_instantiate_ds__X509DataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:102 */
#ifndef SOAP_TYPE_ds__X509IssuerSerialType
#define SOAP_TYPE_ds__X509IssuerSerialType (51)
/* complex XSD type 'ds:X509IssuerSerialType': */
struct ds__X509IssuerSerialType {
      public:
        /** Required element 'ds:X509IssuerName' of XSD type 'xsd:string' */
        char *X509IssuerName;
        /** Required element 'ds:X509SerialNumber' of XSD type 'xsd:string' */
        char *X509SerialNumber;
      public:
        /** Return unique type id SOAP_TYPE_ds__X509IssuerSerialType */
        int soap_type() const { return SOAP_TYPE_ds__X509IssuerSerialType; }
        /** Constructor with member initializations */
        ds__X509IssuerSerialType()
        {
          X509IssuerName = (char *)0;
          X509SerialNumber = (char *)0;
        }
        /** Friend allocator used by soap_new_ds__X509IssuerSerialType(struct soap*, int) */
        friend SOAP_FMAC1 ds__X509IssuerSerialType * SOAP_FMAC2 soap_instantiate_ds__X509IssuerSerialType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:123 */
#ifndef SOAP_TYPE_ds__DSAKeyValueType
#define SOAP_TYPE_ds__DSAKeyValueType (52)
/* complex XSD type 'ds:DSAKeyValueType': */
struct ds__DSAKeyValueType {
      public:
        /** Optional element 'ds:G' of XSD type 'xsd:string' */
        char *G;
        /** Required element 'ds:Y' of XSD type 'xsd:string' */
        char *Y;
        /** Optional element 'ds:J' of XSD type 'xsd:string' */
        char *J;
        /** Required element 'ds:P' of XSD type 'xsd:string' */
        char *P;
        /** Required element 'ds:Q' of XSD type 'xsd:string' */
        char *Q;
        /** Required element 'ds:Seed' of XSD type 'xsd:string' */
        char *Seed;
        /** Required element 'ds:PgenCounter' of XSD type 'xsd:string' */
        char *PgenCounter;
      public:
        /** Return unique type id SOAP_TYPE_ds__DSAKeyValueType */
        int soap_type() const { return SOAP_TYPE_ds__DSAKeyValueType; }
        /** Constructor with member initializations */
        ds__DSAKeyValueType()
        {
          G = (char *)0;
          Y = (char *)0;
          J = (char *)0;
          P = (char *)0;
          Q = (char *)0;
          Seed = (char *)0;
          PgenCounter = (char *)0;
        }
        /** Friend allocator used by soap_new_ds__DSAKeyValueType(struct soap*, int) */
        friend SOAP_FMAC1 ds__DSAKeyValueType * SOAP_FMAC2 soap_instantiate_ds__DSAKeyValueType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* ds.h:126 */
#ifndef SOAP_TYPE_ds__RSAKeyValueType
#define SOAP_TYPE_ds__RSAKeyValueType (53)
/* complex XSD type 'ds:RSAKeyValueType': */
struct ds__RSAKeyValueType {
      public:
        /** Required element 'ds:Modulus' of XSD type 'xsd:string' */
        char *Modulus;
        /** Required element 'ds:Exponent' of XSD type 'xsd:string' */
        char *Exponent;
      public:
        /** Return unique type id SOAP_TYPE_ds__RSAKeyValueType */
        int soap_type() const { return SOAP_TYPE_ds__RSAKeyValueType; }
        /** Constructor with member initializations */
        ds__RSAKeyValueType()
        {
          Modulus = (char *)0;
          Exponent = (char *)0;
        }
        /** Friend allocator used by soap_new_ds__RSAKeyValueType(struct soap*, int) */
        friend SOAP_FMAC1 ds__RSAKeyValueType * SOAP_FMAC2 soap_instantiate_ds__RSAKeyValueType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:84 */
#ifndef SOAP_TYPE_xenc__EncryptionPropertyType
#define SOAP_TYPE_xenc__EncryptionPropertyType (75)
/* complex XSD type 'xenc:EncryptionPropertyType': */
struct xenc__EncryptionPropertyType {
      public:
        /** Optional attribute 'Target' of XSD type 'xsd:string' */
        char *Target;
        /** Optional attribute 'Id' of XSD type 'xsd:string' */
        char *Id;
      public:
        /** Return unique type id SOAP_TYPE_xenc__EncryptionPropertyType */
        int soap_type() const { return SOAP_TYPE_xenc__EncryptionPropertyType; }
        /** Constructor with member initializations */
        xenc__EncryptionPropertyType()
        {
          Target = (char *)0;
          Id = (char *)0;
        }
        /** Friend allocator used by soap_new_xenc__EncryptionPropertyType(struct soap*, int) */
        friend SOAP_FMAC1 xenc__EncryptionPropertyType * SOAP_FMAC2 soap_instantiate_xenc__EncryptionPropertyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:53 */
#ifndef SOAP_TYPE_xenc__EncryptedType
#define SOAP_TYPE_xenc__EncryptedType (65)
/* complex XSD type 'xenc:EncryptedType': */
struct xenc__EncryptedType {
      public:
        /** Optional element 'xenc:EncryptionMethod' of XSD type 'xenc:EncryptionMethodType' */
        struct xenc__EncryptionMethodType *EncryptionMethod;
        /** Optional element 'ds:KeyInfo' of XSD type 'ds:KeyInfo' */
        struct ds__KeyInfoType *ds__KeyInfo;
        /** Required element 'xenc:CipherData' of XSD type 'xenc:CipherDataType' */
        struct xenc__CipherDataType *CipherData;
        /** Optional element 'xenc:EncryptionProperties' of XSD type 'xenc:EncryptionPropertiesType' */
        struct xenc__EncryptionPropertiesType *EncryptionProperties;
        /** Optional attribute 'Id' of XSD type 'xsd:string' */
        char *Id;
        /** Optional attribute 'Type' of XSD type 'xsd:string' */
        char *Type;
        /** Optional attribute 'MimeType' of XSD type 'xsd:string' */
        char *MimeType;
        /** Optional attribute 'Encoding' of XSD type 'xsd:string' */
        char *Encoding;
      public:
        /** Return unique type id SOAP_TYPE_xenc__EncryptedType */
        int soap_type() const { return SOAP_TYPE_xenc__EncryptedType; }
        /** Constructor with member initializations */
        xenc__EncryptedType()
        {
          EncryptionMethod = (struct xenc__EncryptionMethodType *)0;
          ds__KeyInfo = (struct ds__KeyInfoType *)0;
          CipherData = (struct xenc__CipherDataType *)0;
          EncryptionProperties = (struct xenc__EncryptionPropertiesType *)0;
          Id = (char *)0;
          Type = (char *)0;
          MimeType = (char *)0;
          Encoding = (char *)0;
        }
        /** Friend allocator used by soap_new_xenc__EncryptedType(struct soap*, int) */
        friend SOAP_FMAC1 xenc__EncryptedType * SOAP_FMAC2 soap_instantiate_xenc__EncryptedType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:56 */
#ifndef SOAP_TYPE_xenc__EncryptionMethodType
#define SOAP_TYPE_xenc__EncryptionMethodType (66)
/* complex XSD type 'xenc:EncryptionMethodType': */
struct xenc__EncryptionMethodType {
      public:
        /** Optional element 'xenc:KeySize' of XSD type 'xsd:int' */
        int *KeySize;
        /** Optional element 'xenc:OAEPparams' of XSD type 'xsd:string' */
        char *OAEPparams;
        /** Required attribute 'Algorithm' of XSD type 'xsd:string' */
        char *Algorithm;
        /** Optional element 'ds:DigestMethod' of XSD type 'ds:DigestMethodType' */
        struct ds__DigestMethodType *ds__DigestMethod;
        char *__mixed;
      public:
        /** Return unique type id SOAP_TYPE_xenc__EncryptionMethodType */
        int soap_type() const { return SOAP_TYPE_xenc__EncryptionMethodType; }
        /** Constructor with member initializations */
        xenc__EncryptionMethodType()
        {
          KeySize = (int *)0;
          OAEPparams = (char *)0;
          Algorithm = (char *)0;
          ds__DigestMethod = (struct ds__DigestMethodType *)0;
          __mixed = (char *)0;
        }
        /** Friend allocator used by soap_new_xenc__EncryptionMethodType(struct soap*, int) */
        friend SOAP_FMAC1 xenc__EncryptionMethodType * SOAP_FMAC2 soap_instantiate_xenc__EncryptionMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:59 */
#ifndef SOAP_TYPE_xenc__CipherDataType
#define SOAP_TYPE_xenc__CipherDataType (67)
/* complex XSD type 'xenc:CipherDataType': */
struct xenc__CipherDataType {
      public:
        /** Optional element 'xenc:CipherValue' of XSD type 'xsd:string' */
        char *CipherValue;
        /** Optional element 'xenc:CipherReference' of XSD type 'xenc:CipherReferenceType' */
        struct xenc__CipherReferenceType *CipherReference;
      public:
        /** Return unique type id SOAP_TYPE_xenc__CipherDataType */
        int soap_type() const { return SOAP_TYPE_xenc__CipherDataType; }
        /** Constructor with member initializations */
        xenc__CipherDataType()
        {
          CipherValue = (char *)0;
          CipherReference = (struct xenc__CipherReferenceType *)0;
        }
        /** Friend allocator used by soap_new_xenc__CipherDataType(struct soap*, int) */
        friend SOAP_FMAC1 xenc__CipherDataType * SOAP_FMAC2 soap_instantiate_xenc__CipherDataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:62 */
#ifndef SOAP_TYPE_xenc__CipherReferenceType
#define SOAP_TYPE_xenc__CipherReferenceType (68)
/* complex XSD type 'xenc:CipherReferenceType': */
struct xenc__CipherReferenceType {
      public:
        /** Optional element 'xenc:Transforms' of XSD type 'xenc:TransformsType' */
        struct xenc__TransformsType *Transforms;
        /** Required attribute 'URI' of XSD type 'xsd:string' */
        char *URI;
      public:
        /** Return unique type id SOAP_TYPE_xenc__CipherReferenceType */
        int soap_type() const { return SOAP_TYPE_xenc__CipherReferenceType; }
        /** Constructor with member initializations */
        xenc__CipherReferenceType()
        {
          Transforms = (struct xenc__TransformsType *)0;
          URI = (char *)0;
        }
        /** Friend allocator used by soap_new_xenc__CipherReferenceType(struct soap*, int) */
        friend SOAP_FMAC1 xenc__CipherReferenceType * SOAP_FMAC2 soap_instantiate_xenc__CipherReferenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:65 */
#ifndef SOAP_TYPE_xenc__TransformsType
#define SOAP_TYPE_xenc__TransformsType (69)
/* complex XSD type 'xenc:TransformsType': */
struct xenc__TransformsType {
      public:
        /** Required element 'ds:Transform' of XSD type 'ds:Transform' */
        struct ds__TransformType ds__Transform;
      public:
        /** Return unique type id SOAP_TYPE_xenc__TransformsType */
        int soap_type() const { return SOAP_TYPE_xenc__TransformsType; }
        /** Constructor with member initializations */
        xenc__TransformsType()
        {
        }
        /** Friend allocator used by soap_new_xenc__TransformsType(struct soap*, int) */
        friend SOAP_FMAC1 xenc__TransformsType * SOAP_FMAC2 soap_instantiate_xenc__TransformsType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:74 */
#ifndef SOAP_TYPE_xenc__AgreementMethodType
#define SOAP_TYPE_xenc__AgreementMethodType (72)
/* complex XSD type 'xenc:AgreementMethodType': */
struct xenc__AgreementMethodType {
      public:
        /** Optional element 'xenc:KA-Nonce' of XSD type 'xsd:string' */
        char *KA_Nonce;
        /** Optional element 'xenc:OriginatorKeyInfo' of XSD type 'ds:KeyInfoType' */
        struct ds__KeyInfoType *OriginatorKeyInfo;
        /** Optional element 'xenc:RecipientKeyInfo' of XSD type 'ds:KeyInfoType' */
        struct ds__KeyInfoType *RecipientKeyInfo;
        /** Required attribute 'Algorithm' of XSD type 'xsd:string' */
        char *Algorithm;
        char *__mixed;
      public:
        /** Return unique type id SOAP_TYPE_xenc__AgreementMethodType */
        int soap_type() const { return SOAP_TYPE_xenc__AgreementMethodType; }
        /** Constructor with member initializations */
        xenc__AgreementMethodType()
        {
          KA_Nonce = (char *)0;
          OriginatorKeyInfo = (struct ds__KeyInfoType *)0;
          RecipientKeyInfo = (struct ds__KeyInfoType *)0;
          Algorithm = (char *)0;
          __mixed = (char *)0;
        }
        /** Friend allocator used by soap_new_xenc__AgreementMethodType(struct soap*, int) */
        friend SOAP_FMAC1 xenc__AgreementMethodType * SOAP_FMAC2 soap_instantiate_xenc__AgreementMethodType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:77 */
#ifndef SOAP_TYPE_xenc__ReferenceType
#define SOAP_TYPE_xenc__ReferenceType (73)
/* complex XSD type 'xenc:ReferenceType': */
struct xenc__ReferenceType {
      public:
        /** Required attribute 'URI' of XSD type 'xsd:string' */
        char *URI;
      public:
        /** Return unique type id SOAP_TYPE_xenc__ReferenceType */
        int soap_type() const { return SOAP_TYPE_xenc__ReferenceType; }
        /** Constructor with member initializations */
        xenc__ReferenceType()
        {
          URI = (char *)0;
        }
        /** Friend allocator used by soap_new_xenc__ReferenceType(struct soap*, int) */
        friend SOAP_FMAC1 xenc__ReferenceType * SOAP_FMAC2 soap_instantiate_xenc__ReferenceType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:80 */
#ifndef SOAP_TYPE_xenc__EncryptionPropertiesType
#define SOAP_TYPE_xenc__EncryptionPropertiesType (74)
/* complex XSD type 'xenc:EncryptionPropertiesType': */
struct xenc__EncryptionPropertiesType {
      public:
        /** Sequence of at least 1 elements 'xenc:EncryptionProperty' of XSD type 'xenc:EncryptionPropertyType' stored in dynamic array EncryptionProperty of length __sizeEncryptionProperty */
        int __sizeEncryptionProperty;
        struct xenc__EncryptionPropertyType *EncryptionProperty;
        /** Optional attribute 'Id' of XSD type 'xsd:string' */
        char *Id;
      public:
        /** Return unique type id SOAP_TYPE_xenc__EncryptionPropertiesType */
        int soap_type() const { return SOAP_TYPE_xenc__EncryptionPropertiesType; }
        /** Constructor with member initializations */
        xenc__EncryptionPropertiesType()
        {
          __sizeEncryptionProperty = 0;
          EncryptionProperty = NULL;
          Id = (char *)0;
        }
        /** Friend allocator used by soap_new_xenc__EncryptionPropertiesType(struct soap*, int) */
        friend SOAP_FMAC1 xenc__EncryptionPropertiesType * SOAP_FMAC2 soap_instantiate_xenc__EncryptionPropertiesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:238 */
#ifndef SOAP_TYPE___xenc__union_ReferenceList
#define SOAP_TYPE___xenc__union_ReferenceList (84)
/* Wrapper: */
struct __xenc__union_ReferenceList {
      public:
        /** Optional element 'xenc:DataReference' of XSD type 'xenc:ReferenceType' */
        struct xenc__ReferenceType *DataReference;
        /** Optional element 'xenc:KeyReference' of XSD type 'xenc:ReferenceType' */
        struct xenc__ReferenceType *KeyReference;
      public:
        /** Return unique type id SOAP_TYPE___xenc__union_ReferenceList */
        int soap_type() const { return SOAP_TYPE___xenc__union_ReferenceList; }
        /** Constructor with member initializations */
        __xenc__union_ReferenceList()
        {
          DataReference = (struct xenc__ReferenceType *)0;
          KeyReference = (struct xenc__ReferenceType *)0;
        }
        /** Friend allocator used by soap_new___xenc__union_ReferenceList(struct soap*, int) */
        friend SOAP_FMAC1 __xenc__union_ReferenceList * SOAP_FMAC2 soap_instantiate___xenc__union_ReferenceList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:89 */
#ifndef SOAP_TYPE__xenc__ReferenceList
#define SOAP_TYPE__xenc__ReferenceList (76)
/* complex XSD type 'xenc:ReferenceList': */
struct _xenc__ReferenceList {
      public:
        /** Sequence of at least 1 elements '-union-ReferenceList' of XSD type '-xenc:union-ReferenceList' stored in dynamic array __union_ReferenceList of length __size_ReferenceList */
        int __size_ReferenceList;
        struct __xenc__union_ReferenceList *__union_ReferenceList;
      public:
        /** Return unique type id SOAP_TYPE__xenc__ReferenceList */
        int soap_type() const { return SOAP_TYPE__xenc__ReferenceList; }
        /** Constructor with member initializations */
        _xenc__ReferenceList()
        {
          __size_ReferenceList = 0;
          __union_ReferenceList = NULL;
        }
        /** Friend allocator used by soap_new__xenc__ReferenceList(struct soap*, int) */
        friend SOAP_FMAC1 _xenc__ReferenceList * SOAP_FMAC2 soap_instantiate__xenc__ReferenceList(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:68 */
#ifndef SOAP_TYPE_xenc__EncryptedDataType
#define SOAP_TYPE_xenc__EncryptedDataType (70)
/* complex XSD type 'xenc:EncryptedDataType': */
struct xenc__EncryptedDataType {
      public:
        /** Optional element 'xenc:EncryptionMethod' of XSD type 'xenc:EncryptionMethodType' */
        struct xenc__EncryptionMethodType *EncryptionMethod;
        /** Optional element 'ds:KeyInfo' of XSD type 'ds:KeyInfo' */
        struct ds__KeyInfoType *ds__KeyInfo;
        /** Required element 'xenc:CipherData' of XSD type 'xenc:CipherDataType' */
        struct xenc__CipherDataType *CipherData;
        /** Optional element 'xenc:EncryptionProperties' of XSD type 'xenc:EncryptionPropertiesType' */
        struct xenc__EncryptionPropertiesType *EncryptionProperties;
        /** Optional attribute 'Id' of XSD type 'xsd:string' */
        char *Id;
        /** Optional attribute 'Type' of XSD type 'xsd:string' */
        char *Type;
        /** Optional attribute 'MimeType' of XSD type 'xsd:string' */
        char *MimeType;
        /** Optional attribute 'Encoding' of XSD type 'xsd:string' */
        char *Encoding;
      public:
        /** Return unique type id SOAP_TYPE_xenc__EncryptedDataType */
        int soap_type() const { return SOAP_TYPE_xenc__EncryptedDataType; }
        /** Constructor with member initializations */
        xenc__EncryptedDataType()
        {
          EncryptionMethod = (struct xenc__EncryptionMethodType *)0;
          ds__KeyInfo = (struct ds__KeyInfoType *)0;
          CipherData = (struct xenc__CipherDataType *)0;
          EncryptionProperties = (struct xenc__EncryptionPropertiesType *)0;
          Id = (char *)0;
          Type = (char *)0;
          MimeType = (char *)0;
          Encoding = (char *)0;
        }
        /** Friend allocator used by soap_new_xenc__EncryptedDataType(struct soap*, int) */
        friend SOAP_FMAC1 xenc__EncryptedDataType * SOAP_FMAC2 soap_instantiate_xenc__EncryptedDataType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* xenc.h:71 */
#ifndef SOAP_TYPE_xenc__EncryptedKeyType
#define SOAP_TYPE_xenc__EncryptedKeyType (71)
/* complex XSD type 'xenc:EncryptedKeyType': */
struct xenc__EncryptedKeyType {
      public:
        /** Optional element 'xenc:EncryptionMethod' of XSD type 'xenc:EncryptionMethodType' */
        struct xenc__EncryptionMethodType *EncryptionMethod;
        /** Optional element 'ds:KeyInfo' of XSD type 'ds:KeyInfo' */
        struct ds__KeyInfoType *ds__KeyInfo;
        /** Required element 'xenc:CipherData' of XSD type 'xenc:CipherDataType' */
        struct xenc__CipherDataType *CipherData;
        /** Optional element 'xenc:EncryptionProperties' of XSD type 'xenc:EncryptionPropertiesType' */
        struct xenc__EncryptionPropertiesType *EncryptionProperties;
        /** Optional attribute 'Id' of XSD type 'xsd:string' */
        char *Id;
        /** Optional attribute 'Type' of XSD type 'xsd:string' */
        char *Type;
        /** Optional attribute 'MimeType' of XSD type 'xsd:string' */
        char *MimeType;
        /** Optional attribute 'Encoding' of XSD type 'xsd:string' */
        char *Encoding;
        /** Optional element 'xenc:ReferenceList' of XSD type 'xenc:ReferenceList' */
        struct _xenc__ReferenceList *ReferenceList;
        /** Optional element 'xenc:CarriedKeyName' of XSD type 'xsd:string' */
        char *CarriedKeyName;
        /** Optional attribute 'Recipient' of XSD type 'xsd:string' */
        char *Recipient;
      public:
        /** Return unique type id SOAP_TYPE_xenc__EncryptedKeyType */
        int soap_type() const { return SOAP_TYPE_xenc__EncryptedKeyType; }
        /** Constructor with member initializations */
        xenc__EncryptedKeyType()
        {
          EncryptionMethod = (struct xenc__EncryptionMethodType *)0;
          ds__KeyInfo = (struct ds__KeyInfoType *)0;
          CipherData = (struct xenc__CipherDataType *)0;
          EncryptionProperties = (struct xenc__EncryptionPropertiesType *)0;
          Id = (char *)0;
          Type = (char *)0;
          MimeType = (char *)0;
          Encoding = (char *)0;
          ReferenceList = (struct _xenc__ReferenceList *)0;
          CarriedKeyName = (char *)0;
          Recipient = (char *)0;
        }
        /** Friend allocator used by soap_new_xenc__EncryptedKeyType(struct soap*, int) */
        friend SOAP_FMAC1 xenc__EncryptedKeyType * SOAP_FMAC2 soap_instantiate_xenc__EncryptedKeyType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsc.h:87 */
#ifndef SOAP_TYPE_wsc__SecurityContextTokenType
#define SOAP_TYPE_wsc__SecurityContextTokenType (90)
/* complex XSD type 'wsc:SecurityContextTokenType': */
struct wsc__SecurityContextTokenType {
      public:
        /** Optional attribute 'wsu:Id' of XSD type 'xsd:string' */
        char *wsu__Id;
        /** Optional element 'wsc:Identifier' of XSD type 'xsd:string' */
        char *Identifier;
        /** Optional element 'wsc:Instance' of XSD type 'xsd:string' */
        char *Instance;
      public:
        /** Return unique type id SOAP_TYPE_wsc__SecurityContextTokenType */
        int soap_type() const { return SOAP_TYPE_wsc__SecurityContextTokenType; }
        /** Constructor with member initializations */
        wsc__SecurityContextTokenType()
        {
          wsu__Id = (char *)0;
          Identifier = (char *)0;
          Instance = (char *)0;
        }
        /** Friend allocator used by soap_new_wsc__SecurityContextTokenType(struct soap*, int) */
        friend SOAP_FMAC1 wsc__SecurityContextTokenType * SOAP_FMAC2 soap_instantiate_wsc__SecurityContextTokenType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsc.h:125 */
#ifndef SOAP_TYPE__wsc__union_DerivedKeyTokenType
#define SOAP_TYPE__wsc__union_DerivedKeyTokenType (96)
/* union serializable only when used as a member of a struct or class with a union variant selector */
union _wsc__union_DerivedKeyTokenType
{
        #define SOAP_UNION__wsc__union_DerivedKeyTokenType_Generation	(1)	/**< union variant selector value for member Generation */
        ULONG64 Generation;
        #define SOAP_UNION__wsc__union_DerivedKeyTokenType_Offset	(2)	/**< union variant selector value for member Offset */
        ULONG64 Offset;
};
#endif

/* wsc.h:116 */
#ifndef SOAP_TYPE___wsc__DerivedKeyTokenType_sequence
#define SOAP_TYPE___wsc__DerivedKeyTokenType_sequence (94)
/* Wrapper: */
struct __wsc__DerivedKeyTokenType_sequence {
      public:
        /** Union with union _wsc__union_DerivedKeyTokenType variant selector __union_DerivedKeyTokenType set to one of: SOAP_UNION__wsc__union_DerivedKeyTokenType_Generation SOAP_UNION__wsc__union_DerivedKeyTokenType_Offset */
        int __union_DerivedKeyTokenType;
        union _wsc__union_DerivedKeyTokenType union_DerivedKeyTokenType;
        /** Optional element 'wsc:Length' of XSD type 'xsd:unsignedLong' */
        ULONG64 *Length;
      public:
        /** Return unique type id SOAP_TYPE___wsc__DerivedKeyTokenType_sequence */
        int soap_type() const { return SOAP_TYPE___wsc__DerivedKeyTokenType_sequence; }
        /** Constructor with member initializations */
        __wsc__DerivedKeyTokenType_sequence()
        {
          __union_DerivedKeyTokenType = -1;
          Length = (ULONG64 *)0;
        }
        /** Friend allocator used by soap_new___wsc__DerivedKeyTokenType_sequence(struct soap*, int) */
        friend SOAP_FMAC1 __wsc__DerivedKeyTokenType_sequence * SOAP_FMAC2 soap_instantiate___wsc__DerivedKeyTokenType_sequence(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsc.h:109 */
#ifndef SOAP_TYPE_wsc__DerivedKeyTokenType
#define SOAP_TYPE_wsc__DerivedKeyTokenType (91)
/* complex XSD type 'wsc:DerivedKeyTokenType': */
struct wsc__DerivedKeyTokenType {
      public:
        /** Optional element 'wsse:SecurityTokenReference' of XSD type 'wsse:SecurityTokenReference' */
        struct _wsse__SecurityTokenReference *wsse__SecurityTokenReference;
        /** Optional element 'wsc:Properties' of XSD type 'wsc:PropertiesType' */
        struct wsc__PropertiesType *Properties;
        struct __wsc__DerivedKeyTokenType_sequence *__DerivedKeyTokenType_sequence;
        /** Optional element 'wsc:Label' of XSD type 'xsd:string' */
        char *Label;
        /** Optional element 'wsc:Nonce' of XSD type 'xsd:string' */
        char *Nonce;
        /** Optional attribute 'wsu:Id' of XSD type 'xsd:string' */
        char *wsu__Id;
        /** Optional attribute 'Algorithm' of XSD type 'xsd:string' */
        char *Algorithm;
      public:
        /** Return unique type id SOAP_TYPE_wsc__DerivedKeyTokenType */
        int soap_type() const { return SOAP_TYPE_wsc__DerivedKeyTokenType; }
        /** Constructor with member initializations */
        wsc__DerivedKeyTokenType()
        {
          wsse__SecurityTokenReference = (struct _wsse__SecurityTokenReference *)0;
          Properties = (struct wsc__PropertiesType *)0;
          __DerivedKeyTokenType_sequence = (struct __wsc__DerivedKeyTokenType_sequence *)0;
          Label = (char *)0;
          Nonce = (char *)0;
          wsu__Id = (char *)0;
          Algorithm = (char *)0;
        }
        /** Friend allocator used by soap_new_wsc__DerivedKeyTokenType(struct soap*, int) */
        friend SOAP_FMAC1 wsc__DerivedKeyTokenType * SOAP_FMAC2 soap_instantiate_wsc__DerivedKeyTokenType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsc.h:113 */
#ifndef SOAP_TYPE_wsc__PropertiesType
#define SOAP_TYPE_wsc__PropertiesType (92)
/* complex XSD type 'wsc:PropertiesType': */
struct wsc__PropertiesType {
      public:
        /** Return unique type id SOAP_TYPE_wsc__PropertiesType */
        int soap_type() const { return SOAP_TYPE_wsc__PropertiesType; }
        /** Constructor with member initializations */
        wsc__PropertiesType()
        {
        }
        /** Friend allocator used by soap_new_wsc__PropertiesType(struct soap*, int) */
        friend SOAP_FMAC1 wsc__PropertiesType * SOAP_FMAC2 soap_instantiate_wsc__PropertiesType(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:191 */
#ifndef SOAP_TYPE__wsse__Security
#define SOAP_TYPE__wsse__Security (99)
/* complex XSD type 'wsse:Security': */
struct _wsse__Security {
      public:
        /** Optional element 'wsu:Timestamp' of XSD type 'wsu:Timestamp' */
        struct _wsu__Timestamp *wsu__Timestamp;
        /** Optional element 'wsse:UsernameToken' of XSD type 'wsse:UsernameToken' */
        struct _wsse__UsernameToken *UsernameToken;
        /** Optional element 'wsse:BinarySecurityToken' of XSD type 'wsse:BinarySecurityToken' */
        struct _wsse__BinarySecurityToken *BinarySecurityToken;
        /** Optional element 'xenc:EncryptedKey' of XSD type 'xenc:EncryptedKeyType' */
        struct xenc__EncryptedKeyType *xenc__EncryptedKey;
        /** Optional element 'xenc:ReferenceList' of XSD type 'xenc:ReferenceList' */
        struct _xenc__ReferenceList *xenc__ReferenceList;
        /** Optional element 'wsc:SecurityContextToken' of XSD type 'wsc:SecurityContextTokenType' */
        struct wsc__SecurityContextTokenType *wsc__SecurityContextToken;
        /** Optional element 'ds:Signature' of XSD type 'ds:SignatureType' */
        struct ds__SignatureType *ds__Signature;
        /** Optional attribute 'SOAP-ENV:actor' of XSD type 'xsd:string' */
        char *SOAP_ENV__actor;
        /** Optional attribute 'SOAP-ENV:role' of XSD type 'xsd:string' */
        char *SOAP_ENV__role;
      public:
        /** Return unique type id SOAP_TYPE__wsse__Security */
        int soap_type() const { return SOAP_TYPE__wsse__Security; }
        /** Constructor with member initializations */
        _wsse__Security()
        {
          wsu__Timestamp = (struct _wsu__Timestamp *)0;
          UsernameToken = (struct _wsse__UsernameToken *)0;
          BinarySecurityToken = (struct _wsse__BinarySecurityToken *)0;
          xenc__EncryptedKey = (struct xenc__EncryptedKeyType *)0;
          xenc__ReferenceList = (struct _xenc__ReferenceList *)0;
          wsc__SecurityContextToken = (struct wsc__SecurityContextTokenType *)0;
          ds__Signature = (struct ds__SignatureType *)0;
          SOAP_ENV__actor = (char *)0;
          SOAP_ENV__role = (char *)0;
        }
        /** Friend allocator used by soap_new__wsse__Security(struct soap*, int) */
        friend SOAP_FMAC1 _wsse__Security * SOAP_FMAC2 soap_instantiate__wsse__Security(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:129 */
#ifndef SOAP_TYPE__wsse__Password
#define SOAP_TYPE__wsse__Password (16)
/* simple XSD type 'wsse:Password': */
struct _wsse__Password {
      public:
        /** Simple content of XSD type 'xsd:string' wrapped by this struct */
        char *__item;
        /** Optional attribute 'Type' of XSD type 'xsd:string' */
        char *Type;
      public:
        /** Return unique type id SOAP_TYPE__wsse__Password */
        int soap_type() const { return SOAP_TYPE__wsse__Password; }
        /** Constructor with member initializations */
        _wsse__Password()
        {
          __item = (char *)0;
          Type = (char *)0;
        }
        /** Friend allocator used by soap_new__wsse__Password(struct soap*, int) */
        friend SOAP_FMAC1 _wsse__Password * SOAP_FMAC2 soap_instantiate__wsse__Password(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* wsse.h:221 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (106)
/* SOAP_ENV__Header: */
struct SOAP_ENV__Header {
      public:
        /** MustUnderstand */
        struct _wsse__Security *wsse__Security;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Header */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Header; }
        /** Constructor with member initializations */
        SOAP_ENV__Header()
        {
          wsse__Security = (struct _wsse__Security *)0;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Header(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Header * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Header(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* CyberSourceTransaction_xml_1.129.h:153 */
#ifndef SOAP_TYPE_ns2__Item
#define SOAP_TYPE_ns2__Item (110)
/* complex XSD type 'ns2:Item': */
class SOAP_CMAC ns2__Item {
      public:
        /// Optional element 'ns2:unitPrice' of XSD type 'ns2:amount'
        std::string *unitPrice;
        /// Optional element 'ns2:quantity' of XSD type 'ns2:amount'
        std::string *quantity;
        /// Optional element 'ns2:productCode' of XSD type 'xsd:string'
        std::string *productCode;
        /// Optional element 'ns2:productName' of XSD type 'xsd:string'
        std::string *productName;
        /// Optional element 'ns2:productSKU' of XSD type 'xsd:string'
        std::string *productSKU;
        /// Optional element 'ns2:productRisk' of XSD type 'xsd:string'
        std::string *productRisk;
        /// Optional element 'ns2:taxAmount' of XSD type 'ns2:amount'
        std::string *taxAmount;
        /// Optional element 'ns2:cityOverrideAmount' of XSD type 'ns2:amount'
        std::string *cityOverrideAmount;
        /// Optional element 'ns2:cityOverrideRate' of XSD type 'ns2:amount'
        std::string *cityOverrideRate;
        /// Optional element 'ns2:countyOverrideAmount' of XSD type 'ns2:amount'
        std::string *countyOverrideAmount;
        /// Optional element 'ns2:countyOverrideRate' of XSD type 'ns2:amount'
        std::string *countyOverrideRate;
        /// Optional element 'ns2:districtOverrideAmount' of XSD type 'ns2:amount'
        std::string *districtOverrideAmount;
        /// Optional element 'ns2:districtOverrideRate' of XSD type 'ns2:amount'
        std::string *districtOverrideRate;
        /// Optional element 'ns2:stateOverrideAmount' of XSD type 'ns2:amount'
        std::string *stateOverrideAmount;
        /// Optional element 'ns2:stateOverrideRate' of XSD type 'ns2:amount'
        std::string *stateOverrideRate;
        /// Optional element 'ns2:countryOverrideAmount' of XSD type 'ns2:amount'
        std::string *countryOverrideAmount;
        /// Optional element 'ns2:countryOverrideRate' of XSD type 'ns2:amount'
        std::string *countryOverrideRate;
        /// Optional element 'ns2:orderAcceptanceCity' of XSD type 'xsd:string'
        std::string *orderAcceptanceCity;
        /// Optional element 'ns2:orderAcceptanceCounty' of XSD type 'xsd:string'
        std::string *orderAcceptanceCounty;
        /// Optional element 'ns2:orderAcceptanceCountry' of XSD type 'xsd:string'
        std::string *orderAcceptanceCountry;
        /// Optional element 'ns2:orderAcceptanceState' of XSD type 'xsd:string'
        std::string *orderAcceptanceState;
        /// Optional element 'ns2:orderAcceptancePostalCode' of XSD type 'xsd:string'
        std::string *orderAcceptancePostalCode;
        /// Optional element 'ns2:orderOriginCity' of XSD type 'xsd:string'
        std::string *orderOriginCity;
        /// Optional element 'ns2:orderOriginCounty' of XSD type 'xsd:string'
        std::string *orderOriginCounty;
        /// Optional element 'ns2:orderOriginCountry' of XSD type 'xsd:string'
        std::string *orderOriginCountry;
        /// Optional element 'ns2:orderOriginState' of XSD type 'xsd:string'
        std::string *orderOriginState;
        /// Optional element 'ns2:orderOriginPostalCode' of XSD type 'xsd:string'
        std::string *orderOriginPostalCode;
        /// Optional element 'ns2:shipFromCity' of XSD type 'xsd:string'
        std::string *shipFromCity;
        /// Optional element 'ns2:shipFromCounty' of XSD type 'xsd:string'
        std::string *shipFromCounty;
        /// Optional element 'ns2:shipFromCountry' of XSD type 'xsd:string'
        std::string *shipFromCountry;
        /// Optional element 'ns2:shipFromState' of XSD type 'xsd:string'
        std::string *shipFromState;
        /// Optional element 'ns2:shipFromPostalCode' of XSD type 'xsd:string'
        std::string *shipFromPostalCode;
        /// Optional element 'ns2:export' of XSD type 'xsd:string'
        std::string *export_;
        /// Optional element 'ns2:noExport' of XSD type 'xsd:string'
        std::string *noExport;
        /// Optional element 'ns2:nationalTax' of XSD type 'ns2:amount'
        std::string *nationalTax;
        /// Optional element 'ns2:vatRate' of XSD type 'ns2:amount'
        std::string *vatRate;
        /// Optional element 'ns2:sellerRegistration' of XSD type 'xsd:string'
        std::string *sellerRegistration;
        /// Optional element 'ns2:sellerRegistration0' of XSD type 'xsd:string'
        std::string *sellerRegistration0;
        /// Optional element 'ns2:sellerRegistration1' of XSD type 'xsd:string'
        std::string *sellerRegistration1;
        /// Optional element 'ns2:sellerRegistration2' of XSD type 'xsd:string'
        std::string *sellerRegistration2;
        /// Optional element 'ns2:sellerRegistration3' of XSD type 'xsd:string'
        std::string *sellerRegistration3;
        /// Optional element 'ns2:sellerRegistration4' of XSD type 'xsd:string'
        std::string *sellerRegistration4;
        /// Optional element 'ns2:sellerRegistration5' of XSD type 'xsd:string'
        std::string *sellerRegistration5;
        /// Optional element 'ns2:sellerRegistration6' of XSD type 'xsd:string'
        std::string *sellerRegistration6;
        /// Optional element 'ns2:sellerRegistration7' of XSD type 'xsd:string'
        std::string *sellerRegistration7;
        /// Optional element 'ns2:sellerRegistration8' of XSD type 'xsd:string'
        std::string *sellerRegistration8;
        /// Optional element 'ns2:sellerRegistration9' of XSD type 'xsd:string'
        std::string *sellerRegistration9;
        /// Optional element 'ns2:buyerRegistration' of XSD type 'xsd:string'
        std::string *buyerRegistration;
        /// Optional element 'ns2:middlemanRegistration' of XSD type 'xsd:string'
        std::string *middlemanRegistration;
        /// Optional element 'ns2:pointOfTitleTransfer' of XSD type 'xsd:string'
        std::string *pointOfTitleTransfer;
        /// Optional element 'ns2:giftCategory' of XSD type 'ns2:boolean'
        std::string *giftCategory;
        /// Optional element 'ns2:timeCategory' of XSD type 'xsd:string'
        std::string *timeCategory;
        /// Optional element 'ns2:hostHedge' of XSD type 'xsd:string'
        std::string *hostHedge;
        /// Optional element 'ns2:timeHedge' of XSD type 'xsd:string'
        std::string *timeHedge;
        /// Optional element 'ns2:velocityHedge' of XSD type 'xsd:string'
        std::string *velocityHedge;
        /// Optional element 'ns2:nonsensicalHedge' of XSD type 'xsd:string'
        std::string *nonsensicalHedge;
        /// Optional element 'ns2:phoneHedge' of XSD type 'xsd:string'
        std::string *phoneHedge;
        /// Optional element 'ns2:obscenitiesHedge' of XSD type 'xsd:string'
        std::string *obscenitiesHedge;
        /// Optional element 'ns2:unitOfMeasure' of XSD type 'xsd:string'
        std::string *unitOfMeasure;
        /// Optional element 'ns2:taxRate' of XSD type 'ns2:amount'
        std::string *taxRate;
        /// Optional element 'ns2:totalAmount' of XSD type 'ns2:amount'
        std::string *totalAmount;
        /// Optional element 'ns2:discountAmount' of XSD type 'ns2:amount'
        std::string *discountAmount;
        /// Optional element 'ns2:discountRate' of XSD type 'ns2:amount'
        std::string *discountRate;
        /// Optional element 'ns2:commodityCode' of XSD type 'xsd:string'
        std::string *commodityCode;
        /// Optional element 'ns2:grossNetIndicator' of XSD type 'xsd:string'
        std::string *grossNetIndicator;
        /// Optional element 'ns2:taxTypeApplied' of XSD type 'xsd:string'
        std::string *taxTypeApplied;
        /// Optional element 'ns2:discountIndicator' of XSD type 'xsd:string'
        std::string *discountIndicator;
        /// Optional element 'ns2:alternateTaxID' of XSD type 'xsd:string'
        std::string *alternateTaxID;
        /// Optional element 'ns2:alternateTaxAmount' of XSD type 'ns2:amount'
        std::string *alternateTaxAmount;
        /// Optional element 'ns2:alternateTaxTypeApplied' of XSD type 'xsd:string'
        std::string *alternateTaxTypeApplied;
        /// Optional element 'ns2:alternateTaxRate' of XSD type 'ns2:amount'
        std::string *alternateTaxRate;
        /// Optional element 'ns2:alternateTaxType' of XSD type 'xsd:string'
        std::string *alternateTaxType;
        /// Optional element 'ns2:localTax' of XSD type 'ns2:amount'
        std::string *localTax;
        /// Optional element 'ns2:zeroCostToCustomerIndicator' of XSD type 'xsd:string'
        std::string *zeroCostToCustomerIndicator;
        /// Optional element 'ns2:passengerFirstName' of XSD type 'xsd:string'
        std::string *passengerFirstName;
        /// Optional element 'ns2:passengerLastName' of XSD type 'xsd:string'
        std::string *passengerLastName;
        /// Optional element 'ns2:passengerID' of XSD type 'xsd:string'
        std::string *passengerID;
        /// Optional element 'ns2:passengerStatus' of XSD type 'xsd:string'
        std::string *passengerStatus;
        /// Optional element 'ns2:passengerType' of XSD type 'xsd:string'
        std::string *passengerType;
        /// Optional element 'ns2:passengerEmail' of XSD type 'xsd:string'
        std::string *passengerEmail;
        /// Optional element 'ns2:passengerPhone' of XSD type 'xsd:string'
        std::string *passengerPhone;
        /// Optional element 'ns2:invoiceNumber' of XSD type 'xsd:string'
        std::string *invoiceNumber;
        /// Optional element 'ns2:productDescription' of XSD type 'xsd:string'
        std::string *productDescription;
        /// Optional element 'ns2:taxStatusIndicator' of XSD type 'xsd:string'
        std::string *taxStatusIndicator;
        /// Optional element 'ns2:discountManagementIndicator' of XSD type 'xsd:string'
        std::string *discountManagementIndicator;
        /// Optional element 'ns2:typeOfSupply' of XSD type 'xsd:string'
        std::string *typeOfSupply;
        /// Optional element 'ns2:sign' of XSD type 'xsd:string'
        std::string *sign;
        /// optional attribute 'id' of XSD type 'xsd:integer'
        std::string *id;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Item
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__Item; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Item, default initialized and not managed by a soap context
        virtual ns2__Item *soap_alloc(void) const { return SOAP_NEW(ns2__Item); }
      public:
        /// Constructor with initializations
        ns2__Item()
        {
          unitPrice = (std::string *)0;
          quantity = (std::string *)0;
          productCode = (std::string *)0;
          productName = (std::string *)0;
          productSKU = (std::string *)0;
          productRisk = (std::string *)0;
          taxAmount = (std::string *)0;
          cityOverrideAmount = (std::string *)0;
          cityOverrideRate = (std::string *)0;
          countyOverrideAmount = (std::string *)0;
          countyOverrideRate = (std::string *)0;
          districtOverrideAmount = (std::string *)0;
          districtOverrideRate = (std::string *)0;
          stateOverrideAmount = (std::string *)0;
          stateOverrideRate = (std::string *)0;
          countryOverrideAmount = (std::string *)0;
          countryOverrideRate = (std::string *)0;
          orderAcceptanceCity = (std::string *)0;
          orderAcceptanceCounty = (std::string *)0;
          orderAcceptanceCountry = (std::string *)0;
          orderAcceptanceState = (std::string *)0;
          orderAcceptancePostalCode = (std::string *)0;
          orderOriginCity = (std::string *)0;
          orderOriginCounty = (std::string *)0;
          orderOriginCountry = (std::string *)0;
          orderOriginState = (std::string *)0;
          orderOriginPostalCode = (std::string *)0;
          shipFromCity = (std::string *)0;
          shipFromCounty = (std::string *)0;
          shipFromCountry = (std::string *)0;
          shipFromState = (std::string *)0;
          shipFromPostalCode = (std::string *)0;
          export_ = (std::string *)0;
          noExport = (std::string *)0;
          nationalTax = (std::string *)0;
          vatRate = (std::string *)0;
          sellerRegistration = (std::string *)0;
          sellerRegistration0 = (std::string *)0;
          sellerRegistration1 = (std::string *)0;
          sellerRegistration2 = (std::string *)0;
          sellerRegistration3 = (std::string *)0;
          sellerRegistration4 = (std::string *)0;
          sellerRegistration5 = (std::string *)0;
          sellerRegistration6 = (std::string *)0;
          sellerRegistration7 = (std::string *)0;
          sellerRegistration8 = (std::string *)0;
          sellerRegistration9 = (std::string *)0;
          buyerRegistration = (std::string *)0;
          middlemanRegistration = (std::string *)0;
          pointOfTitleTransfer = (std::string *)0;
          giftCategory = (std::string *)0;
          timeCategory = (std::string *)0;
          hostHedge = (std::string *)0;
          timeHedge = (std::string *)0;
          velocityHedge = (std::string *)0;
          nonsensicalHedge = (std::string *)0;
          phoneHedge = (std::string *)0;
          obscenitiesHedge = (std::string *)0;
          unitOfMeasure = (std::string *)0;
          taxRate = (std::string *)0;
          totalAmount = (std::string *)0;
          discountAmount = (std::string *)0;
          discountRate = (std::string *)0;
          commodityCode = (std::string *)0;
          grossNetIndicator = (std::string *)0;
          taxTypeApplied = (std::string *)0;
          discountIndicator = (std::string *)0;
          alternateTaxID = (std::string *)0;
          alternateTaxAmount = (std::string *)0;
          alternateTaxTypeApplied = (std::string *)0;
          alternateTaxRate = (std::string *)0;
          alternateTaxType = (std::string *)0;
          localTax = (std::string *)0;
          zeroCostToCustomerIndicator = (std::string *)0;
          passengerFirstName = (std::string *)0;
          passengerLastName = (std::string *)0;
          passengerID = (std::string *)0;
          passengerStatus = (std::string *)0;
          passengerType = (std::string *)0;
          passengerEmail = (std::string *)0;
          passengerPhone = (std::string *)0;
          invoiceNumber = (std::string *)0;
          productDescription = (std::string *)0;
          taxStatusIndicator = (std::string *)0;
          discountManagementIndicator = (std::string *)0;
          typeOfSupply = (std::string *)0;
          sign = (std::string *)0;
          id = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__Item() { }
        /// Friend allocator used by soap_new_ns2__Item(struct soap*, int)
        friend SOAP_FMAC1 ns2__Item * SOAP_FMAC2 soap_instantiate_ns2__Item(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:156 */
#ifndef SOAP_TYPE_ns2__CCAuthService
#define SOAP_TYPE_ns2__CCAuthService (111)
/* complex XSD type 'ns2:CCAuthService': */
class SOAP_CMAC ns2__CCAuthService {
      public:
        /// Optional element 'ns2:cavv' of XSD type 'xsd:string'
        std::string *cavv;
        /// Optional element 'ns2:cavvAlgorithm' of XSD type 'xsd:string'
        std::string *cavvAlgorithm;
        /// Optional element 'ns2:commerceIndicator' of XSD type 'xsd:string'
        std::string *commerceIndicator;
        /// Optional element 'ns2:eciRaw' of XSD type 'xsd:string'
        std::string *eciRaw;
        /// Optional element 'ns2:xid' of XSD type 'xsd:string'
        std::string *xid;
        /// Optional element 'ns2:reconciliationID' of XSD type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:avsLevel' of XSD type 'xsd:string'
        std::string *avsLevel;
        /// Optional element 'ns2:fxQuoteID' of XSD type 'xsd:string'
        std::string *fxQuoteID;
        /// Optional element 'ns2:returnAuthRecord' of XSD type 'ns2:boolean'
        std::string *returnAuthRecord;
        /// Optional element 'ns2:authType' of XSD type 'xsd:string'
        std::string *authType;
        /// Optional element 'ns2:verbalAuthCode' of XSD type 'xsd:string'
        std::string *verbalAuthCode;
        /// Optional element 'ns2:billPayment' of XSD type 'ns2:boolean'
        std::string *billPayment;
        /// Optional element 'ns2:authenticationXID' of XSD type 'xsd:string'
        std::string *authenticationXID;
        /// Optional element 'ns2:authorizationXID' of XSD type 'xsd:string'
        std::string *authorizationXID;
        /// Optional element 'ns2:industryDatatype' of XSD type 'xsd:string'
        std::string *industryDatatype;
        /// Optional element 'ns2:traceNumber' of XSD type 'xsd:string'
        std::string *traceNumber;
        /// Optional element 'ns2:checksumKey' of XSD type 'xsd:string'
        std::string *checksumKey;
        /// Optional element 'ns2:aggregatorID' of XSD type 'xsd:string'
        std::string *aggregatorID;
        /// Optional element 'ns2:aggregatorName' of XSD type 'xsd:string'
        std::string *aggregatorName;
        /// Optional element 'ns2:splitTenderIndicator' of XSD type 'xsd:string'
        std::string *splitTenderIndicator;
        /// Optional element 'ns2:veresEnrolled' of XSD type 'xsd:string'
        std::string *veresEnrolled;
        /// Optional element 'ns2:paresStatus' of XSD type 'xsd:string'
        std::string *paresStatus;
        /// Optional element 'ns2:partialAuthIndicator' of XSD type 'ns2:boolean'
        std::string *partialAuthIndicator;
        /// Optional element 'ns2:captureDate' of XSD type 'xsd:string'
        std::string *captureDate;
        /// Optional element 'ns2:firstRecurringPayment' of XSD type 'xsd:string'
        std::string *firstRecurringPayment;
        /// Optional element 'ns2:duration' of XSD type 'xsd:integer'
        std::string *duration;
        /// Optional element 'ns2:overridePaymentMethod' of XSD type 'xsd:string'
        std::string *overridePaymentMethod;
        /// Optional element 'ns2:mobileRemotePaymentType' of XSD type 'xsd:string'
        std::string *mobileRemotePaymentType;
        /// Optional element 'ns2:cardholderVerificationMethod' of XSD type 'xsd:string'
        std::string *cardholderVerificationMethod;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__CCAuthService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__CCAuthService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__CCAuthService, default initialized and not managed by a soap context
        virtual ns2__CCAuthService *soap_alloc(void) const { return SOAP_NEW(ns2__CCAuthService); }
      public:
        /// Constructor with initializations
        ns2__CCAuthService()
        {
          cavv = (std::string *)0;
          cavvAlgorithm = (std::string *)0;
          commerceIndicator = (std::string *)0;
          eciRaw = (std::string *)0;
          xid = (std::string *)0;
          reconciliationID = (std::string *)0;
          avsLevel = (std::string *)0;
          fxQuoteID = (std::string *)0;
          returnAuthRecord = (std::string *)0;
          authType = (std::string *)0;
          verbalAuthCode = (std::string *)0;
          billPayment = (std::string *)0;
          authenticationXID = (std::string *)0;
          authorizationXID = (std::string *)0;
          industryDatatype = (std::string *)0;
          traceNumber = (std::string *)0;
          checksumKey = (std::string *)0;
          aggregatorID = (std::string *)0;
          aggregatorName = (std::string *)0;
          splitTenderIndicator = (std::string *)0;
          veresEnrolled = (std::string *)0;
          paresStatus = (std::string *)0;
          partialAuthIndicator = (std::string *)0;
          captureDate = (std::string *)0;
          firstRecurringPayment = (std::string *)0;
          duration = (std::string *)0;
          overridePaymentMethod = (std::string *)0;
          mobileRemotePaymentType = (std::string *)0;
          cardholderVerificationMethod = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__CCAuthService() { }
        /// Friend allocator used by soap_new_ns2__CCAuthService(struct soap*, int)
        friend SOAP_FMAC1 ns2__CCAuthService * SOAP_FMAC2 soap_instantiate_ns2__CCAuthService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:159 */
#ifndef SOAP_TYPE_ns2__OCTService
#define SOAP_TYPE_ns2__OCTService (112)
/* complex XSD type 'ns2:OCTService': */
class SOAP_CMAC ns2__OCTService {
      public:
        /// Optional element 'ns2:commerceIndicator' of XSD type 'xsd:string'
        std::string *commerceIndicator;
        /// Optional element 'ns2:reconciliationID' of XSD type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:networkOrder' of XSD type 'xsd:string'
        std::string *networkOrder;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__OCTService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__OCTService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__OCTService, default initialized and not managed by a soap context
        virtual ns2__OCTService *soap_alloc(void) const { return SOAP_NEW(ns2__OCTService); }
      public:
        /// Constructor with initializations
        ns2__OCTService()
        {
          commerceIndicator = (std::string *)0;
          reconciliationID = (std::string *)0;
          networkOrder = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__OCTService() { }
        /// Friend allocator used by soap_new_ns2__OCTService(struct soap*, int)
        friend SOAP_FMAC1 ns2__OCTService * SOAP_FMAC2 soap_instantiate_ns2__OCTService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:162 */
#ifndef SOAP_TYPE_ns2__VerificationService
#define SOAP_TYPE_ns2__VerificationService (113)
/* complex XSD type 'ns2:VerificationService': */
class SOAP_CMAC ns2__VerificationService {
      public:
        /// Optional element 'ns2:reconciliationID' of XSD type 'xsd:string'
        std::string *reconciliationID;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__VerificationService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__VerificationService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__VerificationService, default initialized and not managed by a soap context
        virtual ns2__VerificationService *soap_alloc(void) const { return SOAP_NEW(ns2__VerificationService); }
      public:
        /// Constructor with initializations
        ns2__VerificationService()
        {
          reconciliationID = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__VerificationService() { }
        /// Friend allocator used by soap_new_ns2__VerificationService(struct soap*, int)
        friend SOAP_FMAC1 ns2__VerificationService * SOAP_FMAC2 soap_instantiate_ns2__VerificationService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:165 */
#ifndef SOAP_TYPE_ns2__CCSaleService
#define SOAP_TYPE_ns2__CCSaleService (114)
/* complex XSD type 'ns2:CCSaleService': */
class SOAP_CMAC ns2__CCSaleService {
      public:
        /// Optional element 'ns2:overridePaymentMethod' of XSD type 'xsd:string'
        std::string *overridePaymentMethod;
        /// Optional element 'ns2:commerceIndicator' of XSD type 'xsd:string'
        std::string *commerceIndicator;
        /// Optional element 'ns2:partialAuthIndicator' of XSD type 'ns2:boolean'
        std::string *partialAuthIndicator;
        /// Optional element 'ns2:cavv' of XSD type 'xsd:string'
        std::string *cavv;
        /// Optional element 'ns2:xid' of XSD type 'xsd:string'
        std::string *xid;
        /// Optional element 'ns2:reconciliationID' of XSD type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:industryDatatype' of XSD type 'xsd:string'
        std::string *industryDatatype;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__CCSaleService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__CCSaleService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__CCSaleService, default initialized and not managed by a soap context
        virtual ns2__CCSaleService *soap_alloc(void) const { return SOAP_NEW(ns2__CCSaleService); }
      public:
        /// Constructor with initializations
        ns2__CCSaleService()
        {
          overridePaymentMethod = (std::string *)0;
          commerceIndicator = (std::string *)0;
          partialAuthIndicator = (std::string *)0;
          cavv = (std::string *)0;
          xid = (std::string *)0;
          reconciliationID = (std::string *)0;
          industryDatatype = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__CCSaleService() { }
        /// Friend allocator used by soap_new_ns2__CCSaleService(struct soap*, int)
        friend SOAP_FMAC1 ns2__CCSaleService * SOAP_FMAC2 soap_instantiate_ns2__CCSaleService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:168 */
#ifndef SOAP_TYPE_ns2__CCSaleCreditService
#define SOAP_TYPE_ns2__CCSaleCreditService (115)
/* complex XSD type 'ns2:CCSaleCreditService': */
class SOAP_CMAC ns2__CCSaleCreditService {
      public:
        /// Optional element 'ns2:overridePaymentMethod' of XSD type 'xsd:string'
        std::string *overridePaymentMethod;
        /// Optional element 'ns2:commerceIndicator' of XSD type 'xsd:string'
        std::string *commerceIndicator;
        /// Optional element 'ns2:reconciliationID' of XSD type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:refundReason' of XSD type 'xsd:string'
        std::string *refundReason;
        /// Optional element 'ns2:saleRequestID' of XSD type 'xsd:string'
        std::string *saleRequestID;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__CCSaleCreditService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__CCSaleCreditService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__CCSaleCreditService, default initialized and not managed by a soap context
        virtual ns2__CCSaleCreditService *soap_alloc(void) const { return SOAP_NEW(ns2__CCSaleCreditService); }
      public:
        /// Constructor with initializations
        ns2__CCSaleCreditService()
        {
          overridePaymentMethod = (std::string *)0;
          commerceIndicator = (std::string *)0;
          reconciliationID = (std::string *)0;
          refundReason = (std::string *)0;
          saleRequestID = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__CCSaleCreditService() { }
        /// Friend allocator used by soap_new_ns2__CCSaleCreditService(struct soap*, int)
        friend SOAP_FMAC1 ns2__CCSaleCreditService * SOAP_FMAC2 soap_instantiate_ns2__CCSaleCreditService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:171 */
#ifndef SOAP_TYPE_ns2__CCSaleReversalService
#define SOAP_TYPE_ns2__CCSaleReversalService (116)
/* complex XSD type 'ns2:CCSaleReversalService': */
class SOAP_CMAC ns2__CCSaleReversalService {
      public:
        /// Optional element 'ns2:saleRequestID' of XSD type 'xsd:string'
        std::string *saleRequestID;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__CCSaleReversalService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__CCSaleReversalService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__CCSaleReversalService, default initialized and not managed by a soap context
        virtual ns2__CCSaleReversalService *soap_alloc(void) const { return SOAP_NEW(ns2__CCSaleReversalService); }
      public:
        /// Constructor with initializations
        ns2__CCSaleReversalService()
        {
          saleRequestID = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__CCSaleReversalService() { }
        /// Friend allocator used by soap_new_ns2__CCSaleReversalService(struct soap*, int)
        friend SOAP_FMAC1 ns2__CCSaleReversalService * SOAP_FMAC2 soap_instantiate_ns2__CCSaleReversalService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:174 */
#ifndef SOAP_TYPE_ns2__CCIncrementalAuthService
#define SOAP_TYPE_ns2__CCIncrementalAuthService (117)
/* complex XSD type 'ns2:CCIncrementalAuthService': */
class SOAP_CMAC ns2__CCIncrementalAuthService {
      public:
        /// Optional element 'ns2:authRequestID' of XSD type 'xsd:string'
        std::string *authRequestID;
        /// Optional element 'ns2:duration' of XSD type 'xsd:integer'
        std::string *duration;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__CCIncrementalAuthService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__CCIncrementalAuthService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__CCIncrementalAuthService, default initialized and not managed by a soap context
        virtual ns2__CCIncrementalAuthService *soap_alloc(void) const { return SOAP_NEW(ns2__CCIncrementalAuthService); }
      public:
        /// Constructor with initializations
        ns2__CCIncrementalAuthService()
        {
          authRequestID = (std::string *)0;
          duration = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__CCIncrementalAuthService() { }
        /// Friend allocator used by soap_new_ns2__CCIncrementalAuthService(struct soap*, int)
        friend SOAP_FMAC1 ns2__CCIncrementalAuthService * SOAP_FMAC2 soap_instantiate_ns2__CCIncrementalAuthService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:177 */
#ifndef SOAP_TYPE_ns2__CCCaptureService
#define SOAP_TYPE_ns2__CCCaptureService (118)
/* complex XSD type 'ns2:CCCaptureService': */
class SOAP_CMAC ns2__CCCaptureService {
      public:
        /// Optional element 'ns2:authType' of XSD type 'xsd:string'
        std::string *authType;
        /// Optional element 'ns2:verbalAuthCode' of XSD type 'xsd:string'
        std::string *verbalAuthCode;
        /// Optional element 'ns2:authRequestID' of XSD type 'xsd:string'
        std::string *authRequestID;
        /// Optional element 'ns2:reconciliationID' of XSD type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:partialPaymentID' of XSD type 'xsd:string'
        std::string *partialPaymentID;
        /// Optional element 'ns2:purchasingLevel' of XSD type 'xsd:string'
        std::string *purchasingLevel;
        /// Optional element 'ns2:industryDatatype' of XSD type 'xsd:string'
        std::string *industryDatatype;
        /// Optional element 'ns2:authRequestToken' of XSD type 'xsd:string'
        std::string *authRequestToken;
        /// Optional element 'ns2:merchantReceiptNumber' of XSD type 'xsd:string'
        std::string *merchantReceiptNumber;
        /// Optional element 'ns2:posData' of XSD type 'xsd:string'
        std::string *posData;
        /// Optional element 'ns2:transactionID' of XSD type 'xsd:string'
        std::string *transactionID;
        /// Optional element 'ns2:checksumKey' of XSD type 'xsd:string'
        std::string *checksumKey;
        /// Optional element 'ns2:gratuityAmount' of XSD type 'xsd:string'
        std::string *gratuityAmount;
        /// Optional element 'ns2:duration' of XSD type 'xsd:integer'
        std::string *duration;
        /// Optional element 'ns2:dpdeBillingMonth' of XSD type 'xsd:integer'
        std::string *dpdeBillingMonth;
        /// Optional element 'ns2:sequence' of XSD type 'xsd:string'
        std::string *sequence;
        /// Optional element 'ns2:totalCount' of XSD type 'xsd:string'
        std::string *totalCount;
        /// Optional element 'ns2:reconciliationIDAlternate' of XSD type 'xsd:string'
        std::string *reconciliationIDAlternate;
        /// Optional element 'ns2:aggregatorID' of XSD type 'xsd:string'
        std::string *aggregatorID;
        /// Optional element 'ns2:aggregatorName' of XSD type 'xsd:string'
        std::string *aggregatorName;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__CCCaptureService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__CCCaptureService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__CCCaptureService, default initialized and not managed by a soap context
        virtual ns2__CCCaptureService *soap_alloc(void) const { return SOAP_NEW(ns2__CCCaptureService); }
      public:
        /// Constructor with initializations
        ns2__CCCaptureService()
        {
          authType = (std::string *)0;
          verbalAuthCode = (std::string *)0;
          authRequestID = (std::string *)0;
          reconciliationID = (std::string *)0;
          partialPaymentID = (std::string *)0;
          purchasingLevel = (std::string *)0;
          industryDatatype = (std::string *)0;
          authRequestToken = (std::string *)0;
          merchantReceiptNumber = (std::string *)0;
          posData = (std::string *)0;
          transactionID = (std::string *)0;
          checksumKey = (std::string *)0;
          gratuityAmount = (std::string *)0;
          duration = (std::string *)0;
          dpdeBillingMonth = (std::string *)0;
          sequence = (std::string *)0;
          totalCount = (std::string *)0;
          reconciliationIDAlternate = (std::string *)0;
          aggregatorID = (std::string *)0;
          aggregatorName = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__CCCaptureService() { }
        /// Friend allocator used by soap_new_ns2__CCCaptureService(struct soap*, int)
        friend SOAP_FMAC1 ns2__CCCaptureService * SOAP_FMAC2 soap_instantiate_ns2__CCCaptureService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:180 */
#ifndef SOAP_TYPE_ns2__CCCreditService
#define SOAP_TYPE_ns2__CCCreditService (119)
/* complex XSD type 'ns2:CCCreditService': */
class SOAP_CMAC ns2__CCCreditService {
      public:
        /// Optional element 'ns2:captureRequestID' of XSD type 'xsd:string'
        std::string *captureRequestID;
        /// Optional element 'ns2:reconciliationID' of XSD type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:partialPaymentID' of XSD type 'xsd:string'
        std::string *partialPaymentID;
        /// Optional element 'ns2:purchasingLevel' of XSD type 'xsd:string'
        std::string *purchasingLevel;
        /// Optional element 'ns2:industryDatatype' of XSD type 'xsd:string'
        std::string *industryDatatype;
        /// Optional element 'ns2:commerceIndicator' of XSD type 'xsd:string'
        std::string *commerceIndicator;
        /// Optional element 'ns2:billPayment' of XSD type 'ns2:boolean'
        std::string *billPayment;
        /// Optional element 'ns2:authorizationXID' of XSD type 'xsd:string'
        std::string *authorizationXID;
        /// Optional element 'ns2:occurrenceNumber' of XSD type 'xsd:string'
        std::string *occurrenceNumber;
        /// Optional element 'ns2:authCode' of XSD type 'xsd:string'
        std::string *authCode;
        /// Optional element 'ns2:captureRequestToken' of XSD type 'xsd:string'
        std::string *captureRequestToken;
        /// Optional element 'ns2:merchantReceiptNumber' of XSD type 'xsd:string'
        std::string *merchantReceiptNumber;
        /// Optional element 'ns2:checksumKey' of XSD type 'xsd:string'
        std::string *checksumKey;
        /// Optional element 'ns2:aggregatorID' of XSD type 'xsd:string'
        std::string *aggregatorID;
        /// Optional element 'ns2:aggregatorName' of XSD type 'xsd:string'
        std::string *aggregatorName;
        /// Optional element 'ns2:duration' of XSD type 'xsd:integer'
        std::string *duration;
        /// Optional element 'ns2:dpdeBillingMonth' of XSD type 'xsd:integer'
        std::string *dpdeBillingMonth;
        /// Optional element 'ns2:reconciliationIDAlternate' of XSD type 'xsd:string'
        std::string *reconciliationIDAlternate;
        /// Optional element 'ns2:refundReason' of XSD type 'xsd:string'
        std::string *refundReason;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__CCCreditService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__CCCreditService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__CCCreditService, default initialized and not managed by a soap context
        virtual ns2__CCCreditService *soap_alloc(void) const { return SOAP_NEW(ns2__CCCreditService); }
      public:
        /// Constructor with initializations
        ns2__CCCreditService()
        {
          captureRequestID = (std::string *)0;
          reconciliationID = (std::string *)0;
          partialPaymentID = (std::string *)0;
          purchasingLevel = (std::string *)0;
          industryDatatype = (std::string *)0;
          commerceIndicator = (std::string *)0;
          billPayment = (std::string *)0;
          authorizationXID = (std::string *)0;
          occurrenceNumber = (std::string *)0;
          authCode = (std::string *)0;
          captureRequestToken = (std::string *)0;
          merchantReceiptNumber = (std::string *)0;
          checksumKey = (std::string *)0;
          aggregatorID = (std::string *)0;
          aggregatorName = (std::string *)0;
          duration = (std::string *)0;
          dpdeBillingMonth = (std::string *)0;
          reconciliationIDAlternate = (std::string *)0;
          refundReason = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__CCCreditService() { }
        /// Friend allocator used by soap_new_ns2__CCCreditService(struct soap*, int)
        friend SOAP_FMAC1 ns2__CCCreditService * SOAP_FMAC2 soap_instantiate_ns2__CCCreditService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:183 */
#ifndef SOAP_TYPE_ns2__CCAuthReversalService
#define SOAP_TYPE_ns2__CCAuthReversalService (120)
/* complex XSD type 'ns2:CCAuthReversalService': */
class SOAP_CMAC ns2__CCAuthReversalService {
      public:
        /// Optional element 'ns2:authRequestID' of XSD type 'xsd:string'
        std::string *authRequestID;
        /// Optional element 'ns2:authRequestToken' of XSD type 'xsd:string'
        std::string *authRequestToken;
        /// Optional element 'ns2:reversalReason' of XSD type 'xsd:string'
        std::string *reversalReason;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__CCAuthReversalService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__CCAuthReversalService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__CCAuthReversalService, default initialized and not managed by a soap context
        virtual ns2__CCAuthReversalService *soap_alloc(void) const { return SOAP_NEW(ns2__CCAuthReversalService); }
      public:
        /// Constructor with initializations
        ns2__CCAuthReversalService()
        {
          authRequestID = (std::string *)0;
          authRequestToken = (std::string *)0;
          reversalReason = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__CCAuthReversalService() { }
        /// Friend allocator used by soap_new_ns2__CCAuthReversalService(struct soap*, int)
        friend SOAP_FMAC1 ns2__CCAuthReversalService * SOAP_FMAC2 soap_instantiate_ns2__CCAuthReversalService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:186 */
#ifndef SOAP_TYPE_ns2__CCAutoAuthReversalService
#define SOAP_TYPE_ns2__CCAutoAuthReversalService (121)
/* complex XSD type 'ns2:CCAutoAuthReversalService': */
class SOAP_CMAC ns2__CCAutoAuthReversalService {
      public:
        /// Optional element 'ns2:authPaymentServiceData' of XSD type 'xsd:string'
        std::string *authPaymentServiceData;
        /// Optional element 'ns2:reconciliationID' of XSD type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:authAmount' of XSD type 'xsd:string'
        std::string *authAmount;
        /// Optional element 'ns2:commerceIndicator' of XSD type 'xsd:string'
        std::string *commerceIndicator;
        /// Optional element 'ns2:authRequestID' of XSD type 'xsd:string'
        std::string *authRequestID;
        /// Optional element 'ns2:billAmount' of XSD type 'xsd:string'
        std::string *billAmount;
        /// Optional element 'ns2:authCode' of XSD type 'xsd:string'
        std::string *authCode;
        /// Optional element 'ns2:authType' of XSD type 'xsd:string'
        std::string *authType;
        /// Optional element 'ns2:billPayment' of XSD type 'ns2:boolean'
        std::string *billPayment;
        /// Optional element 'ns2:dateAdded' of XSD type 'xsd:string'
        std::string *dateAdded;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__CCAutoAuthReversalService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__CCAutoAuthReversalService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__CCAutoAuthReversalService, default initialized and not managed by a soap context
        virtual ns2__CCAutoAuthReversalService *soap_alloc(void) const { return SOAP_NEW(ns2__CCAutoAuthReversalService); }
      public:
        /// Constructor with initializations
        ns2__CCAutoAuthReversalService()
        {
          authPaymentServiceData = (std::string *)0;
          reconciliationID = (std::string *)0;
          authAmount = (std::string *)0;
          commerceIndicator = (std::string *)0;
          authRequestID = (std::string *)0;
          billAmount = (std::string *)0;
          authCode = (std::string *)0;
          authType = (std::string *)0;
          billPayment = (std::string *)0;
          dateAdded = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__CCAutoAuthReversalService() { }
        /// Friend allocator used by soap_new_ns2__CCAutoAuthReversalService(struct soap*, int)
        friend SOAP_FMAC1 ns2__CCAutoAuthReversalService * SOAP_FMAC2 soap_instantiate_ns2__CCAutoAuthReversalService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:189 */
#ifndef SOAP_TYPE_ns2__CCDCCService
#define SOAP_TYPE_ns2__CCDCCService (122)
/* complex XSD type 'ns2:CCDCCService': */
class SOAP_CMAC ns2__CCDCCService {
      public:
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__CCDCCService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__CCDCCService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__CCDCCService, default initialized and not managed by a soap context
        virtual ns2__CCDCCService *soap_alloc(void) const { return SOAP_NEW(ns2__CCDCCService); }
      public:
        /// Constructor with initializations
        ns2__CCDCCService()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__CCDCCService() { }
        /// Friend allocator used by soap_new_ns2__CCDCCService(struct soap*, int)
        friend SOAP_FMAC1 ns2__CCDCCService * SOAP_FMAC2 soap_instantiate_ns2__CCDCCService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:192 */
#ifndef SOAP_TYPE_ns2__ServiceFeeCalculateService
#define SOAP_TYPE_ns2__ServiceFeeCalculateService (123)
/* complex XSD type 'ns2:ServiceFeeCalculateService': */
class SOAP_CMAC ns2__ServiceFeeCalculateService {
      public:
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ServiceFeeCalculateService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ServiceFeeCalculateService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ServiceFeeCalculateService, default initialized and not managed by a soap context
        virtual ns2__ServiceFeeCalculateService *soap_alloc(void) const { return SOAP_NEW(ns2__ServiceFeeCalculateService); }
      public:
        /// Constructor with initializations
        ns2__ServiceFeeCalculateService()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__ServiceFeeCalculateService() { }
        /// Friend allocator used by soap_new_ns2__ServiceFeeCalculateService(struct soap*, int)
        friend SOAP_FMAC1 ns2__ServiceFeeCalculateService * SOAP_FMAC2 soap_instantiate_ns2__ServiceFeeCalculateService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:195 */
#ifndef SOAP_TYPE_ns2__ECDebitService
#define SOAP_TYPE_ns2__ECDebitService (124)
/* complex XSD type 'ns2:ECDebitService': */
class SOAP_CMAC ns2__ECDebitService {
      public:
        /// Optional element 'ns2:paymentMode' of XSD type 'xsd:integer'
        std::string *paymentMode;
        /// Optional element 'ns2:referenceNumber' of XSD type 'xsd:string'
        std::string *referenceNumber;
        /// Optional element 'ns2:settlementMethod' of XSD type 'xsd:string'
        std::string *settlementMethod;
        /// Optional element 'ns2:transactionToken' of XSD type 'xsd:string'
        std::string *transactionToken;
        /// Optional element 'ns2:verificationLevel' of XSD type 'xsd:integer'
        std::string *verificationLevel;
        /// Optional element 'ns2:partialPaymentID' of XSD type 'xsd:string'
        std::string *partialPaymentID;
        /// Optional element 'ns2:commerceIndicator' of XSD type 'xsd:string'
        std::string *commerceIndicator;
        /// Optional element 'ns2:debitRequestID' of XSD type 'xsd:string'
        std::string *debitRequestID;
        /// Optional element 'ns2:effectiveDate' of XSD type 'xsd:string'
        std::string *effectiveDate;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ECDebitService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ECDebitService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ECDebitService, default initialized and not managed by a soap context
        virtual ns2__ECDebitService *soap_alloc(void) const { return SOAP_NEW(ns2__ECDebitService); }
      public:
        /// Constructor with initializations
        ns2__ECDebitService()
        {
          paymentMode = (std::string *)0;
          referenceNumber = (std::string *)0;
          settlementMethod = (std::string *)0;
          transactionToken = (std::string *)0;
          verificationLevel = (std::string *)0;
          partialPaymentID = (std::string *)0;
          commerceIndicator = (std::string *)0;
          debitRequestID = (std::string *)0;
          effectiveDate = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__ECDebitService() { }
        /// Friend allocator used by soap_new_ns2__ECDebitService(struct soap*, int)
        friend SOAP_FMAC1 ns2__ECDebitService * SOAP_FMAC2 soap_instantiate_ns2__ECDebitService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:198 */
#ifndef SOAP_TYPE_ns2__ECCreditService
#define SOAP_TYPE_ns2__ECCreditService (125)
/* complex XSD type 'ns2:ECCreditService': */
class SOAP_CMAC ns2__ECCreditService {
      public:
        /// Optional element 'ns2:referenceNumber' of XSD type 'xsd:string'
        std::string *referenceNumber;
        /// Optional element 'ns2:settlementMethod' of XSD type 'xsd:string'
        std::string *settlementMethod;
        /// Optional element 'ns2:transactionToken' of XSD type 'xsd:string'
        std::string *transactionToken;
        /// Optional element 'ns2:debitRequestID' of XSD type 'xsd:string'
        std::string *debitRequestID;
        /// Optional element 'ns2:partialPaymentID' of XSD type 'xsd:string'
        std::string *partialPaymentID;
        /// Optional element 'ns2:commerceIndicator' of XSD type 'xsd:string'
        std::string *commerceIndicator;
        /// Optional element 'ns2:debitRequestToken' of XSD type 'xsd:string'
        std::string *debitRequestToken;
        /// Optional element 'ns2:effectiveDate' of XSD type 'xsd:string'
        std::string *effectiveDate;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ECCreditService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ECCreditService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ECCreditService, default initialized and not managed by a soap context
        virtual ns2__ECCreditService *soap_alloc(void) const { return SOAP_NEW(ns2__ECCreditService); }
      public:
        /// Constructor with initializations
        ns2__ECCreditService()
        {
          referenceNumber = (std::string *)0;
          settlementMethod = (std::string *)0;
          transactionToken = (std::string *)0;
          debitRequestID = (std::string *)0;
          partialPaymentID = (std::string *)0;
          commerceIndicator = (std::string *)0;
          debitRequestToken = (std::string *)0;
          effectiveDate = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__ECCreditService() { }
        /// Friend allocator used by soap_new_ns2__ECCreditService(struct soap*, int)
        friend SOAP_FMAC1 ns2__ECCreditService * SOAP_FMAC2 soap_instantiate_ns2__ECCreditService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:201 */
#ifndef SOAP_TYPE_ns2__ECAuthenticateService
#define SOAP_TYPE_ns2__ECAuthenticateService (126)
/* complex XSD type 'ns2:ECAuthenticateService': */
class SOAP_CMAC ns2__ECAuthenticateService {
      public:
        /// Optional element 'ns2:referenceNumber' of XSD type 'xsd:string'
        std::string *referenceNumber;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ECAuthenticateService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ECAuthenticateService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ECAuthenticateService, default initialized and not managed by a soap context
        virtual ns2__ECAuthenticateService *soap_alloc(void) const { return SOAP_NEW(ns2__ECAuthenticateService); }
      public:
        /// Constructor with initializations
        ns2__ECAuthenticateService()
        {
          referenceNumber = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__ECAuthenticateService() { }
        /// Friend allocator used by soap_new_ns2__ECAuthenticateService(struct soap*, int)
        friend SOAP_FMAC1 ns2__ECAuthenticateService * SOAP_FMAC2 soap_instantiate_ns2__ECAuthenticateService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:204 */
#ifndef SOAP_TYPE_ns2__PayerAuthEnrollService
#define SOAP_TYPE_ns2__PayerAuthEnrollService (127)
/* complex XSD type 'ns2:PayerAuthEnrollService': */
class SOAP_CMAC ns2__PayerAuthEnrollService {
      public:
        /// Optional element 'ns2:httpAccept' of XSD type 'xsd:string'
        std::string *httpAccept;
        /// Optional element 'ns2:httpUserAgent' of XSD type 'xsd:string'
        std::string *httpUserAgent;
        /// Optional element 'ns2:merchantName' of XSD type 'xsd:string'
        std::string *merchantName;
        /// Optional element 'ns2:merchantURL' of XSD type 'xsd:string'
        std::string *merchantURL;
        /// Optional element 'ns2:purchaseDescription' of XSD type 'xsd:string'
        std::string *purchaseDescription;
        /// Optional element 'ns2:purchaseTime' of XSD type 'ns2:dateTime'
        std::string *purchaseTime;
        /// Optional element 'ns2:countryCode' of XSD type 'xsd:string'
        std::string *countryCode;
        /// Optional element 'ns2:acquirerBin' of XSD type 'xsd:string'
        std::string *acquirerBin;
        /// Optional element 'ns2:loginID' of XSD type 'xsd:string'
        std::string *loginID;
        /// Optional element 'ns2:password' of XSD type 'xsd:string'
        std::string *password;
        /// Optional element 'ns2:merchantID' of XSD type 'xsd:string'
        std::string *merchantID;
        /// Optional element 'ns2:overridePaymentMethod' of XSD type 'xsd:string'
        std::string *overridePaymentMethod;
        /// Optional element 'ns2:mobilePhone' of XSD type 'xsd:string'
        std::string *mobilePhone;
        /// Optional element 'ns2:MCC' of XSD type 'xsd:string'
        std::string *MCC;
        /// Optional element 'ns2:productCode' of XSD type 'xsd:string'
        std::string *productCode;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayerAuthEnrollService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PayerAuthEnrollService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayerAuthEnrollService, default initialized and not managed by a soap context
        virtual ns2__PayerAuthEnrollService *soap_alloc(void) const { return SOAP_NEW(ns2__PayerAuthEnrollService); }
      public:
        /// Constructor with initializations
        ns2__PayerAuthEnrollService()
        {
          httpAccept = (std::string *)0;
          httpUserAgent = (std::string *)0;
          merchantName = (std::string *)0;
          merchantURL = (std::string *)0;
          purchaseDescription = (std::string *)0;
          purchaseTime = (std::string *)0;
          countryCode = (std::string *)0;
          acquirerBin = (std::string *)0;
          loginID = (std::string *)0;
          password = (std::string *)0;
          merchantID = (std::string *)0;
          overridePaymentMethod = (std::string *)0;
          mobilePhone = (std::string *)0;
          MCC = (std::string *)0;
          productCode = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PayerAuthEnrollService() { }
        /// Friend allocator used by soap_new_ns2__PayerAuthEnrollService(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayerAuthEnrollService * SOAP_FMAC2 soap_instantiate_ns2__PayerAuthEnrollService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:207 */
#ifndef SOAP_TYPE_ns2__PayerAuthValidateService
#define SOAP_TYPE_ns2__PayerAuthValidateService (128)
/* complex XSD type 'ns2:PayerAuthValidateService': */
class SOAP_CMAC ns2__PayerAuthValidateService {
      public:
        /// Optional element 'ns2:signedPARes' of XSD type 'xsd:string'
        std::string *signedPARes;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayerAuthValidateService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PayerAuthValidateService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayerAuthValidateService, default initialized and not managed by a soap context
        virtual ns2__PayerAuthValidateService *soap_alloc(void) const { return SOAP_NEW(ns2__PayerAuthValidateService); }
      public:
        /// Constructor with initializations
        ns2__PayerAuthValidateService()
        {
          signedPARes = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PayerAuthValidateService() { }
        /// Friend allocator used by soap_new_ns2__PayerAuthValidateService(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayerAuthValidateService * SOAP_FMAC2 soap_instantiate_ns2__PayerAuthValidateService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:210 */
#ifndef SOAP_TYPE_ns2__TaxService
#define SOAP_TYPE_ns2__TaxService (129)
/* complex XSD type 'ns2:TaxService': */
class SOAP_CMAC ns2__TaxService {
      public:
        /// Optional element 'ns2:nexus' of XSD type 'xsd:string'
        std::string *nexus;
        /// Optional element 'ns2:noNexus' of XSD type 'xsd:string'
        std::string *noNexus;
        /// Optional element 'ns2:orderAcceptanceCity' of XSD type 'xsd:string'
        std::string *orderAcceptanceCity;
        /// Optional element 'ns2:orderAcceptanceCounty' of XSD type 'xsd:string'
        std::string *orderAcceptanceCounty;
        /// Optional element 'ns2:orderAcceptanceCountry' of XSD type 'xsd:string'
        std::string *orderAcceptanceCountry;
        /// Optional element 'ns2:orderAcceptanceState' of XSD type 'xsd:string'
        std::string *orderAcceptanceState;
        /// Optional element 'ns2:orderAcceptancePostalCode' of XSD type 'xsd:string'
        std::string *orderAcceptancePostalCode;
        /// Optional element 'ns2:orderOriginCity' of XSD type 'xsd:string'
        std::string *orderOriginCity;
        /// Optional element 'ns2:orderOriginCounty' of XSD type 'xsd:string'
        std::string *orderOriginCounty;
        /// Optional element 'ns2:orderOriginCountry' of XSD type 'xsd:string'
        std::string *orderOriginCountry;
        /// Optional element 'ns2:orderOriginState' of XSD type 'xsd:string'
        std::string *orderOriginState;
        /// Optional element 'ns2:orderOriginPostalCode' of XSD type 'xsd:string'
        std::string *orderOriginPostalCode;
        /// Optional element 'ns2:sellerRegistration' of XSD type 'xsd:string'
        std::string *sellerRegistration;
        /// Optional element 'ns2:sellerRegistration0' of XSD type 'xsd:string'
        std::string *sellerRegistration0;
        /// Optional element 'ns2:sellerRegistration1' of XSD type 'xsd:string'
        std::string *sellerRegistration1;
        /// Optional element 'ns2:sellerRegistration2' of XSD type 'xsd:string'
        std::string *sellerRegistration2;
        /// Optional element 'ns2:sellerRegistration3' of XSD type 'xsd:string'
        std::string *sellerRegistration3;
        /// Optional element 'ns2:sellerRegistration4' of XSD type 'xsd:string'
        std::string *sellerRegistration4;
        /// Optional element 'ns2:sellerRegistration5' of XSD type 'xsd:string'
        std::string *sellerRegistration5;
        /// Optional element 'ns2:sellerRegistration6' of XSD type 'xsd:string'
        std::string *sellerRegistration6;
        /// Optional element 'ns2:sellerRegistration7' of XSD type 'xsd:string'
        std::string *sellerRegistration7;
        /// Optional element 'ns2:sellerRegistration8' of XSD type 'xsd:string'
        std::string *sellerRegistration8;
        /// Optional element 'ns2:sellerRegistration9' of XSD type 'xsd:string'
        std::string *sellerRegistration9;
        /// Optional element 'ns2:buyerRegistration' of XSD type 'xsd:string'
        std::string *buyerRegistration;
        /// Optional element 'ns2:middlemanRegistration' of XSD type 'xsd:string'
        std::string *middlemanRegistration;
        /// Optional element 'ns2:pointOfTitleTransfer' of XSD type 'xsd:string'
        std::string *pointOfTitleTransfer;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__TaxService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__TaxService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__TaxService, default initialized and not managed by a soap context
        virtual ns2__TaxService *soap_alloc(void) const { return SOAP_NEW(ns2__TaxService); }
      public:
        /// Constructor with initializations
        ns2__TaxService()
        {
          nexus = (std::string *)0;
          noNexus = (std::string *)0;
          orderAcceptanceCity = (std::string *)0;
          orderAcceptanceCounty = (std::string *)0;
          orderAcceptanceCountry = (std::string *)0;
          orderAcceptanceState = (std::string *)0;
          orderAcceptancePostalCode = (std::string *)0;
          orderOriginCity = (std::string *)0;
          orderOriginCounty = (std::string *)0;
          orderOriginCountry = (std::string *)0;
          orderOriginState = (std::string *)0;
          orderOriginPostalCode = (std::string *)0;
          sellerRegistration = (std::string *)0;
          sellerRegistration0 = (std::string *)0;
          sellerRegistration1 = (std::string *)0;
          sellerRegistration2 = (std::string *)0;
          sellerRegistration3 = (std::string *)0;
          sellerRegistration4 = (std::string *)0;
          sellerRegistration5 = (std::string *)0;
          sellerRegistration6 = (std::string *)0;
          sellerRegistration7 = (std::string *)0;
          sellerRegistration8 = (std::string *)0;
          sellerRegistration9 = (std::string *)0;
          buyerRegistration = (std::string *)0;
          middlemanRegistration = (std::string *)0;
          pointOfTitleTransfer = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__TaxService() { }
        /// Friend allocator used by soap_new_ns2__TaxService(struct soap*, int)
        friend SOAP_FMAC1 ns2__TaxService * SOAP_FMAC2 soap_instantiate_ns2__TaxService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:213 */
#ifndef SOAP_TYPE_ns2__DMEService
#define SOAP_TYPE_ns2__DMEService (130)
/* complex XSD type 'ns2:DMEService': */
class SOAP_CMAC ns2__DMEService {
      public:
        /// Optional element 'ns2:eventType' of XSD type 'xsd:string'
        std::string *eventType;
        /// Optional element 'ns2:eventPolicy' of XSD type 'xsd:string'
        std::string *eventPolicy;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__DMEService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__DMEService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__DMEService, default initialized and not managed by a soap context
        virtual ns2__DMEService *soap_alloc(void) const { return SOAP_NEW(ns2__DMEService); }
      public:
        /// Constructor with initializations
        ns2__DMEService()
        {
          eventType = (std::string *)0;
          eventPolicy = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__DMEService() { }
        /// Friend allocator used by soap_new_ns2__DMEService(struct soap*, int)
        friend SOAP_FMAC1 ns2__DMEService * SOAP_FMAC2 soap_instantiate_ns2__DMEService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:216 */
#ifndef SOAP_TYPE_ns2__AFSService
#define SOAP_TYPE_ns2__AFSService (131)
/* complex XSD type 'ns2:AFSService': */
class SOAP_CMAC ns2__AFSService {
      public:
        /// Optional element 'ns2:avsCode' of XSD type 'xsd:string'
        std::string *avsCode;
        /// Optional element 'ns2:cvCode' of XSD type 'xsd:string'
        std::string *cvCode;
        /// Optional element 'ns2:disableAVSScoring' of XSD type 'ns2:boolean'
        std::string *disableAVSScoring;
        /// Optional element 'ns2:customRiskModel' of XSD type 'xsd:string'
        std::string *customRiskModel;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__AFSService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__AFSService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__AFSService, default initialized and not managed by a soap context
        virtual ns2__AFSService *soap_alloc(void) const { return SOAP_NEW(ns2__AFSService); }
      public:
        /// Constructor with initializations
        ns2__AFSService()
        {
          avsCode = (std::string *)0;
          cvCode = (std::string *)0;
          disableAVSScoring = (std::string *)0;
          customRiskModel = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__AFSService() { }
        /// Friend allocator used by soap_new_ns2__AFSService(struct soap*, int)
        friend SOAP_FMAC1 ns2__AFSService * SOAP_FMAC2 soap_instantiate_ns2__AFSService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:219 */
#ifndef SOAP_TYPE_ns2__DAVService
#define SOAP_TYPE_ns2__DAVService (132)
/* complex XSD type 'ns2:DAVService': */
class SOAP_CMAC ns2__DAVService {
      public:
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__DAVService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__DAVService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__DAVService, default initialized and not managed by a soap context
        virtual ns2__DAVService *soap_alloc(void) const { return SOAP_NEW(ns2__DAVService); }
      public:
        /// Constructor with initializations
        ns2__DAVService()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__DAVService() { }
        /// Friend allocator used by soap_new_ns2__DAVService(struct soap*, int)
        friend SOAP_FMAC1 ns2__DAVService * SOAP_FMAC2 soap_instantiate_ns2__DAVService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:222 */
#ifndef SOAP_TYPE_ns2__ExportService
#define SOAP_TYPE_ns2__ExportService (133)
/* complex XSD type 'ns2:ExportService': */
class SOAP_CMAC ns2__ExportService {
      public:
        /// Optional element 'ns2:addressOperator' of XSD type 'xsd:string'
        std::string *addressOperator;
        /// Optional element 'ns2:addressWeight' of XSD type 'xsd:string'
        std::string *addressWeight;
        /// Optional element 'ns2:companyWeight' of XSD type 'xsd:string'
        std::string *companyWeight;
        /// Optional element 'ns2:nameWeight' of XSD type 'xsd:string'
        std::string *nameWeight;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ExportService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ExportService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ExportService, default initialized and not managed by a soap context
        virtual ns2__ExportService *soap_alloc(void) const { return SOAP_NEW(ns2__ExportService); }
      public:
        /// Constructor with initializations
        ns2__ExportService()
        {
          addressOperator = (std::string *)0;
          addressWeight = (std::string *)0;
          companyWeight = (std::string *)0;
          nameWeight = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__ExportService() { }
        /// Friend allocator used by soap_new_ns2__ExportService(struct soap*, int)
        friend SOAP_FMAC1 ns2__ExportService * SOAP_FMAC2 soap_instantiate_ns2__ExportService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:225 */
#ifndef SOAP_TYPE_ns2__FXRatesService
#define SOAP_TYPE_ns2__FXRatesService (134)
/* complex XSD type 'ns2:FXRatesService': */
class SOAP_CMAC ns2__FXRatesService {
      public:
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__FXRatesService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__FXRatesService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__FXRatesService, default initialized and not managed by a soap context
        virtual ns2__FXRatesService *soap_alloc(void) const { return SOAP_NEW(ns2__FXRatesService); }
      public:
        /// Constructor with initializations
        ns2__FXRatesService()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__FXRatesService() { }
        /// Friend allocator used by soap_new_ns2__FXRatesService(struct soap*, int)
        friend SOAP_FMAC1 ns2__FXRatesService * SOAP_FMAC2 soap_instantiate_ns2__FXRatesService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:228 */
#ifndef SOAP_TYPE_ns2__BankTransferService
#define SOAP_TYPE_ns2__BankTransferService (135)
/* complex XSD type 'ns2:BankTransferService': */
class SOAP_CMAC ns2__BankTransferService {
      public:
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__BankTransferService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__BankTransferService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__BankTransferService, default initialized and not managed by a soap context
        virtual ns2__BankTransferService *soap_alloc(void) const { return SOAP_NEW(ns2__BankTransferService); }
      public:
        /// Constructor with initializations
        ns2__BankTransferService()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__BankTransferService() { }
        /// Friend allocator used by soap_new_ns2__BankTransferService(struct soap*, int)
        friend SOAP_FMAC1 ns2__BankTransferService * SOAP_FMAC2 soap_instantiate_ns2__BankTransferService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:231 */
#ifndef SOAP_TYPE_ns2__BankTransferRefundService
#define SOAP_TYPE_ns2__BankTransferRefundService (136)
/* complex XSD type 'ns2:BankTransferRefundService': */
class SOAP_CMAC ns2__BankTransferRefundService {
      public:
        /// Optional element 'ns2:bankTransferRequestID' of XSD type 'xsd:string'
        std::string *bankTransferRequestID;
        /// Optional element 'ns2:bankTransferRealTimeRequestID' of XSD type 'xsd:string'
        std::string *bankTransferRealTimeRequestID;
        /// Optional element 'ns2:reconciliationID' of XSD type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:bankTransferRealTimeReconciliationID' of XSD type 'xsd:string'
        std::string *bankTransferRealTimeReconciliationID;
        /// Optional element 'ns2:bankTransferRequestToken' of XSD type 'xsd:string'
        std::string *bankTransferRequestToken;
        /// Optional element 'ns2:bankTransferRealTimeRequestToken' of XSD type 'xsd:string'
        std::string *bankTransferRealTimeRequestToken;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__BankTransferRefundService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__BankTransferRefundService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__BankTransferRefundService, default initialized and not managed by a soap context
        virtual ns2__BankTransferRefundService *soap_alloc(void) const { return SOAP_NEW(ns2__BankTransferRefundService); }
      public:
        /// Constructor with initializations
        ns2__BankTransferRefundService()
        {
          bankTransferRequestID = (std::string *)0;
          bankTransferRealTimeRequestID = (std::string *)0;
          reconciliationID = (std::string *)0;
          bankTransferRealTimeReconciliationID = (std::string *)0;
          bankTransferRequestToken = (std::string *)0;
          bankTransferRealTimeRequestToken = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__BankTransferRefundService() { }
        /// Friend allocator used by soap_new_ns2__BankTransferRefundService(struct soap*, int)
        friend SOAP_FMAC1 ns2__BankTransferRefundService * SOAP_FMAC2 soap_instantiate_ns2__BankTransferRefundService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:234 */
#ifndef SOAP_TYPE_ns2__BankTransferRealTimeService
#define SOAP_TYPE_ns2__BankTransferRealTimeService (137)
/* complex XSD type 'ns2:BankTransferRealTimeService': */
class SOAP_CMAC ns2__BankTransferRealTimeService {
      public:
        /// Optional element 'ns2:bankTransferRealTimeType' of XSD type 'xsd:string'
        std::string *bankTransferRealTimeType;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__BankTransferRealTimeService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__BankTransferRealTimeService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__BankTransferRealTimeService, default initialized and not managed by a soap context
        virtual ns2__BankTransferRealTimeService *soap_alloc(void) const { return SOAP_NEW(ns2__BankTransferRealTimeService); }
      public:
        /// Constructor with initializations
        ns2__BankTransferRealTimeService()
        {
          bankTransferRealTimeType = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__BankTransferRealTimeService() { }
        /// Friend allocator used by soap_new_ns2__BankTransferRealTimeService(struct soap*, int)
        friend SOAP_FMAC1 ns2__BankTransferRealTimeService * SOAP_FMAC2 soap_instantiate_ns2__BankTransferRealTimeService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:237 */
#ifndef SOAP_TYPE_ns2__DirectDebitMandateService
#define SOAP_TYPE_ns2__DirectDebitMandateService (138)
/* complex XSD type 'ns2:DirectDebitMandateService': */
class SOAP_CMAC ns2__DirectDebitMandateService {
      public:
        /// Optional element 'ns2:mandateDescriptor' of XSD type 'xsd:string'
        std::string *mandateDescriptor;
        /// Optional element 'ns2:firstDebitDate' of XSD type 'xsd:string'
        std::string *firstDebitDate;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__DirectDebitMandateService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__DirectDebitMandateService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__DirectDebitMandateService, default initialized and not managed by a soap context
        virtual ns2__DirectDebitMandateService *soap_alloc(void) const { return SOAP_NEW(ns2__DirectDebitMandateService); }
      public:
        /// Constructor with initializations
        ns2__DirectDebitMandateService()
        {
          mandateDescriptor = (std::string *)0;
          firstDebitDate = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__DirectDebitMandateService() { }
        /// Friend allocator used by soap_new_ns2__DirectDebitMandateService(struct soap*, int)
        friend SOAP_FMAC1 ns2__DirectDebitMandateService * SOAP_FMAC2 soap_instantiate_ns2__DirectDebitMandateService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:240 */
#ifndef SOAP_TYPE_ns2__DirectDebitService
#define SOAP_TYPE_ns2__DirectDebitService (139)
/* complex XSD type 'ns2:DirectDebitService': */
class SOAP_CMAC ns2__DirectDebitService {
      public:
        /// Optional element 'ns2:dateCollect' of XSD type 'xsd:string'
        std::string *dateCollect;
        /// Optional element 'ns2:directDebitText' of XSD type 'xsd:string'
        std::string *directDebitText;
        /// Optional element 'ns2:authorizationID' of XSD type 'xsd:string'
        std::string *authorizationID;
        /// Optional element 'ns2:transactionType' of XSD type 'xsd:string'
        std::string *transactionType;
        /// Optional element 'ns2:directDebitType' of XSD type 'xsd:string'
        std::string *directDebitType;
        /// Optional element 'ns2:validateRequestID' of XSD type 'xsd:string'
        std::string *validateRequestID;
        /// Optional element 'ns2:recurringType' of XSD type 'xsd:string'
        std::string *recurringType;
        /// Optional element 'ns2:mandateID' of XSD type 'xsd:string'
        std::string *mandateID;
        /// Optional element 'ns2:validateRequestToken' of XSD type 'xsd:string'
        std::string *validateRequestToken;
        /// Optional element 'ns2:reconciliationID' of XSD type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:mandateAuthenticationDate' of XSD type 'xsd:string'
        std::string *mandateAuthenticationDate;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__DirectDebitService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__DirectDebitService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__DirectDebitService, default initialized and not managed by a soap context
        virtual ns2__DirectDebitService *soap_alloc(void) const { return SOAP_NEW(ns2__DirectDebitService); }
      public:
        /// Constructor with initializations
        ns2__DirectDebitService()
        {
          dateCollect = (std::string *)0;
          directDebitText = (std::string *)0;
          authorizationID = (std::string *)0;
          transactionType = (std::string *)0;
          directDebitType = (std::string *)0;
          validateRequestID = (std::string *)0;
          recurringType = (std::string *)0;
          mandateID = (std::string *)0;
          validateRequestToken = (std::string *)0;
          reconciliationID = (std::string *)0;
          mandateAuthenticationDate = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__DirectDebitService() { }
        /// Friend allocator used by soap_new_ns2__DirectDebitService(struct soap*, int)
        friend SOAP_FMAC1 ns2__DirectDebitService * SOAP_FMAC2 soap_instantiate_ns2__DirectDebitService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:243 */
#ifndef SOAP_TYPE_ns2__DirectDebitRefundService
#define SOAP_TYPE_ns2__DirectDebitRefundService (140)
/* complex XSD type 'ns2:DirectDebitRefundService': */
class SOAP_CMAC ns2__DirectDebitRefundService {
      public:
        /// Optional element 'ns2:directDebitRequestID' of XSD type 'xsd:string'
        std::string *directDebitRequestID;
        /// Optional element 'ns2:reconciliationID' of XSD type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:directDebitRequestToken' of XSD type 'xsd:string'
        std::string *directDebitRequestToken;
        /// Optional element 'ns2:directDebitType' of XSD type 'xsd:string'
        std::string *directDebitType;
        /// Optional element 'ns2:recurringType' of XSD type 'xsd:string'
        std::string *recurringType;
        /// Optional element 'ns2:mandateID' of XSD type 'xsd:string'
        std::string *mandateID;
        /// Optional element 'ns2:mandateAuthenticationDate' of XSD type 'xsd:string'
        std::string *mandateAuthenticationDate;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__DirectDebitRefundService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__DirectDebitRefundService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__DirectDebitRefundService, default initialized and not managed by a soap context
        virtual ns2__DirectDebitRefundService *soap_alloc(void) const { return SOAP_NEW(ns2__DirectDebitRefundService); }
      public:
        /// Constructor with initializations
        ns2__DirectDebitRefundService()
        {
          directDebitRequestID = (std::string *)0;
          reconciliationID = (std::string *)0;
          directDebitRequestToken = (std::string *)0;
          directDebitType = (std::string *)0;
          recurringType = (std::string *)0;
          mandateID = (std::string *)0;
          mandateAuthenticationDate = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__DirectDebitRefundService() { }
        /// Friend allocator used by soap_new_ns2__DirectDebitRefundService(struct soap*, int)
        friend SOAP_FMAC1 ns2__DirectDebitRefundService * SOAP_FMAC2 soap_instantiate_ns2__DirectDebitRefundService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:246 */
#ifndef SOAP_TYPE_ns2__DirectDebitValidateService
#define SOAP_TYPE_ns2__DirectDebitValidateService (141)
/* complex XSD type 'ns2:DirectDebitValidateService': */
class SOAP_CMAC ns2__DirectDebitValidateService {
      public:
        /// Optional element 'ns2:directDebitValidateText' of XSD type 'xsd:string'
        std::string *directDebitValidateText;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__DirectDebitValidateService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__DirectDebitValidateService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__DirectDebitValidateService, default initialized and not managed by a soap context
        virtual ns2__DirectDebitValidateService *soap_alloc(void) const { return SOAP_NEW(ns2__DirectDebitValidateService); }
      public:
        /// Constructor with initializations
        ns2__DirectDebitValidateService()
        {
          directDebitValidateText = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__DirectDebitValidateService() { }
        /// Friend allocator used by soap_new_ns2__DirectDebitValidateService(struct soap*, int)
        friend SOAP_FMAC1 ns2__DirectDebitValidateService * SOAP_FMAC2 soap_instantiate_ns2__DirectDebitValidateService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:249 */
#ifndef SOAP_TYPE_ns2__PaySubscriptionCreateService
#define SOAP_TYPE_ns2__PaySubscriptionCreateService (142)
/* complex XSD type 'ns2:PaySubscriptionCreateService': */
class SOAP_CMAC ns2__PaySubscriptionCreateService {
      public:
        /// Optional element 'ns2:paymentRequestID' of XSD type 'xsd:string'
        std::string *paymentRequestID;
        /// Optional element 'ns2:paymentRequestToken' of XSD type 'xsd:string'
        std::string *paymentRequestToken;
        /// Optional element 'ns2:disableAutoAuth' of XSD type 'ns2:boolean'
        std::string *disableAutoAuth;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PaySubscriptionCreateService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PaySubscriptionCreateService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PaySubscriptionCreateService, default initialized and not managed by a soap context
        virtual ns2__PaySubscriptionCreateService *soap_alloc(void) const { return SOAP_NEW(ns2__PaySubscriptionCreateService); }
      public:
        /// Constructor with initializations
        ns2__PaySubscriptionCreateService()
        {
          paymentRequestID = (std::string *)0;
          paymentRequestToken = (std::string *)0;
          disableAutoAuth = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PaySubscriptionCreateService() { }
        /// Friend allocator used by soap_new_ns2__PaySubscriptionCreateService(struct soap*, int)
        friend SOAP_FMAC1 ns2__PaySubscriptionCreateService * SOAP_FMAC2 soap_instantiate_ns2__PaySubscriptionCreateService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:252 */
#ifndef SOAP_TYPE_ns2__PaySubscriptionUpdateService
#define SOAP_TYPE_ns2__PaySubscriptionUpdateService (143)
/* complex XSD type 'ns2:PaySubscriptionUpdateService': */
class SOAP_CMAC ns2__PaySubscriptionUpdateService {
      public:
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PaySubscriptionUpdateService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PaySubscriptionUpdateService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PaySubscriptionUpdateService, default initialized and not managed by a soap context
        virtual ns2__PaySubscriptionUpdateService *soap_alloc(void) const { return SOAP_NEW(ns2__PaySubscriptionUpdateService); }
      public:
        /// Constructor with initializations
        ns2__PaySubscriptionUpdateService()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__PaySubscriptionUpdateService() { }
        /// Friend allocator used by soap_new_ns2__PaySubscriptionUpdateService(struct soap*, int)
        friend SOAP_FMAC1 ns2__PaySubscriptionUpdateService * SOAP_FMAC2 soap_instantiate_ns2__PaySubscriptionUpdateService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:255 */
#ifndef SOAP_TYPE_ns2__PaySubscriptionEventUpdateService
#define SOAP_TYPE_ns2__PaySubscriptionEventUpdateService (144)
/* complex XSD type 'ns2:PaySubscriptionEventUpdateService': */
class SOAP_CMAC ns2__PaySubscriptionEventUpdateService {
      public:
        /// Optional element 'ns2:action' of XSD type 'xsd:string'
        std::string *action;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PaySubscriptionEventUpdateService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PaySubscriptionEventUpdateService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PaySubscriptionEventUpdateService, default initialized and not managed by a soap context
        virtual ns2__PaySubscriptionEventUpdateService *soap_alloc(void) const { return SOAP_NEW(ns2__PaySubscriptionEventUpdateService); }
      public:
        /// Constructor with initializations
        ns2__PaySubscriptionEventUpdateService()
        {
          action = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PaySubscriptionEventUpdateService() { }
        /// Friend allocator used by soap_new_ns2__PaySubscriptionEventUpdateService(struct soap*, int)
        friend SOAP_FMAC1 ns2__PaySubscriptionEventUpdateService * SOAP_FMAC2 soap_instantiate_ns2__PaySubscriptionEventUpdateService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:258 */
#ifndef SOAP_TYPE_ns2__PaySubscriptionRetrieveService
#define SOAP_TYPE_ns2__PaySubscriptionRetrieveService (145)
/* complex XSD type 'ns2:PaySubscriptionRetrieveService': */
class SOAP_CMAC ns2__PaySubscriptionRetrieveService {
      public:
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PaySubscriptionRetrieveService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PaySubscriptionRetrieveService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PaySubscriptionRetrieveService, default initialized and not managed by a soap context
        virtual ns2__PaySubscriptionRetrieveService *soap_alloc(void) const { return SOAP_NEW(ns2__PaySubscriptionRetrieveService); }
      public:
        /// Constructor with initializations
        ns2__PaySubscriptionRetrieveService()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__PaySubscriptionRetrieveService() { }
        /// Friend allocator used by soap_new_ns2__PaySubscriptionRetrieveService(struct soap*, int)
        friend SOAP_FMAC1 ns2__PaySubscriptionRetrieveService * SOAP_FMAC2 soap_instantiate_ns2__PaySubscriptionRetrieveService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:261 */
#ifndef SOAP_TYPE_ns2__PaySubscriptionDeleteService
#define SOAP_TYPE_ns2__PaySubscriptionDeleteService (146)
/* complex XSD type 'ns2:PaySubscriptionDeleteService': */
class SOAP_CMAC ns2__PaySubscriptionDeleteService {
      public:
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PaySubscriptionDeleteService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PaySubscriptionDeleteService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PaySubscriptionDeleteService, default initialized and not managed by a soap context
        virtual ns2__PaySubscriptionDeleteService *soap_alloc(void) const { return SOAP_NEW(ns2__PaySubscriptionDeleteService); }
      public:
        /// Constructor with initializations
        ns2__PaySubscriptionDeleteService()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__PaySubscriptionDeleteService() { }
        /// Friend allocator used by soap_new_ns2__PaySubscriptionDeleteService(struct soap*, int)
        friend SOAP_FMAC1 ns2__PaySubscriptionDeleteService * SOAP_FMAC2 soap_instantiate_ns2__PaySubscriptionDeleteService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:264 */
#ifndef SOAP_TYPE_ns2__PayPalPaymentService
#define SOAP_TYPE_ns2__PayPalPaymentService (147)
/* complex XSD type 'ns2:PayPalPaymentService': */
class SOAP_CMAC ns2__PayPalPaymentService {
      public:
        /// Optional element 'ns2:cancelURL' of XSD type 'xsd:string'
        std::string *cancelURL;
        /// Optional element 'ns2:successURL' of XSD type 'xsd:string'
        std::string *successURL;
        /// Optional element 'ns2:reconciliationID' of XSD type 'xsd:string'
        std::string *reconciliationID;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalPaymentService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PayPalPaymentService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalPaymentService, default initialized and not managed by a soap context
        virtual ns2__PayPalPaymentService *soap_alloc(void) const { return SOAP_NEW(ns2__PayPalPaymentService); }
      public:
        /// Constructor with initializations
        ns2__PayPalPaymentService()
        {
          cancelURL = (std::string *)0;
          successURL = (std::string *)0;
          reconciliationID = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PayPalPaymentService() { }
        /// Friend allocator used by soap_new_ns2__PayPalPaymentService(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalPaymentService * SOAP_FMAC2 soap_instantiate_ns2__PayPalPaymentService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:267 */
#ifndef SOAP_TYPE_ns2__PayPalCreditService
#define SOAP_TYPE_ns2__PayPalCreditService (148)
/* complex XSD type 'ns2:PayPalCreditService': */
class SOAP_CMAC ns2__PayPalCreditService {
      public:
        /// Optional element 'ns2:payPalPaymentRequestID' of XSD type 'xsd:string'
        std::string *payPalPaymentRequestID;
        /// Optional element 'ns2:reconciliationID' of XSD type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:payPalPaymentRequestToken' of XSD type 'xsd:string'
        std::string *payPalPaymentRequestToken;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalCreditService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PayPalCreditService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalCreditService, default initialized and not managed by a soap context
        virtual ns2__PayPalCreditService *soap_alloc(void) const { return SOAP_NEW(ns2__PayPalCreditService); }
      public:
        /// Constructor with initializations
        ns2__PayPalCreditService()
        {
          payPalPaymentRequestID = (std::string *)0;
          reconciliationID = (std::string *)0;
          payPalPaymentRequestToken = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PayPalCreditService() { }
        /// Friend allocator used by soap_new_ns2__PayPalCreditService(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalCreditService * SOAP_FMAC2 soap_instantiate_ns2__PayPalCreditService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:270 */
#ifndef SOAP_TYPE_ns2__PayPalEcSetService
#define SOAP_TYPE_ns2__PayPalEcSetService (149)
/* complex XSD type 'ns2:PayPalEcSetService': */
class SOAP_CMAC ns2__PayPalEcSetService {
      public:
        /// Optional element 'ns2:paypalReturn' of XSD type 'xsd:string'
        std::string *paypalReturn;
        /// Optional element 'ns2:paypalCancelReturn' of XSD type 'xsd:string'
        std::string *paypalCancelReturn;
        /// Optional element 'ns2:paypalMaxamt' of XSD type 'xsd:string'
        std::string *paypalMaxamt;
        /// Optional element 'ns2:paypalCustomerEmail' of XSD type 'xsd:string'
        std::string *paypalCustomerEmail;
        /// Optional element 'ns2:paypalDesc' of XSD type 'xsd:string'
        std::string *paypalDesc;
        /// Optional element 'ns2:paypalReqconfirmshipping' of XSD type 'xsd:string'
        std::string *paypalReqconfirmshipping;
        /// Optional element 'ns2:paypalNoshipping' of XSD type 'xsd:string'
        std::string *paypalNoshipping;
        /// Optional element 'ns2:paypalAddressOverride' of XSD type 'xsd:string'
        std::string *paypalAddressOverride;
        /// Optional element 'ns2:paypalToken' of XSD type 'xsd:string'
        std::string *paypalToken;
        /// Optional element 'ns2:paypalLc' of XSD type 'xsd:string'
        std::string *paypalLc;
        /// Optional element 'ns2:paypalPagestyle' of XSD type 'xsd:string'
        std::string *paypalPagestyle;
        /// Optional element 'ns2:paypalHdrimg' of XSD type 'xsd:string'
        std::string *paypalHdrimg;
        /// Optional element 'ns2:paypalHdrbordercolor' of XSD type 'xsd:string'
        std::string *paypalHdrbordercolor;
        /// Optional element 'ns2:paypalHdrbackcolor' of XSD type 'xsd:string'
        std::string *paypalHdrbackcolor;
        /// Optional element 'ns2:paypalPayflowcolor' of XSD type 'xsd:string'
        std::string *paypalPayflowcolor;
        /// Optional element 'ns2:paypalEcSetRequestID' of XSD type 'xsd:string'
        std::string *paypalEcSetRequestID;
        /// Optional element 'ns2:paypalEcSetRequestToken' of XSD type 'xsd:string'
        std::string *paypalEcSetRequestToken;
        /// Optional element 'ns2:promoCode0' of XSD type 'xsd:string'
        std::string *promoCode0;
        /// Optional element 'ns2:requestBillingAddress' of XSD type 'xsd:string'
        std::string *requestBillingAddress;
        /// Optional element 'ns2:invoiceNumber' of XSD type 'xsd:string'
        std::string *invoiceNumber;
        /// Optional element 'ns2:paypalBillingType' of XSD type 'xsd:string'
        std::string *paypalBillingType;
        /// Optional element 'ns2:paypalBillingAgreementDesc' of XSD type 'xsd:string'
        std::string *paypalBillingAgreementDesc;
        /// Optional element 'ns2:paypalPaymentType' of XSD type 'xsd:string'
        std::string *paypalPaymentType;
        /// Optional element 'ns2:paypalBillingAgreementCustom' of XSD type 'xsd:string'
        std::string *paypalBillingAgreementCustom;
        /// Optional element 'ns2:paypalLogoimg' of XSD type 'xsd:string'
        std::string *paypalLogoimg;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalEcSetService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PayPalEcSetService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalEcSetService, default initialized and not managed by a soap context
        virtual ns2__PayPalEcSetService *soap_alloc(void) const { return SOAP_NEW(ns2__PayPalEcSetService); }
      public:
        /// Constructor with initializations
        ns2__PayPalEcSetService()
        {
          paypalReturn = (std::string *)0;
          paypalCancelReturn = (std::string *)0;
          paypalMaxamt = (std::string *)0;
          paypalCustomerEmail = (std::string *)0;
          paypalDesc = (std::string *)0;
          paypalReqconfirmshipping = (std::string *)0;
          paypalNoshipping = (std::string *)0;
          paypalAddressOverride = (std::string *)0;
          paypalToken = (std::string *)0;
          paypalLc = (std::string *)0;
          paypalPagestyle = (std::string *)0;
          paypalHdrimg = (std::string *)0;
          paypalHdrbordercolor = (std::string *)0;
          paypalHdrbackcolor = (std::string *)0;
          paypalPayflowcolor = (std::string *)0;
          paypalEcSetRequestID = (std::string *)0;
          paypalEcSetRequestToken = (std::string *)0;
          promoCode0 = (std::string *)0;
          requestBillingAddress = (std::string *)0;
          invoiceNumber = (std::string *)0;
          paypalBillingType = (std::string *)0;
          paypalBillingAgreementDesc = (std::string *)0;
          paypalPaymentType = (std::string *)0;
          paypalBillingAgreementCustom = (std::string *)0;
          paypalLogoimg = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PayPalEcSetService() { }
        /// Friend allocator used by soap_new_ns2__PayPalEcSetService(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalEcSetService * SOAP_FMAC2 soap_instantiate_ns2__PayPalEcSetService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:273 */
#ifndef SOAP_TYPE_ns2__PayPalEcGetDetailsService
#define SOAP_TYPE_ns2__PayPalEcGetDetailsService (150)
/* complex XSD type 'ns2:PayPalEcGetDetailsService': */
class SOAP_CMAC ns2__PayPalEcGetDetailsService {
      public:
        /// Optional element 'ns2:paypalToken' of XSD type 'xsd:string'
        std::string *paypalToken;
        /// Optional element 'ns2:paypalEcSetRequestID' of XSD type 'xsd:string'
        std::string *paypalEcSetRequestID;
        /// Optional element 'ns2:paypalEcSetRequestToken' of XSD type 'xsd:string'
        std::string *paypalEcSetRequestToken;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalEcGetDetailsService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PayPalEcGetDetailsService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalEcGetDetailsService, default initialized and not managed by a soap context
        virtual ns2__PayPalEcGetDetailsService *soap_alloc(void) const { return SOAP_NEW(ns2__PayPalEcGetDetailsService); }
      public:
        /// Constructor with initializations
        ns2__PayPalEcGetDetailsService()
        {
          paypalToken = (std::string *)0;
          paypalEcSetRequestID = (std::string *)0;
          paypalEcSetRequestToken = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PayPalEcGetDetailsService() { }
        /// Friend allocator used by soap_new_ns2__PayPalEcGetDetailsService(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalEcGetDetailsService * SOAP_FMAC2 soap_instantiate_ns2__PayPalEcGetDetailsService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:276 */
#ifndef SOAP_TYPE_ns2__PayPalEcDoPaymentService
#define SOAP_TYPE_ns2__PayPalEcDoPaymentService (151)
/* complex XSD type 'ns2:PayPalEcDoPaymentService': */
class SOAP_CMAC ns2__PayPalEcDoPaymentService {
      public:
        /// Optional element 'ns2:paypalToken' of XSD type 'xsd:string'
        std::string *paypalToken;
        /// Optional element 'ns2:paypalPayerId' of XSD type 'xsd:string'
        std::string *paypalPayerId;
        /// Optional element 'ns2:paypalCustomerEmail' of XSD type 'xsd:string'
        std::string *paypalCustomerEmail;
        /// Optional element 'ns2:paypalDesc' of XSD type 'xsd:string'
        std::string *paypalDesc;
        /// Optional element 'ns2:paypalEcSetRequestID' of XSD type 'xsd:string'
        std::string *paypalEcSetRequestID;
        /// Optional element 'ns2:paypalEcSetRequestToken' of XSD type 'xsd:string'
        std::string *paypalEcSetRequestToken;
        /// Optional element 'ns2:promoCode0' of XSD type 'xsd:string'
        std::string *promoCode0;
        /// Optional element 'ns2:invoiceNumber' of XSD type 'xsd:string'
        std::string *invoiceNumber;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalEcDoPaymentService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PayPalEcDoPaymentService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalEcDoPaymentService, default initialized and not managed by a soap context
        virtual ns2__PayPalEcDoPaymentService *soap_alloc(void) const { return SOAP_NEW(ns2__PayPalEcDoPaymentService); }
      public:
        /// Constructor with initializations
        ns2__PayPalEcDoPaymentService()
        {
          paypalToken = (std::string *)0;
          paypalPayerId = (std::string *)0;
          paypalCustomerEmail = (std::string *)0;
          paypalDesc = (std::string *)0;
          paypalEcSetRequestID = (std::string *)0;
          paypalEcSetRequestToken = (std::string *)0;
          promoCode0 = (std::string *)0;
          invoiceNumber = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PayPalEcDoPaymentService() { }
        /// Friend allocator used by soap_new_ns2__PayPalEcDoPaymentService(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalEcDoPaymentService * SOAP_FMAC2 soap_instantiate_ns2__PayPalEcDoPaymentService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:279 */
#ifndef SOAP_TYPE_ns2__PayPalDoCaptureService
#define SOAP_TYPE_ns2__PayPalDoCaptureService (152)
/* complex XSD type 'ns2:PayPalDoCaptureService': */
class SOAP_CMAC ns2__PayPalDoCaptureService {
      public:
        /// Optional element 'ns2:paypalAuthorizationId' of XSD type 'xsd:string'
        std::string *paypalAuthorizationId;
        /// Optional element 'ns2:completeType' of XSD type 'xsd:string'
        std::string *completeType;
        /// Optional element 'ns2:paypalEcDoPaymentRequestID' of XSD type 'xsd:string'
        std::string *paypalEcDoPaymentRequestID;
        /// Optional element 'ns2:paypalEcDoPaymentRequestToken' of XSD type 'xsd:string'
        std::string *paypalEcDoPaymentRequestToken;
        /// Optional element 'ns2:paypalAuthorizationRequestID' of XSD type 'xsd:string'
        std::string *paypalAuthorizationRequestID;
        /// Optional element 'ns2:paypalAuthorizationRequestToken' of XSD type 'xsd:string'
        std::string *paypalAuthorizationRequestToken;
        /// Optional element 'ns2:invoiceNumber' of XSD type 'xsd:string'
        std::string *invoiceNumber;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalDoCaptureService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PayPalDoCaptureService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalDoCaptureService, default initialized and not managed by a soap context
        virtual ns2__PayPalDoCaptureService *soap_alloc(void) const { return SOAP_NEW(ns2__PayPalDoCaptureService); }
      public:
        /// Constructor with initializations
        ns2__PayPalDoCaptureService()
        {
          paypalAuthorizationId = (std::string *)0;
          completeType = (std::string *)0;
          paypalEcDoPaymentRequestID = (std::string *)0;
          paypalEcDoPaymentRequestToken = (std::string *)0;
          paypalAuthorizationRequestID = (std::string *)0;
          paypalAuthorizationRequestToken = (std::string *)0;
          invoiceNumber = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PayPalDoCaptureService() { }
        /// Friend allocator used by soap_new_ns2__PayPalDoCaptureService(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalDoCaptureService * SOAP_FMAC2 soap_instantiate_ns2__PayPalDoCaptureService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:282 */
#ifndef SOAP_TYPE_ns2__PayPalAuthReversalService
#define SOAP_TYPE_ns2__PayPalAuthReversalService (153)
/* complex XSD type 'ns2:PayPalAuthReversalService': */
class SOAP_CMAC ns2__PayPalAuthReversalService {
      public:
        /// Optional element 'ns2:paypalAuthorizationId' of XSD type 'xsd:string'
        std::string *paypalAuthorizationId;
        /// Optional element 'ns2:paypalEcDoPaymentRequestID' of XSD type 'xsd:string'
        std::string *paypalEcDoPaymentRequestID;
        /// Optional element 'ns2:paypalEcDoPaymentRequestToken' of XSD type 'xsd:string'
        std::string *paypalEcDoPaymentRequestToken;
        /// Optional element 'ns2:paypalAuthorizationRequestID' of XSD type 'xsd:string'
        std::string *paypalAuthorizationRequestID;
        /// Optional element 'ns2:paypalAuthorizationRequestToken' of XSD type 'xsd:string'
        std::string *paypalAuthorizationRequestToken;
        /// Optional element 'ns2:paypalEcOrderSetupRequestID' of XSD type 'xsd:string'
        std::string *paypalEcOrderSetupRequestID;
        /// Optional element 'ns2:paypalEcOrderSetupRequestToken' of XSD type 'xsd:string'
        std::string *paypalEcOrderSetupRequestToken;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalAuthReversalService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PayPalAuthReversalService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalAuthReversalService, default initialized and not managed by a soap context
        virtual ns2__PayPalAuthReversalService *soap_alloc(void) const { return SOAP_NEW(ns2__PayPalAuthReversalService); }
      public:
        /// Constructor with initializations
        ns2__PayPalAuthReversalService()
        {
          paypalAuthorizationId = (std::string *)0;
          paypalEcDoPaymentRequestID = (std::string *)0;
          paypalEcDoPaymentRequestToken = (std::string *)0;
          paypalAuthorizationRequestID = (std::string *)0;
          paypalAuthorizationRequestToken = (std::string *)0;
          paypalEcOrderSetupRequestID = (std::string *)0;
          paypalEcOrderSetupRequestToken = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PayPalAuthReversalService() { }
        /// Friend allocator used by soap_new_ns2__PayPalAuthReversalService(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalAuthReversalService * SOAP_FMAC2 soap_instantiate_ns2__PayPalAuthReversalService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:285 */
#ifndef SOAP_TYPE_ns2__PayPalRefundService
#define SOAP_TYPE_ns2__PayPalRefundService (154)
/* complex XSD type 'ns2:PayPalRefundService': */
class SOAP_CMAC ns2__PayPalRefundService {
      public:
        /// Optional element 'ns2:paypalDoCaptureRequestID' of XSD type 'xsd:string'
        std::string *paypalDoCaptureRequestID;
        /// Optional element 'ns2:paypalDoCaptureRequestToken' of XSD type 'xsd:string'
        std::string *paypalDoCaptureRequestToken;
        /// Optional element 'ns2:paypalCaptureId' of XSD type 'xsd:string'
        std::string *paypalCaptureId;
        /// Optional element 'ns2:paypalNote' of XSD type 'xsd:string'
        std::string *paypalNote;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalRefundService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PayPalRefundService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalRefundService, default initialized and not managed by a soap context
        virtual ns2__PayPalRefundService *soap_alloc(void) const { return SOAP_NEW(ns2__PayPalRefundService); }
      public:
        /// Constructor with initializations
        ns2__PayPalRefundService()
        {
          paypalDoCaptureRequestID = (std::string *)0;
          paypalDoCaptureRequestToken = (std::string *)0;
          paypalCaptureId = (std::string *)0;
          paypalNote = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PayPalRefundService() { }
        /// Friend allocator used by soap_new_ns2__PayPalRefundService(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalRefundService * SOAP_FMAC2 soap_instantiate_ns2__PayPalRefundService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:288 */
#ifndef SOAP_TYPE_ns2__PayPalEcOrderSetupService
#define SOAP_TYPE_ns2__PayPalEcOrderSetupService (155)
/* complex XSD type 'ns2:PayPalEcOrderSetupService': */
class SOAP_CMAC ns2__PayPalEcOrderSetupService {
      public:
        /// Optional element 'ns2:paypalToken' of XSD type 'xsd:string'
        std::string *paypalToken;
        /// Optional element 'ns2:paypalPayerId' of XSD type 'xsd:string'
        std::string *paypalPayerId;
        /// Optional element 'ns2:paypalCustomerEmail' of XSD type 'xsd:string'
        std::string *paypalCustomerEmail;
        /// Optional element 'ns2:paypalDesc' of XSD type 'xsd:string'
        std::string *paypalDesc;
        /// Optional element 'ns2:paypalEcSetRequestID' of XSD type 'xsd:string'
        std::string *paypalEcSetRequestID;
        /// Optional element 'ns2:paypalEcSetRequestToken' of XSD type 'xsd:string'
        std::string *paypalEcSetRequestToken;
        /// Optional element 'ns2:promoCode0' of XSD type 'xsd:string'
        std::string *promoCode0;
        /// Optional element 'ns2:invoiceNumber' of XSD type 'xsd:string'
        std::string *invoiceNumber;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalEcOrderSetupService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PayPalEcOrderSetupService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalEcOrderSetupService, default initialized and not managed by a soap context
        virtual ns2__PayPalEcOrderSetupService *soap_alloc(void) const { return SOAP_NEW(ns2__PayPalEcOrderSetupService); }
      public:
        /// Constructor with initializations
        ns2__PayPalEcOrderSetupService()
        {
          paypalToken = (std::string *)0;
          paypalPayerId = (std::string *)0;
          paypalCustomerEmail = (std::string *)0;
          paypalDesc = (std::string *)0;
          paypalEcSetRequestID = (std::string *)0;
          paypalEcSetRequestToken = (std::string *)0;
          promoCode0 = (std::string *)0;
          invoiceNumber = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PayPalEcOrderSetupService() { }
        /// Friend allocator used by soap_new_ns2__PayPalEcOrderSetupService(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalEcOrderSetupService * SOAP_FMAC2 soap_instantiate_ns2__PayPalEcOrderSetupService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:291 */
#ifndef SOAP_TYPE_ns2__PayPalAuthorizationService
#define SOAP_TYPE_ns2__PayPalAuthorizationService (156)
/* complex XSD type 'ns2:PayPalAuthorizationService': */
class SOAP_CMAC ns2__PayPalAuthorizationService {
      public:
        /// Optional element 'ns2:paypalOrderId' of XSD type 'xsd:string'
        std::string *paypalOrderId;
        /// Optional element 'ns2:paypalEcOrderSetupRequestID' of XSD type 'xsd:string'
        std::string *paypalEcOrderSetupRequestID;
        /// Optional element 'ns2:paypalEcOrderSetupRequestToken' of XSD type 'xsd:string'
        std::string *paypalEcOrderSetupRequestToken;
        /// Optional element 'ns2:paypalDoRefTransactionRequestID' of XSD type 'xsd:string'
        std::string *paypalDoRefTransactionRequestID;
        /// Optional element 'ns2:paypalDoRefTransactionRequestToken' of XSD type 'xsd:string'
        std::string *paypalDoRefTransactionRequestToken;
        /// Optional element 'ns2:paypalCustomerEmail' of XSD type 'xsd:string'
        std::string *paypalCustomerEmail;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalAuthorizationService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PayPalAuthorizationService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalAuthorizationService, default initialized and not managed by a soap context
        virtual ns2__PayPalAuthorizationService *soap_alloc(void) const { return SOAP_NEW(ns2__PayPalAuthorizationService); }
      public:
        /// Constructor with initializations
        ns2__PayPalAuthorizationService()
        {
          paypalOrderId = (std::string *)0;
          paypalEcOrderSetupRequestID = (std::string *)0;
          paypalEcOrderSetupRequestToken = (std::string *)0;
          paypalDoRefTransactionRequestID = (std::string *)0;
          paypalDoRefTransactionRequestToken = (std::string *)0;
          paypalCustomerEmail = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PayPalAuthorizationService() { }
        /// Friend allocator used by soap_new_ns2__PayPalAuthorizationService(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalAuthorizationService * SOAP_FMAC2 soap_instantiate_ns2__PayPalAuthorizationService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:294 */
#ifndef SOAP_TYPE_ns2__PayPalUpdateAgreementService
#define SOAP_TYPE_ns2__PayPalUpdateAgreementService (157)
/* complex XSD type 'ns2:PayPalUpdateAgreementService': */
class SOAP_CMAC ns2__PayPalUpdateAgreementService {
      public:
        /// Optional element 'ns2:paypalBillingAgreementId' of XSD type 'xsd:string'
        std::string *paypalBillingAgreementId;
        /// Optional element 'ns2:paypalBillingAgreementStatus' of XSD type 'xsd:string'
        std::string *paypalBillingAgreementStatus;
        /// Optional element 'ns2:paypalBillingAgreementDesc' of XSD type 'xsd:string'
        std::string *paypalBillingAgreementDesc;
        /// Optional element 'ns2:paypalBillingAgreementCustom' of XSD type 'xsd:string'
        std::string *paypalBillingAgreementCustom;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalUpdateAgreementService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PayPalUpdateAgreementService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalUpdateAgreementService, default initialized and not managed by a soap context
        virtual ns2__PayPalUpdateAgreementService *soap_alloc(void) const { return SOAP_NEW(ns2__PayPalUpdateAgreementService); }
      public:
        /// Constructor with initializations
        ns2__PayPalUpdateAgreementService()
        {
          paypalBillingAgreementId = (std::string *)0;
          paypalBillingAgreementStatus = (std::string *)0;
          paypalBillingAgreementDesc = (std::string *)0;
          paypalBillingAgreementCustom = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PayPalUpdateAgreementService() { }
        /// Friend allocator used by soap_new_ns2__PayPalUpdateAgreementService(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalUpdateAgreementService * SOAP_FMAC2 soap_instantiate_ns2__PayPalUpdateAgreementService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:297 */
#ifndef SOAP_TYPE_ns2__PayPalCreateAgreementService
#define SOAP_TYPE_ns2__PayPalCreateAgreementService (158)
/* complex XSD type 'ns2:PayPalCreateAgreementService': */
class SOAP_CMAC ns2__PayPalCreateAgreementService {
      public:
        /// Optional element 'ns2:paypalToken' of XSD type 'xsd:string'
        std::string *paypalToken;
        /// Optional element 'ns2:paypalEcSetRequestID' of XSD type 'xsd:string'
        std::string *paypalEcSetRequestID;
        /// Optional element 'ns2:paypalEcSetRequestToken' of XSD type 'xsd:string'
        std::string *paypalEcSetRequestToken;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalCreateAgreementService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PayPalCreateAgreementService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalCreateAgreementService, default initialized and not managed by a soap context
        virtual ns2__PayPalCreateAgreementService *soap_alloc(void) const { return SOAP_NEW(ns2__PayPalCreateAgreementService); }
      public:
        /// Constructor with initializations
        ns2__PayPalCreateAgreementService()
        {
          paypalToken = (std::string *)0;
          paypalEcSetRequestID = (std::string *)0;
          paypalEcSetRequestToken = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PayPalCreateAgreementService() { }
        /// Friend allocator used by soap_new_ns2__PayPalCreateAgreementService(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalCreateAgreementService * SOAP_FMAC2 soap_instantiate_ns2__PayPalCreateAgreementService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:300 */
#ifndef SOAP_TYPE_ns2__PayPalDoRefTransactionService
#define SOAP_TYPE_ns2__PayPalDoRefTransactionService (159)
/* complex XSD type 'ns2:PayPalDoRefTransactionService': */
class SOAP_CMAC ns2__PayPalDoRefTransactionService {
      public:
        /// Optional element 'ns2:paypalBillingAgreementId' of XSD type 'xsd:string'
        std::string *paypalBillingAgreementId;
        /// Optional element 'ns2:paypalPaymentType' of XSD type 'xsd:string'
        std::string *paypalPaymentType;
        /// Optional element 'ns2:paypalReqconfirmshipping' of XSD type 'xsd:string'
        std::string *paypalReqconfirmshipping;
        /// Optional element 'ns2:paypalReturnFmfDetails' of XSD type 'xsd:string'
        std::string *paypalReturnFmfDetails;
        /// Optional element 'ns2:paypalSoftDescriptor' of XSD type 'xsd:string'
        std::string *paypalSoftDescriptor;
        /// Optional element 'ns2:paypalShippingdiscount' of XSD type 'xsd:string'
        std::string *paypalShippingdiscount;
        /// Optional element 'ns2:paypalDesc' of XSD type 'xsd:string'
        std::string *paypalDesc;
        /// Optional element 'ns2:invoiceNumber' of XSD type 'xsd:string'
        std::string *invoiceNumber;
        /// Optional element 'ns2:paypalEcNotifyUrl' of XSD type 'xsd:string'
        std::string *paypalEcNotifyUrl;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalDoRefTransactionService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PayPalDoRefTransactionService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalDoRefTransactionService, default initialized and not managed by a soap context
        virtual ns2__PayPalDoRefTransactionService *soap_alloc(void) const { return SOAP_NEW(ns2__PayPalDoRefTransactionService); }
      public:
        /// Constructor with initializations
        ns2__PayPalDoRefTransactionService()
        {
          paypalBillingAgreementId = (std::string *)0;
          paypalPaymentType = (std::string *)0;
          paypalReqconfirmshipping = (std::string *)0;
          paypalReturnFmfDetails = (std::string *)0;
          paypalSoftDescriptor = (std::string *)0;
          paypalShippingdiscount = (std::string *)0;
          paypalDesc = (std::string *)0;
          invoiceNumber = (std::string *)0;
          paypalEcNotifyUrl = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PayPalDoRefTransactionService() { }
        /// Friend allocator used by soap_new_ns2__PayPalDoRefTransactionService(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalDoRefTransactionService * SOAP_FMAC2 soap_instantiate_ns2__PayPalDoRefTransactionService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:303 */
#ifndef SOAP_TYPE_ns2__VoidService
#define SOAP_TYPE_ns2__VoidService (160)
/* complex XSD type 'ns2:VoidService': */
class SOAP_CMAC ns2__VoidService {
      public:
        /// Optional element 'ns2:voidRequestID' of XSD type 'xsd:string'
        std::string *voidRequestID;
        /// Optional element 'ns2:voidRequestToken' of XSD type 'xsd:string'
        std::string *voidRequestToken;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__VoidService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__VoidService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__VoidService, default initialized and not managed by a soap context
        virtual ns2__VoidService *soap_alloc(void) const { return SOAP_NEW(ns2__VoidService); }
      public:
        /// Constructor with initializations
        ns2__VoidService()
        {
          voidRequestID = (std::string *)0;
          voidRequestToken = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__VoidService() { }
        /// Friend allocator used by soap_new_ns2__VoidService(struct soap*, int)
        friend SOAP_FMAC1 ns2__VoidService * SOAP_FMAC2 soap_instantiate_ns2__VoidService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:306 */
#ifndef SOAP_TYPE_ns2__PinlessDebitService
#define SOAP_TYPE_ns2__PinlessDebitService (161)
/* complex XSD type 'ns2:PinlessDebitService': */
class SOAP_CMAC ns2__PinlessDebitService {
      public:
        /// Optional element 'ns2:reconciliationID' of XSD type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:commerceIndicator' of XSD type 'xsd:string'
        std::string *commerceIndicator;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PinlessDebitService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PinlessDebitService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PinlessDebitService, default initialized and not managed by a soap context
        virtual ns2__PinlessDebitService *soap_alloc(void) const { return SOAP_NEW(ns2__PinlessDebitService); }
      public:
        /// Constructor with initializations
        ns2__PinlessDebitService()
        {
          reconciliationID = (std::string *)0;
          commerceIndicator = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PinlessDebitService() { }
        /// Friend allocator used by soap_new_ns2__PinlessDebitService(struct soap*, int)
        friend SOAP_FMAC1 ns2__PinlessDebitService * SOAP_FMAC2 soap_instantiate_ns2__PinlessDebitService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:309 */
#ifndef SOAP_TYPE_ns2__PinlessDebitValidateService
#define SOAP_TYPE_ns2__PinlessDebitValidateService (162)
/* complex XSD type 'ns2:PinlessDebitValidateService': */
class SOAP_CMAC ns2__PinlessDebitValidateService {
      public:
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PinlessDebitValidateService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PinlessDebitValidateService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PinlessDebitValidateService, default initialized and not managed by a soap context
        virtual ns2__PinlessDebitValidateService *soap_alloc(void) const { return SOAP_NEW(ns2__PinlessDebitValidateService); }
      public:
        /// Constructor with initializations
        ns2__PinlessDebitValidateService()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__PinlessDebitValidateService() { }
        /// Friend allocator used by soap_new_ns2__PinlessDebitValidateService(struct soap*, int)
        friend SOAP_FMAC1 ns2__PinlessDebitValidateService * SOAP_FMAC2 soap_instantiate_ns2__PinlessDebitValidateService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:312 */
#ifndef SOAP_TYPE_ns2__PinlessDebitReversalService
#define SOAP_TYPE_ns2__PinlessDebitReversalService (163)
/* complex XSD type 'ns2:PinlessDebitReversalService': */
class SOAP_CMAC ns2__PinlessDebitReversalService {
      public:
        /// Optional element 'ns2:pinlessDebitRequestID' of XSD type 'xsd:string'
        std::string *pinlessDebitRequestID;
        /// Optional element 'ns2:pinlessDebitRequestToken' of XSD type 'xsd:string'
        std::string *pinlessDebitRequestToken;
        /// Optional element 'ns2:reconciliationID' of XSD type 'xsd:string'
        std::string *reconciliationID;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PinlessDebitReversalService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PinlessDebitReversalService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PinlessDebitReversalService, default initialized and not managed by a soap context
        virtual ns2__PinlessDebitReversalService *soap_alloc(void) const { return SOAP_NEW(ns2__PinlessDebitReversalService); }
      public:
        /// Constructor with initializations
        ns2__PinlessDebitReversalService()
        {
          pinlessDebitRequestID = (std::string *)0;
          pinlessDebitRequestToken = (std::string *)0;
          reconciliationID = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PinlessDebitReversalService() { }
        /// Friend allocator used by soap_new_ns2__PinlessDebitReversalService(struct soap*, int)
        friend SOAP_FMAC1 ns2__PinlessDebitReversalService * SOAP_FMAC2 soap_instantiate_ns2__PinlessDebitReversalService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:315 */
#ifndef SOAP_TYPE_ns2__PinDebitPurchaseService
#define SOAP_TYPE_ns2__PinDebitPurchaseService (164)
/* complex XSD type 'ns2:PinDebitPurchaseService': */
class SOAP_CMAC ns2__PinDebitPurchaseService {
      public:
        /// Optional element 'ns2:networkOrder' of XSD type 'xsd:string'
        std::string *networkOrder;
        /// Optional element 'ns2:commerceIndicator' of XSD type 'xsd:string'
        std::string *commerceIndicator;
        /// Optional element 'ns2:reconciliationID' of XSD type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:partialAuthIndicator' of XSD type 'ns2:boolean'
        std::string *partialAuthIndicator;
        /// Optional element 'ns2:overridePaymentMethod' of XSD type 'xsd:string'
        std::string *overridePaymentMethod;
        /// Optional element 'ns2:paymentType' of XSD type 'xsd:string'
        std::string *paymentType;
        /// Optional element 'ns2:ebtCategory' of XSD type 'xsd:string'
        std::string *ebtCategory;
        /// Optional element 'ns2:transactionType' of XSD type 'xsd:string'
        std::string *transactionType;
        /// Optional element 'ns2:ebtVoucherSerialNumber' of XSD type 'xsd:string'
        std::string *ebtVoucherSerialNumber;
        /// Optional element 'ns2:authorizationCode' of XSD type 'xsd:string'
        std::string *authorizationCode;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PinDebitPurchaseService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PinDebitPurchaseService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PinDebitPurchaseService, default initialized and not managed by a soap context
        virtual ns2__PinDebitPurchaseService *soap_alloc(void) const { return SOAP_NEW(ns2__PinDebitPurchaseService); }
      public:
        /// Constructor with initializations
        ns2__PinDebitPurchaseService()
        {
          networkOrder = (std::string *)0;
          commerceIndicator = (std::string *)0;
          reconciliationID = (std::string *)0;
          partialAuthIndicator = (std::string *)0;
          overridePaymentMethod = (std::string *)0;
          paymentType = (std::string *)0;
          ebtCategory = (std::string *)0;
          transactionType = (std::string *)0;
          ebtVoucherSerialNumber = (std::string *)0;
          authorizationCode = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PinDebitPurchaseService() { }
        /// Friend allocator used by soap_new_ns2__PinDebitPurchaseService(struct soap*, int)
        friend SOAP_FMAC1 ns2__PinDebitPurchaseService * SOAP_FMAC2 soap_instantiate_ns2__PinDebitPurchaseService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:318 */
#ifndef SOAP_TYPE_ns2__PinDebitCreditService
#define SOAP_TYPE_ns2__PinDebitCreditService (165)
/* complex XSD type 'ns2:PinDebitCreditService': */
class SOAP_CMAC ns2__PinDebitCreditService {
      public:
        /// Optional element 'ns2:networkOrder' of XSD type 'xsd:string'
        std::string *networkOrder;
        /// Optional element 'ns2:commerceIndicator' of XSD type 'xsd:string'
        std::string *commerceIndicator;
        /// Optional element 'ns2:reconciliationID' of XSD type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:overridePaymentMethod' of XSD type 'xsd:string'
        std::string *overridePaymentMethod;
        /// Optional element 'ns2:paymentType' of XSD type 'xsd:string'
        std::string *paymentType;
        /// Optional element 'ns2:ebtCategory' of XSD type 'xsd:string'
        std::string *ebtCategory;
        /// Optional element 'ns2:transactionType' of XSD type 'xsd:string'
        std::string *transactionType;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PinDebitCreditService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PinDebitCreditService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PinDebitCreditService, default initialized and not managed by a soap context
        virtual ns2__PinDebitCreditService *soap_alloc(void) const { return SOAP_NEW(ns2__PinDebitCreditService); }
      public:
        /// Constructor with initializations
        ns2__PinDebitCreditService()
        {
          networkOrder = (std::string *)0;
          commerceIndicator = (std::string *)0;
          reconciliationID = (std::string *)0;
          overridePaymentMethod = (std::string *)0;
          paymentType = (std::string *)0;
          ebtCategory = (std::string *)0;
          transactionType = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PinDebitCreditService() { }
        /// Friend allocator used by soap_new_ns2__PinDebitCreditService(struct soap*, int)
        friend SOAP_FMAC1 ns2__PinDebitCreditService * SOAP_FMAC2 soap_instantiate_ns2__PinDebitCreditService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:321 */
#ifndef SOAP_TYPE_ns2__PinDebitReversalService
#define SOAP_TYPE_ns2__PinDebitReversalService (166)
/* complex XSD type 'ns2:PinDebitReversalService': */
class SOAP_CMAC ns2__PinDebitReversalService {
      public:
        /// Optional element 'ns2:pinDebitRequestID' of XSD type 'xsd:string'
        std::string *pinDebitRequestID;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PinDebitReversalService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PinDebitReversalService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PinDebitReversalService, default initialized and not managed by a soap context
        virtual ns2__PinDebitReversalService *soap_alloc(void) const { return SOAP_NEW(ns2__PinDebitReversalService); }
      public:
        /// Constructor with initializations
        ns2__PinDebitReversalService()
        {
          pinDebitRequestID = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PinDebitReversalService() { }
        /// Friend allocator used by soap_new_ns2__PinDebitReversalService(struct soap*, int)
        friend SOAP_FMAC1 ns2__PinDebitReversalService * SOAP_FMAC2 soap_instantiate_ns2__PinDebitReversalService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:324 */
#ifndef SOAP_TYPE_ns2__PayPalButtonCreateService
#define SOAP_TYPE_ns2__PayPalButtonCreateService (167)
/* complex XSD type 'ns2:PayPalButtonCreateService': */
class SOAP_CMAC ns2__PayPalButtonCreateService {
      public:
        /// Optional element 'ns2:buttonType' of XSD type 'xsd:string'
        std::string *buttonType;
        /// Optional element 'ns2:reconciliationID' of XSD type 'xsd:string'
        std::string *reconciliationID;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalButtonCreateService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PayPalButtonCreateService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalButtonCreateService, default initialized and not managed by a soap context
        virtual ns2__PayPalButtonCreateService *soap_alloc(void) const { return SOAP_NEW(ns2__PayPalButtonCreateService); }
      public:
        /// Constructor with initializations
        ns2__PayPalButtonCreateService()
        {
          buttonType = (std::string *)0;
          reconciliationID = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PayPalButtonCreateService() { }
        /// Friend allocator used by soap_new_ns2__PayPalButtonCreateService(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalButtonCreateService * SOAP_FMAC2 soap_instantiate_ns2__PayPalButtonCreateService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:327 */
#ifndef SOAP_TYPE_ns2__PayPalPreapprovedPaymentService
#define SOAP_TYPE_ns2__PayPalPreapprovedPaymentService (168)
/* complex XSD type 'ns2:PayPalPreapprovedPaymentService': */
class SOAP_CMAC ns2__PayPalPreapprovedPaymentService {
      public:
        /// Optional element 'ns2:mpID' of XSD type 'xsd:string'
        std::string *mpID;
        /// Optional element 'ns2:reconciliationID' of XSD type 'xsd:string'
        std::string *reconciliationID;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalPreapprovedPaymentService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PayPalPreapprovedPaymentService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalPreapprovedPaymentService, default initialized and not managed by a soap context
        virtual ns2__PayPalPreapprovedPaymentService *soap_alloc(void) const { return SOAP_NEW(ns2__PayPalPreapprovedPaymentService); }
      public:
        /// Constructor with initializations
        ns2__PayPalPreapprovedPaymentService()
        {
          mpID = (std::string *)0;
          reconciliationID = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PayPalPreapprovedPaymentService() { }
        /// Friend allocator used by soap_new_ns2__PayPalPreapprovedPaymentService(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalPreapprovedPaymentService * SOAP_FMAC2 soap_instantiate_ns2__PayPalPreapprovedPaymentService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:330 */
#ifndef SOAP_TYPE_ns2__PayPalPreapprovedUpdateService
#define SOAP_TYPE_ns2__PayPalPreapprovedUpdateService (169)
/* complex XSD type 'ns2:PayPalPreapprovedUpdateService': */
class SOAP_CMAC ns2__PayPalPreapprovedUpdateService {
      public:
        /// Optional element 'ns2:mpID' of XSD type 'xsd:string'
        std::string *mpID;
        /// Optional element 'ns2:reconciliationID' of XSD type 'xsd:string'
        std::string *reconciliationID;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalPreapprovedUpdateService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PayPalPreapprovedUpdateService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalPreapprovedUpdateService, default initialized and not managed by a soap context
        virtual ns2__PayPalPreapprovedUpdateService *soap_alloc(void) const { return SOAP_NEW(ns2__PayPalPreapprovedUpdateService); }
      public:
        /// Constructor with initializations
        ns2__PayPalPreapprovedUpdateService()
        {
          mpID = (std::string *)0;
          reconciliationID = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PayPalPreapprovedUpdateService() { }
        /// Friend allocator used by soap_new_ns2__PayPalPreapprovedUpdateService(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalPreapprovedUpdateService * SOAP_FMAC2 soap_instantiate_ns2__PayPalPreapprovedUpdateService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:333 */
#ifndef SOAP_TYPE_ns2__ChinaPaymentService
#define SOAP_TYPE_ns2__ChinaPaymentService (170)
/* complex XSD type 'ns2:ChinaPaymentService': */
class SOAP_CMAC ns2__ChinaPaymentService {
      public:
        /// Optional element 'ns2:paymentMode' of XSD type 'xsd:string'
        std::string *paymentMode;
        /// Optional element 'ns2:returnURL' of XSD type 'xsd:string'
        std::string *returnURL;
        /// Optional element 'ns2:pickUpAddress' of XSD type 'xsd:string'
        std::string *pickUpAddress;
        /// Optional element 'ns2:pickUpPhoneNumber' of XSD type 'xsd:string'
        std::string *pickUpPhoneNumber;
        /// Optional element 'ns2:pickUpPostalCode' of XSD type 'xsd:string'
        std::string *pickUpPostalCode;
        /// Optional element 'ns2:pickUpName' of XSD type 'xsd:string'
        std::string *pickUpName;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ChinaPaymentService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ChinaPaymentService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ChinaPaymentService, default initialized and not managed by a soap context
        virtual ns2__ChinaPaymentService *soap_alloc(void) const { return SOAP_NEW(ns2__ChinaPaymentService); }
      public:
        /// Constructor with initializations
        ns2__ChinaPaymentService()
        {
          paymentMode = (std::string *)0;
          returnURL = (std::string *)0;
          pickUpAddress = (std::string *)0;
          pickUpPhoneNumber = (std::string *)0;
          pickUpPostalCode = (std::string *)0;
          pickUpName = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__ChinaPaymentService() { }
        /// Friend allocator used by soap_new_ns2__ChinaPaymentService(struct soap*, int)
        friend SOAP_FMAC1 ns2__ChinaPaymentService * SOAP_FMAC2 soap_instantiate_ns2__ChinaPaymentService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:336 */
#ifndef SOAP_TYPE_ns2__ChinaRefundService
#define SOAP_TYPE_ns2__ChinaRefundService (171)
/* complex XSD type 'ns2:ChinaRefundService': */
class SOAP_CMAC ns2__ChinaRefundService {
      public:
        /// Optional element 'ns2:chinaPaymentRequestID' of XSD type 'xsd:string'
        std::string *chinaPaymentRequestID;
        /// Optional element 'ns2:chinaPaymentRequestToken' of XSD type 'xsd:string'
        std::string *chinaPaymentRequestToken;
        /// Optional element 'ns2:refundReason' of XSD type 'xsd:string'
        std::string *refundReason;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ChinaRefundService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ChinaRefundService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ChinaRefundService, default initialized and not managed by a soap context
        virtual ns2__ChinaRefundService *soap_alloc(void) const { return SOAP_NEW(ns2__ChinaRefundService); }
      public:
        /// Constructor with initializations
        ns2__ChinaRefundService()
        {
          chinaPaymentRequestID = (std::string *)0;
          chinaPaymentRequestToken = (std::string *)0;
          refundReason = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__ChinaRefundService() { }
        /// Friend allocator used by soap_new_ns2__ChinaRefundService(struct soap*, int)
        friend SOAP_FMAC1 ns2__ChinaRefundService * SOAP_FMAC2 soap_instantiate_ns2__ChinaRefundService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:339 */
#ifndef SOAP_TYPE_ns2__BoletoPaymentService
#define SOAP_TYPE_ns2__BoletoPaymentService (172)
/* complex XSD type 'ns2:BoletoPaymentService': */
class SOAP_CMAC ns2__BoletoPaymentService {
      public:
        /// Optional element 'ns2:instruction' of XSD type 'xsd:string'
        std::string *instruction;
        /// Optional element 'ns2:expirationDate' of XSD type 'xsd:string'
        std::string *expirationDate;
        /// Optional element 'ns2:reconciliationID' of XSD type 'xsd:string'
        std::string *reconciliationID;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__BoletoPaymentService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__BoletoPaymentService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__BoletoPaymentService, default initialized and not managed by a soap context
        virtual ns2__BoletoPaymentService *soap_alloc(void) const { return SOAP_NEW(ns2__BoletoPaymentService); }
      public:
        /// Constructor with initializations
        ns2__BoletoPaymentService()
        {
          instruction = (std::string *)0;
          expirationDate = (std::string *)0;
          reconciliationID = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__BoletoPaymentService() { }
        /// Friend allocator used by soap_new_ns2__BoletoPaymentService(struct soap*, int)
        friend SOAP_FMAC1 ns2__BoletoPaymentService * SOAP_FMAC2 soap_instantiate_ns2__BoletoPaymentService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:342 */
#ifndef SOAP_TYPE_ns2__PersonalId
#define SOAP_TYPE_ns2__PersonalId (173)
/* complex XSD type 'ns2:PersonalId': */
class SOAP_CMAC ns2__PersonalId {
      public:
        /// Optional element 'ns2:number' of XSD type 'xsd:string'
        std::string *number;
        /// Optional element 'ns2:type' of XSD type 'xsd:string'
        std::string *type;
        /// Optional element 'ns2:name' of XSD type 'xsd:string'
        std::string *name;
        /// Optional element 'ns2:country' of XSD type 'xsd:string'
        std::string *country;
        /// Optional element 'ns2:address' of XSD type 'xsd:string'
        std::string *address;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PersonalId
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PersonalId; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PersonalId, default initialized and not managed by a soap context
        virtual ns2__PersonalId *soap_alloc(void) const { return SOAP_NEW(ns2__PersonalId); }
      public:
        /// Constructor with initializations
        ns2__PersonalId()
        {
          number = (std::string *)0;
          type = (std::string *)0;
          name = (std::string *)0;
          country = (std::string *)0;
          address = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PersonalId() { }
        /// Friend allocator used by soap_new_ns2__PersonalId(struct soap*, int)
        friend SOAP_FMAC1 ns2__PersonalId * SOAP_FMAC2 soap_instantiate_ns2__PersonalId(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:345 */
#ifndef SOAP_TYPE_ns2__Address
#define SOAP_TYPE_ns2__Address (174)
/* complex XSD type 'ns2:Address': */
class SOAP_CMAC ns2__Address {
      public:
        /// Optional element 'ns2:street1' of XSD type 'xsd:string'
        std::string *street1;
        /// Optional element 'ns2:street2' of XSD type 'xsd:string'
        std::string *street2;
        /// Optional element 'ns2:city' of XSD type 'xsd:string'
        std::string *city;
        /// Optional element 'ns2:state' of XSD type 'xsd:string'
        std::string *state;
        /// Optional element 'ns2:postalCode' of XSD type 'xsd:string'
        std::string *postalCode;
        /// Optional element 'ns2:country' of XSD type 'xsd:string'
        std::string *country;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Address
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__Address; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Address, default initialized and not managed by a soap context
        virtual ns2__Address *soap_alloc(void) const { return SOAP_NEW(ns2__Address); }
      public:
        /// Constructor with initializations
        ns2__Address()
        {
          street1 = (std::string *)0;
          street2 = (std::string *)0;
          city = (std::string *)0;
          state = (std::string *)0;
          postalCode = (std::string *)0;
          country = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__Address() { }
        /// Friend allocator used by soap_new_ns2__Address(struct soap*, int)
        friend SOAP_FMAC1 ns2__Address * SOAP_FMAC2 soap_instantiate_ns2__Address(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:348 */
#ifndef SOAP_TYPE_ns2__APInitiateService
#define SOAP_TYPE_ns2__APInitiateService (175)
/* complex XSD type 'ns2:APInitiateService': */
class SOAP_CMAC ns2__APInitiateService {
      public:
        /// Optional element 'ns2:returnURL' of XSD type 'xsd:string'
        std::string *returnURL;
        /// Optional element 'ns2:productName' of XSD type 'xsd:string'
        std::string *productName;
        /// Optional element 'ns2:productDescription' of XSD type 'xsd:string'
        std::string *productDescription;
        /// Optional element 'ns2:reconciliationID' of XSD type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:bankID' of XSD type 'xsd:string'
        std::string *bankID;
        /// Optional element 'ns2:countryCode' of XSD type 'xsd:string'
        std::string *countryCode;
        /// Optional element 'ns2:escrowAgreement' of XSD type 'xsd:string'
        std::string *escrowAgreement;
        /// Optional element 'ns2:languageInterface' of XSD type 'xsd:string'
        std::string *languageInterface;
        /// Optional element 'ns2:intent' of XSD type 'xsd:string'
        std::string *intent;
        /// Optional element 'ns2:successURL' of XSD type 'xsd:string'
        std::string *successURL;
        /// Optional element 'ns2:cancelURL' of XSD type 'xsd:string'
        std::string *cancelURL;
        /// Optional element 'ns2:failureURL' of XSD type 'xsd:string'
        std::string *failureURL;
        /// Optional element 'ns2:overridePaymentMethod' of XSD type 'xsd:string'
        std::string *overridePaymentMethod;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__APInitiateService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__APInitiateService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__APInitiateService, default initialized and not managed by a soap context
        virtual ns2__APInitiateService *soap_alloc(void) const { return SOAP_NEW(ns2__APInitiateService); }
      public:
        /// Constructor with initializations
        ns2__APInitiateService()
        {
          returnURL = (std::string *)0;
          productName = (std::string *)0;
          productDescription = (std::string *)0;
          reconciliationID = (std::string *)0;
          bankID = (std::string *)0;
          countryCode = (std::string *)0;
          escrowAgreement = (std::string *)0;
          languageInterface = (std::string *)0;
          intent = (std::string *)0;
          successURL = (std::string *)0;
          cancelURL = (std::string *)0;
          failureURL = (std::string *)0;
          overridePaymentMethod = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__APInitiateService() { }
        /// Friend allocator used by soap_new_ns2__APInitiateService(struct soap*, int)
        friend SOAP_FMAC1 ns2__APInitiateService * SOAP_FMAC2 soap_instantiate_ns2__APInitiateService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:351 */
#ifndef SOAP_TYPE_ns2__APCheckStatusService
#define SOAP_TYPE_ns2__APCheckStatusService (176)
/* complex XSD type 'ns2:APCheckStatusService': */
class SOAP_CMAC ns2__APCheckStatusService {
      public:
        /// Optional element 'ns2:apInitiateRequestID' of XSD type 'xsd:string'
        std::string *apInitiateRequestID;
        /// Optional element 'ns2:reconciliationID' of XSD type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:checkStatusRequestID' of XSD type 'xsd:string'
        std::string *checkStatusRequestID;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__APCheckStatusService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__APCheckStatusService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__APCheckStatusService, default initialized and not managed by a soap context
        virtual ns2__APCheckStatusService *soap_alloc(void) const { return SOAP_NEW(ns2__APCheckStatusService); }
      public:
        /// Constructor with initializations
        ns2__APCheckStatusService()
        {
          apInitiateRequestID = (std::string *)0;
          reconciliationID = (std::string *)0;
          checkStatusRequestID = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__APCheckStatusService() { }
        /// Friend allocator used by soap_new_ns2__APCheckStatusService(struct soap*, int)
        friend SOAP_FMAC1 ns2__APCheckStatusService * SOAP_FMAC2 soap_instantiate_ns2__APCheckStatusService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:354 */
#ifndef SOAP_TYPE_ns2__RiskUpdateService
#define SOAP_TYPE_ns2__RiskUpdateService (177)
/* complex XSD type 'ns2:RiskUpdateService': */
class SOAP_CMAC ns2__RiskUpdateService {
      public:
        /// Optional element 'ns2:actionCode' of XSD type 'xsd:string'
        std::string *actionCode;
        /// Optional element 'ns2:recordID' of XSD type 'xsd:string'
        std::string *recordID;
        /// Optional element 'ns2:recordName' of XSD type 'xsd:string'
        std::string *recordName;
        /// Optional element 'ns2:negativeAddress' of XSD type 'ns2:Address'
        ns2__Address *negativeAddress;
        /// Optional element 'ns2:markingReason' of XSD type 'xsd:string'
        std::string *markingReason;
        /// Optional element 'ns2:markingNotes' of XSD type 'xsd:string'
        std::string *markingNotes;
        /// Optional element 'ns2:markingRequestID' of XSD type 'xsd:string'
        std::string *markingRequestID;
        /// Optional element 'ns2:deviceFingerprintSmartID' of XSD type 'xsd:string'
        std::string *deviceFingerprintSmartID;
        /// Optional element 'ns2:deviceFingerprintTrueIPAddress' of XSD type 'xsd:string'
        std::string *deviceFingerprintTrueIPAddress;
        /// Optional element 'ns2:deviceFingerprintProxyIPAddress' of XSD type 'xsd:string'
        std::string *deviceFingerprintProxyIPAddress;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__RiskUpdateService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__RiskUpdateService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__RiskUpdateService, default initialized and not managed by a soap context
        virtual ns2__RiskUpdateService *soap_alloc(void) const { return SOAP_NEW(ns2__RiskUpdateService); }
      public:
        /// Constructor with initializations
        ns2__RiskUpdateService()
        {
          actionCode = (std::string *)0;
          recordID = (std::string *)0;
          recordName = (std::string *)0;
          negativeAddress = (ns2__Address *)0;
          markingReason = (std::string *)0;
          markingNotes = (std::string *)0;
          markingRequestID = (std::string *)0;
          deviceFingerprintSmartID = (std::string *)0;
          deviceFingerprintTrueIPAddress = (std::string *)0;
          deviceFingerprintProxyIPAddress = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__RiskUpdateService() { }
        /// Friend allocator used by soap_new_ns2__RiskUpdateService(struct soap*, int)
        friend SOAP_FMAC1 ns2__RiskUpdateService * SOAP_FMAC2 soap_instantiate_ns2__RiskUpdateService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:357 */
#ifndef SOAP_TYPE_ns2__FraudUpdateService
#define SOAP_TYPE_ns2__FraudUpdateService (178)
/* complex XSD type 'ns2:FraudUpdateService': */
class SOAP_CMAC ns2__FraudUpdateService {
      public:
        /// Optional element 'ns2:actionCode' of XSD type 'xsd:string'
        std::string *actionCode;
        /// Optional element 'ns2:markedData' of XSD type 'xsd:string'
        std::string *markedData;
        /// Optional element 'ns2:markingReason' of XSD type 'xsd:string'
        std::string *markingReason;
        /// Optional element 'ns2:markingNotes' of XSD type 'xsd:string'
        std::string *markingNotes;
        /// Optional element 'ns2:markingRequestID' of XSD type 'xsd:string'
        std::string *markingRequestID;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__FraudUpdateService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__FraudUpdateService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__FraudUpdateService, default initialized and not managed by a soap context
        virtual ns2__FraudUpdateService *soap_alloc(void) const { return SOAP_NEW(ns2__FraudUpdateService); }
      public:
        /// Constructor with initializations
        ns2__FraudUpdateService()
        {
          actionCode = (std::string *)0;
          markedData = (std::string *)0;
          markingReason = (std::string *)0;
          markingNotes = (std::string *)0;
          markingRequestID = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__FraudUpdateService() { }
        /// Friend allocator used by soap_new_ns2__FraudUpdateService(struct soap*, int)
        friend SOAP_FMAC1 ns2__FraudUpdateService * SOAP_FMAC2 soap_instantiate_ns2__FraudUpdateService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:360 */
#ifndef SOAP_TYPE_ns2__CaseManagementActionService
#define SOAP_TYPE_ns2__CaseManagementActionService (179)
/* complex XSD type 'ns2:CaseManagementActionService': */
class SOAP_CMAC ns2__CaseManagementActionService {
      public:
        /// Optional element 'ns2:actionCode' of XSD type 'xsd:string'
        std::string *actionCode;
        /// Optional element 'ns2:requestID' of XSD type 'xsd:string'
        std::string *requestID;
        /// Optional element 'ns2:comments' of XSD type 'xsd:string'
        std::string *comments;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__CaseManagementActionService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__CaseManagementActionService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__CaseManagementActionService, default initialized and not managed by a soap context
        virtual ns2__CaseManagementActionService *soap_alloc(void) const { return SOAP_NEW(ns2__CaseManagementActionService); }
      public:
        /// Constructor with initializations
        ns2__CaseManagementActionService()
        {
          actionCode = (std::string *)0;
          requestID = (std::string *)0;
          comments = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__CaseManagementActionService() { }
        /// Friend allocator used by soap_new_ns2__CaseManagementActionService(struct soap*, int)
        friend SOAP_FMAC1 ns2__CaseManagementActionService * SOAP_FMAC2 soap_instantiate_ns2__CaseManagementActionService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:363 */
#ifndef SOAP_TYPE_ns2__EncryptPaymentDataService
#define SOAP_TYPE_ns2__EncryptPaymentDataService (180)
/* complex XSD type 'ns2:EncryptPaymentDataService': */
class SOAP_CMAC ns2__EncryptPaymentDataService {
      public:
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__EncryptPaymentDataService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__EncryptPaymentDataService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__EncryptPaymentDataService, default initialized and not managed by a soap context
        virtual ns2__EncryptPaymentDataService *soap_alloc(void) const { return SOAP_NEW(ns2__EncryptPaymentDataService); }
      public:
        /// Constructor with initializations
        ns2__EncryptPaymentDataService()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__EncryptPaymentDataService() { }
        /// Friend allocator used by soap_new_ns2__EncryptPaymentDataService(struct soap*, int)
        friend SOAP_FMAC1 ns2__EncryptPaymentDataService * SOAP_FMAC2 soap_instantiate_ns2__EncryptPaymentDataService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:366 */
#ifndef SOAP_TYPE_ns2__InvoiceHeader
#define SOAP_TYPE_ns2__InvoiceHeader (181)
/* complex XSD type 'ns2:InvoiceHeader': */
class SOAP_CMAC ns2__InvoiceHeader {
      public:
        /// Optional element 'ns2:merchantDescriptor' of XSD type 'xsd:string'
        std::string *merchantDescriptor;
        /// Optional element 'ns2:merchantDescriptorContact' of XSD type 'xsd:string'
        std::string *merchantDescriptorContact;
        /// Optional element 'ns2:merchantDescriptorAlternate' of XSD type 'xsd:string'
        std::string *merchantDescriptorAlternate;
        /// Optional element 'ns2:merchantDescriptorStreet' of XSD type 'xsd:string'
        std::string *merchantDescriptorStreet;
        /// Optional element 'ns2:merchantDescriptorCity' of XSD type 'xsd:string'
        std::string *merchantDescriptorCity;
        /// Optional element 'ns2:merchantDescriptorState' of XSD type 'xsd:string'
        std::string *merchantDescriptorState;
        /// Optional element 'ns2:merchantDescriptorPostalCode' of XSD type 'xsd:string'
        std::string *merchantDescriptorPostalCode;
        /// Optional element 'ns2:merchantDescriptorCountry' of XSD type 'xsd:string'
        std::string *merchantDescriptorCountry;
        /// Optional element 'ns2:isGift' of XSD type 'ns2:boolean'
        std::string *isGift;
        /// Optional element 'ns2:returnsAccepted' of XSD type 'ns2:boolean'
        std::string *returnsAccepted;
        /// Optional element 'ns2:tenderType' of XSD type 'xsd:string'
        std::string *tenderType;
        /// Optional element 'ns2:merchantVATRegistrationNumber' of XSD type 'xsd:string'
        std::string *merchantVATRegistrationNumber;
        /// Optional element 'ns2:purchaserOrderDate' of XSD type 'xsd:string'
        std::string *purchaserOrderDate;
        /// Optional element 'ns2:purchaserVATRegistrationNumber' of XSD type 'xsd:string'
        std::string *purchaserVATRegistrationNumber;
        /// Optional element 'ns2:vatInvoiceReferenceNumber' of XSD type 'xsd:string'
        std::string *vatInvoiceReferenceNumber;
        /// Optional element 'ns2:summaryCommodityCode' of XSD type 'xsd:string'
        std::string *summaryCommodityCode;
        /// Optional element 'ns2:supplierOrderReference' of XSD type 'xsd:string'
        std::string *supplierOrderReference;
        /// Optional element 'ns2:userPO' of XSD type 'xsd:string'
        std::string *userPO;
        /// Optional element 'ns2:costCenter' of XSD type 'xsd:string'
        std::string *costCenter;
        /// Optional element 'ns2:purchaserCode' of XSD type 'xsd:string'
        std::string *purchaserCode;
        /// Optional element 'ns2:taxable' of XSD type 'ns2:boolean'
        std::string *taxable;
        /// Optional element 'ns2:amexDataTAA1' of XSD type 'xsd:string'
        std::string *amexDataTAA1;
        /// Optional element 'ns2:amexDataTAA2' of XSD type 'xsd:string'
        std::string *amexDataTAA2;
        /// Optional element 'ns2:amexDataTAA3' of XSD type 'xsd:string'
        std::string *amexDataTAA3;
        /// Optional element 'ns2:amexDataTAA4' of XSD type 'xsd:string'
        std::string *amexDataTAA4;
        /// Optional element 'ns2:invoiceDate' of XSD type 'xsd:string'
        std::string *invoiceDate;
        /// Optional element 'ns2:totalTaxTypeCode' of XSD type 'xsd:string'
        std::string *totalTaxTypeCode;
        /// Optional element 'ns2:cardAcceptorRefNumber' of XSD type 'xsd:string'
        std::string *cardAcceptorRefNumber;
        /// Optional element 'ns2:authorizedContactName' of XSD type 'xsd:string'
        std::string *authorizedContactName;
        /// Optional element 'ns2:businessApplicationID' of XSD type 'xsd:string'
        std::string *businessApplicationID;
        /// Optional element 'ns2:salesOrganizationID' of XSD type 'xsd:integer'
        std::string *salesOrganizationID;
        /// Optional element 'ns2:submerchantID' of XSD type 'xsd:string'
        std::string *submerchantID;
        /// Optional element 'ns2:submerchantName' of XSD type 'xsd:string'
        std::string *submerchantName;
        /// Optional element 'ns2:submerchantStreet' of XSD type 'xsd:string'
        std::string *submerchantStreet;
        /// Optional element 'ns2:submerchantCity' of XSD type 'xsd:string'
        std::string *submerchantCity;
        /// Optional element 'ns2:submerchantPostalCode' of XSD type 'xsd:string'
        std::string *submerchantPostalCode;
        /// Optional element 'ns2:submerchantState' of XSD type 'xsd:string'
        std::string *submerchantState;
        /// Optional element 'ns2:submerchantCountry' of XSD type 'xsd:string'
        std::string *submerchantCountry;
        /// Optional element 'ns2:submerchantEmail' of XSD type 'xsd:string'
        std::string *submerchantEmail;
        /// Optional element 'ns2:submerchantTelephoneNumber' of XSD type 'xsd:string'
        std::string *submerchantTelephoneNumber;
        /// Optional element 'ns2:submerchantRegion' of XSD type 'xsd:string'
        std::string *submerchantRegion;
        /// Optional element 'ns2:submerchantMerchantID' of XSD type 'xsd:string'
        std::string *submerchantMerchantID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__InvoiceHeader
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__InvoiceHeader; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__InvoiceHeader, default initialized and not managed by a soap context
        virtual ns2__InvoiceHeader *soap_alloc(void) const { return SOAP_NEW(ns2__InvoiceHeader); }
      public:
        /// Constructor with initializations
        ns2__InvoiceHeader()
        {
          merchantDescriptor = (std::string *)0;
          merchantDescriptorContact = (std::string *)0;
          merchantDescriptorAlternate = (std::string *)0;
          merchantDescriptorStreet = (std::string *)0;
          merchantDescriptorCity = (std::string *)0;
          merchantDescriptorState = (std::string *)0;
          merchantDescriptorPostalCode = (std::string *)0;
          merchantDescriptorCountry = (std::string *)0;
          isGift = (std::string *)0;
          returnsAccepted = (std::string *)0;
          tenderType = (std::string *)0;
          merchantVATRegistrationNumber = (std::string *)0;
          purchaserOrderDate = (std::string *)0;
          purchaserVATRegistrationNumber = (std::string *)0;
          vatInvoiceReferenceNumber = (std::string *)0;
          summaryCommodityCode = (std::string *)0;
          supplierOrderReference = (std::string *)0;
          userPO = (std::string *)0;
          costCenter = (std::string *)0;
          purchaserCode = (std::string *)0;
          taxable = (std::string *)0;
          amexDataTAA1 = (std::string *)0;
          amexDataTAA2 = (std::string *)0;
          amexDataTAA3 = (std::string *)0;
          amexDataTAA4 = (std::string *)0;
          invoiceDate = (std::string *)0;
          totalTaxTypeCode = (std::string *)0;
          cardAcceptorRefNumber = (std::string *)0;
          authorizedContactName = (std::string *)0;
          businessApplicationID = (std::string *)0;
          salesOrganizationID = (std::string *)0;
          submerchantID = (std::string *)0;
          submerchantName = (std::string *)0;
          submerchantStreet = (std::string *)0;
          submerchantCity = (std::string *)0;
          submerchantPostalCode = (std::string *)0;
          submerchantState = (std::string *)0;
          submerchantCountry = (std::string *)0;
          submerchantEmail = (std::string *)0;
          submerchantTelephoneNumber = (std::string *)0;
          submerchantRegion = (std::string *)0;
          submerchantMerchantID = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__InvoiceHeader() { }
        /// Friend allocator used by soap_new_ns2__InvoiceHeader(struct soap*, int)
        friend SOAP_FMAC1 ns2__InvoiceHeader * SOAP_FMAC2 soap_instantiate_ns2__InvoiceHeader(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:369 */
#ifndef SOAP_TYPE_ns2__BusinessRules
#define SOAP_TYPE_ns2__BusinessRules (182)
/* complex XSD type 'ns2:BusinessRules': */
class SOAP_CMAC ns2__BusinessRules {
      public:
        /// Optional element 'ns2:ignoreAVSResult' of XSD type 'ns2:boolean'
        std::string *ignoreAVSResult;
        /// Optional element 'ns2:ignoreCVResult' of XSD type 'ns2:boolean'
        std::string *ignoreCVResult;
        /// Optional element 'ns2:ignoreDAVResult' of XSD type 'ns2:boolean'
        std::string *ignoreDAVResult;
        /// Optional element 'ns2:ignoreExportResult' of XSD type 'ns2:boolean'
        std::string *ignoreExportResult;
        /// Optional element 'ns2:ignoreValidateResult' of XSD type 'ns2:boolean'
        std::string *ignoreValidateResult;
        /// Optional element 'ns2:declineAVSFlags' of XSD type 'xsd:string'
        std::string *declineAVSFlags;
        /// Optional element 'ns2:scoreThreshold' of XSD type 'xsd:integer'
        std::string *scoreThreshold;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__BusinessRules
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__BusinessRules; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__BusinessRules, default initialized and not managed by a soap context
        virtual ns2__BusinessRules *soap_alloc(void) const { return SOAP_NEW(ns2__BusinessRules); }
      public:
        /// Constructor with initializations
        ns2__BusinessRules()
        {
          ignoreAVSResult = (std::string *)0;
          ignoreCVResult = (std::string *)0;
          ignoreDAVResult = (std::string *)0;
          ignoreExportResult = (std::string *)0;
          ignoreValidateResult = (std::string *)0;
          declineAVSFlags = (std::string *)0;
          scoreThreshold = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__BusinessRules() { }
        /// Friend allocator used by soap_new_ns2__BusinessRules(struct soap*, int)
        friend SOAP_FMAC1 ns2__BusinessRules * SOAP_FMAC2 soap_instantiate_ns2__BusinessRules(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:372 */
#ifndef SOAP_TYPE_ns2__BillTo
#define SOAP_TYPE_ns2__BillTo (183)
/* complex XSD type 'ns2:BillTo': */
class SOAP_CMAC ns2__BillTo {
      public:
        /// Optional element 'ns2:title' of XSD type 'xsd:string'
        std::string *title;
        /// Optional element 'ns2:firstName' of XSD type 'xsd:string'
        std::string *firstName;
        /// Optional element 'ns2:middleName' of XSD type 'xsd:string'
        std::string *middleName;
        /// Optional element 'ns2:lastName' of XSD type 'xsd:string'
        std::string *lastName;
        /// Optional element 'ns2:suffix' of XSD type 'xsd:string'
        std::string *suffix;
        /// Optional element 'ns2:buildingNumber' of XSD type 'xsd:string'
        std::string *buildingNumber;
        /// Optional element 'ns2:street1' of XSD type 'xsd:string'
        std::string *street1;
        /// Optional element 'ns2:street2' of XSD type 'xsd:string'
        std::string *street2;
        /// Optional element 'ns2:street3' of XSD type 'xsd:string'
        std::string *street3;
        /// Optional element 'ns2:street4' of XSD type 'xsd:string'
        std::string *street4;
        /// Optional element 'ns2:city' of XSD type 'xsd:string'
        std::string *city;
        /// Optional element 'ns2:district' of XSD type 'xsd:string'
        std::string *district;
        /// Optional element 'ns2:county' of XSD type 'xsd:string'
        std::string *county;
        /// Optional element 'ns2:state' of XSD type 'xsd:string'
        std::string *state;
        /// Optional element 'ns2:postalCode' of XSD type 'xsd:string'
        std::string *postalCode;
        /// Optional element 'ns2:country' of XSD type 'xsd:string'
        std::string *country;
        /// Optional element 'ns2:company' of XSD type 'xsd:string'
        std::string *company;
        /// Optional element 'ns2:companyTaxID' of XSD type 'xsd:string'
        std::string *companyTaxID;
        /// Optional element 'ns2:phoneNumber' of XSD type 'xsd:string'
        std::string *phoneNumber;
        /// Optional element 'ns2:email' of XSD type 'xsd:string'
        std::string *email;
        /// Optional element 'ns2:ipAddress' of XSD type 'xsd:string'
        std::string *ipAddress;
        /// Optional element 'ns2:customerUserName' of XSD type 'xsd:string'
        std::string *customerUserName;
        /// Optional element 'ns2:customerPassword' of XSD type 'xsd:string'
        std::string *customerPassword;
        /// Optional element 'ns2:ipNetworkAddress' of XSD type 'xsd:string'
        std::string *ipNetworkAddress;
        /// Optional element 'ns2:hostname' of XSD type 'xsd:string'
        std::string *hostname;
        /// Optional element 'ns2:domainName' of XSD type 'xsd:string'
        std::string *domainName;
        /// Optional element 'ns2:dateOfBirth' of XSD type 'xsd:string'
        std::string *dateOfBirth;
        /// Optional element 'ns2:driversLicenseNumber' of XSD type 'xsd:string'
        std::string *driversLicenseNumber;
        /// Optional element 'ns2:driversLicenseState' of XSD type 'xsd:string'
        std::string *driversLicenseState;
        /// Optional element 'ns2:ssn' of XSD type 'xsd:string'
        std::string *ssn;
        /// Optional element 'ns2:customerID' of XSD type 'xsd:string'
        std::string *customerID;
        /// Optional element 'ns2:httpBrowserType' of XSD type 'xsd:string'
        std::string *httpBrowserType;
        /// Optional element 'ns2:httpBrowserEmail' of XSD type 'xsd:string'
        std::string *httpBrowserEmail;
        /// Optional element 'ns2:httpBrowserCookiesAccepted' of XSD type 'ns2:boolean'
        std::string *httpBrowserCookiesAccepted;
        /// Optional element 'ns2:nif' of XSD type 'xsd:string'
        std::string *nif;
        /// Optional element 'ns2:personalID' of XSD type 'xsd:string'
        std::string *personalID;
        /// Optional element 'ns2:language' of XSD type 'xsd:string'
        std::string *language;
        /// Optional element 'ns2:name' of XSD type 'xsd:string'
        std::string *name;
        /// Optional element 'ns2:gender' of XSD type 'xsd:string'
        std::string *gender;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__BillTo
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__BillTo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__BillTo, default initialized and not managed by a soap context
        virtual ns2__BillTo *soap_alloc(void) const { return SOAP_NEW(ns2__BillTo); }
      public:
        /// Constructor with initializations
        ns2__BillTo()
        {
          title = (std::string *)0;
          firstName = (std::string *)0;
          middleName = (std::string *)0;
          lastName = (std::string *)0;
          suffix = (std::string *)0;
          buildingNumber = (std::string *)0;
          street1 = (std::string *)0;
          street2 = (std::string *)0;
          street3 = (std::string *)0;
          street4 = (std::string *)0;
          city = (std::string *)0;
          district = (std::string *)0;
          county = (std::string *)0;
          state = (std::string *)0;
          postalCode = (std::string *)0;
          country = (std::string *)0;
          company = (std::string *)0;
          companyTaxID = (std::string *)0;
          phoneNumber = (std::string *)0;
          email = (std::string *)0;
          ipAddress = (std::string *)0;
          customerUserName = (std::string *)0;
          customerPassword = (std::string *)0;
          ipNetworkAddress = (std::string *)0;
          hostname = (std::string *)0;
          domainName = (std::string *)0;
          dateOfBirth = (std::string *)0;
          driversLicenseNumber = (std::string *)0;
          driversLicenseState = (std::string *)0;
          ssn = (std::string *)0;
          customerID = (std::string *)0;
          httpBrowserType = (std::string *)0;
          httpBrowserEmail = (std::string *)0;
          httpBrowserCookiesAccepted = (std::string *)0;
          nif = (std::string *)0;
          personalID = (std::string *)0;
          language = (std::string *)0;
          name = (std::string *)0;
          gender = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__BillTo() { }
        /// Friend allocator used by soap_new_ns2__BillTo(struct soap*, int)
        friend SOAP_FMAC1 ns2__BillTo * SOAP_FMAC2 soap_instantiate_ns2__BillTo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:375 */
#ifndef SOAP_TYPE_ns2__ShipTo
#define SOAP_TYPE_ns2__ShipTo (184)
/* complex XSD type 'ns2:ShipTo': */
class SOAP_CMAC ns2__ShipTo {
      public:
        /// Optional element 'ns2:title' of XSD type 'xsd:string'
        std::string *title;
        /// Optional element 'ns2:firstName' of XSD type 'xsd:string'
        std::string *firstName;
        /// Optional element 'ns2:middleName' of XSD type 'xsd:string'
        std::string *middleName;
        /// Optional element 'ns2:lastName' of XSD type 'xsd:string'
        std::string *lastName;
        /// Optional element 'ns2:suffix' of XSD type 'xsd:string'
        std::string *suffix;
        /// Optional element 'ns2:street1' of XSD type 'xsd:string'
        std::string *street1;
        /// Optional element 'ns2:street2' of XSD type 'xsd:string'
        std::string *street2;
        /// Optional element 'ns2:street3' of XSD type 'xsd:string'
        std::string *street3;
        /// Optional element 'ns2:street4' of XSD type 'xsd:string'
        std::string *street4;
        /// Optional element 'ns2:city' of XSD type 'xsd:string'
        std::string *city;
        /// Optional element 'ns2:county' of XSD type 'xsd:string'
        std::string *county;
        /// Optional element 'ns2:state' of XSD type 'xsd:string'
        std::string *state;
        /// Optional element 'ns2:buildingNumber' of XSD type 'xsd:string'
        std::string *buildingNumber;
        /// Optional element 'ns2:district' of XSD type 'xsd:string'
        std::string *district;
        /// Optional element 'ns2:postalCode' of XSD type 'xsd:string'
        std::string *postalCode;
        /// Optional element 'ns2:country' of XSD type 'xsd:string'
        std::string *country;
        /// Optional element 'ns2:company' of XSD type 'xsd:string'
        std::string *company;
        /// Optional element 'ns2:phoneNumber' of XSD type 'xsd:string'
        std::string *phoneNumber;
        /// Optional element 'ns2:email' of XSD type 'xsd:string'
        std::string *email;
        /// Optional element 'ns2:shippingMethod' of XSD type 'xsd:string'
        std::string *shippingMethod;
        /// Optional element 'ns2:name' of XSD type 'xsd:string'
        std::string *name;
        /// Optional element 'ns2:id' of XSD type 'xsd:string'
        std::string *id;
        /// Optional element 'ns2:addressVerificationStatus' of XSD type 'xsd:string'
        std::string *addressVerificationStatus;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ShipTo
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ShipTo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ShipTo, default initialized and not managed by a soap context
        virtual ns2__ShipTo *soap_alloc(void) const { return SOAP_NEW(ns2__ShipTo); }
      public:
        /// Constructor with initializations
        ns2__ShipTo()
        {
          title = (std::string *)0;
          firstName = (std::string *)0;
          middleName = (std::string *)0;
          lastName = (std::string *)0;
          suffix = (std::string *)0;
          street1 = (std::string *)0;
          street2 = (std::string *)0;
          street3 = (std::string *)0;
          street4 = (std::string *)0;
          city = (std::string *)0;
          county = (std::string *)0;
          state = (std::string *)0;
          buildingNumber = (std::string *)0;
          district = (std::string *)0;
          postalCode = (std::string *)0;
          country = (std::string *)0;
          company = (std::string *)0;
          phoneNumber = (std::string *)0;
          email = (std::string *)0;
          shippingMethod = (std::string *)0;
          name = (std::string *)0;
          id = (std::string *)0;
          addressVerificationStatus = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__ShipTo() { }
        /// Friend allocator used by soap_new_ns2__ShipTo(struct soap*, int)
        friend SOAP_FMAC1 ns2__ShipTo * SOAP_FMAC2 soap_instantiate_ns2__ShipTo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:378 */
#ifndef SOAP_TYPE_ns2__ShipFrom
#define SOAP_TYPE_ns2__ShipFrom (185)
/* complex XSD type 'ns2:ShipFrom': */
class SOAP_CMAC ns2__ShipFrom {
      public:
        /// Optional element 'ns2:title' of XSD type 'xsd:string'
        std::string *title;
        /// Optional element 'ns2:firstName' of XSD type 'xsd:string'
        std::string *firstName;
        /// Optional element 'ns2:middleName' of XSD type 'xsd:string'
        std::string *middleName;
        /// Optional element 'ns2:lastName' of XSD type 'xsd:string'
        std::string *lastName;
        /// Optional element 'ns2:suffix' of XSD type 'xsd:string'
        std::string *suffix;
        /// Optional element 'ns2:street1' of XSD type 'xsd:string'
        std::string *street1;
        /// Optional element 'ns2:street2' of XSD type 'xsd:string'
        std::string *street2;
        /// Optional element 'ns2:street3' of XSD type 'xsd:string'
        std::string *street3;
        /// Optional element 'ns2:street4' of XSD type 'xsd:string'
        std::string *street4;
        /// Optional element 'ns2:city' of XSD type 'xsd:string'
        std::string *city;
        /// Optional element 'ns2:county' of XSD type 'xsd:string'
        std::string *county;
        /// Optional element 'ns2:state' of XSD type 'xsd:string'
        std::string *state;
        /// Optional element 'ns2:postalCode' of XSD type 'xsd:string'
        std::string *postalCode;
        /// Optional element 'ns2:country' of XSD type 'xsd:string'
        std::string *country;
        /// Optional element 'ns2:company' of XSD type 'xsd:string'
        std::string *company;
        /// Optional element 'ns2:phoneNumber' of XSD type 'xsd:string'
        std::string *phoneNumber;
        /// Optional element 'ns2:email' of XSD type 'xsd:string'
        std::string *email;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ShipFrom
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ShipFrom; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ShipFrom, default initialized and not managed by a soap context
        virtual ns2__ShipFrom *soap_alloc(void) const { return SOAP_NEW(ns2__ShipFrom); }
      public:
        /// Constructor with initializations
        ns2__ShipFrom()
        {
          title = (std::string *)0;
          firstName = (std::string *)0;
          middleName = (std::string *)0;
          lastName = (std::string *)0;
          suffix = (std::string *)0;
          street1 = (std::string *)0;
          street2 = (std::string *)0;
          street3 = (std::string *)0;
          street4 = (std::string *)0;
          city = (std::string *)0;
          county = (std::string *)0;
          state = (std::string *)0;
          postalCode = (std::string *)0;
          country = (std::string *)0;
          company = (std::string *)0;
          phoneNumber = (std::string *)0;
          email = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__ShipFrom() { }
        /// Friend allocator used by soap_new_ns2__ShipFrom(struct soap*, int)
        friend SOAP_FMAC1 ns2__ShipFrom * SOAP_FMAC2 soap_instantiate_ns2__ShipFrom(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:381 */
#ifndef SOAP_TYPE_ns2__Card
#define SOAP_TYPE_ns2__Card (186)
/* complex XSD type 'ns2:Card': */
class SOAP_CMAC ns2__Card {
      public:
        /// Optional element 'ns2:fullName' of XSD type 'xsd:string'
        std::string *fullName;
        /// Optional element 'ns2:accountNumber' of XSD type 'xsd:string'
        std::string *accountNumber;
        /// Optional element 'ns2:expirationMonth' of XSD type 'xsd:integer'
        std::string *expirationMonth;
        /// Optional element 'ns2:expirationYear' of XSD type 'xsd:integer'
        std::string *expirationYear;
        /// Optional element 'ns2:cvIndicator' of XSD type 'xsd:string'
        std::string *cvIndicator;
        /// Optional element 'ns2:cvNumber' of XSD type 'xsd:string'
        std::string *cvNumber;
        /// Optional element 'ns2:cardType' of XSD type 'xsd:string'
        std::string *cardType;
        /// Optional element 'ns2:issueNumber' of XSD type 'xsd:string'
        std::string *issueNumber;
        /// Optional element 'ns2:startMonth' of XSD type 'xsd:integer'
        std::string *startMonth;
        /// Optional element 'ns2:startYear' of XSD type 'xsd:integer'
        std::string *startYear;
        /// Optional element 'ns2:pin' of XSD type 'xsd:string'
        std::string *pin;
        /// Optional element 'ns2:accountEncoderID' of XSD type 'xsd:string'
        std::string *accountEncoderID;
        /// Optional element 'ns2:bin' of XSD type 'xsd:string'
        std::string *bin;
        /// Optional element 'ns2:encryptedData' of XSD type 'xsd:string'
        std::string *encryptedData;
        /// Optional element 'ns2:suffix' of XSD type 'xsd:string'
        std::string *suffix;
        /// Optional element 'ns2:prefix' of XSD type 'xsd:string'
        std::string *prefix;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Card
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__Card; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Card, default initialized and not managed by a soap context
        virtual ns2__Card *soap_alloc(void) const { return SOAP_NEW(ns2__Card); }
      public:
        /// Constructor with initializations
        ns2__Card()
        {
          fullName = (std::string *)0;
          accountNumber = (std::string *)0;
          expirationMonth = (std::string *)0;
          expirationYear = (std::string *)0;
          cvIndicator = (std::string *)0;
          cvNumber = (std::string *)0;
          cardType = (std::string *)0;
          issueNumber = (std::string *)0;
          startMonth = (std::string *)0;
          startYear = (std::string *)0;
          pin = (std::string *)0;
          accountEncoderID = (std::string *)0;
          bin = (std::string *)0;
          encryptedData = (std::string *)0;
          suffix = (std::string *)0;
          prefix = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__Card() { }
        /// Friend allocator used by soap_new_ns2__Card(struct soap*, int)
        friend SOAP_FMAC1 ns2__Card * SOAP_FMAC2 soap_instantiate_ns2__Card(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:384 */
#ifndef SOAP_TYPE_ns2__Check
#define SOAP_TYPE_ns2__Check (187)
/* complex XSD type 'ns2:Check': */
class SOAP_CMAC ns2__Check {
      public:
        /// Optional element 'ns2:fullName' of XSD type 'xsd:string'
        std::string *fullName;
        /// Optional element 'ns2:accountNumber' of XSD type 'xsd:string'
        std::string *accountNumber;
        /// Optional element 'ns2:accountType' of XSD type 'xsd:string'
        std::string *accountType;
        /// Optional element 'ns2:bankTransitNumber' of XSD type 'xsd:string'
        std::string *bankTransitNumber;
        /// Optional element 'ns2:checkNumber' of XSD type 'xsd:string'
        std::string *checkNumber;
        /// Optional element 'ns2:secCode' of XSD type 'xsd:string'
        std::string *secCode;
        /// Optional element 'ns2:accountEncoderID' of XSD type 'xsd:string'
        std::string *accountEncoderID;
        /// Optional element 'ns2:authenticateID' of XSD type 'xsd:string'
        std::string *authenticateID;
        /// Optional element 'ns2:paymentInfo' of XSD type 'xsd:string'
        std::string *paymentInfo;
        /// Optional element 'ns2:imageReferenceNumber' of XSD type 'xsd:string'
        std::string *imageReferenceNumber;
        /// Optional element 'ns2:terminalCity' of XSD type 'xsd:string'
        std::string *terminalCity;
        /// Optional element 'ns2:terminalState' of XSD type 'xsd:string'
        std::string *terminalState;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Check
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__Check; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Check, default initialized and not managed by a soap context
        virtual ns2__Check *soap_alloc(void) const { return SOAP_NEW(ns2__Check); }
      public:
        /// Constructor with initializations
        ns2__Check()
        {
          fullName = (std::string *)0;
          accountNumber = (std::string *)0;
          accountType = (std::string *)0;
          bankTransitNumber = (std::string *)0;
          checkNumber = (std::string *)0;
          secCode = (std::string *)0;
          accountEncoderID = (std::string *)0;
          authenticateID = (std::string *)0;
          paymentInfo = (std::string *)0;
          imageReferenceNumber = (std::string *)0;
          terminalCity = (std::string *)0;
          terminalState = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__Check() { }
        /// Friend allocator used by soap_new_ns2__Check(struct soap*, int)
        friend SOAP_FMAC1 ns2__Check * SOAP_FMAC2 soap_instantiate_ns2__Check(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:387 */
#ifndef SOAP_TYPE_ns2__BML
#define SOAP_TYPE_ns2__BML (188)
/* complex XSD type 'ns2:BML': */
class SOAP_CMAC ns2__BML {
      public:
        /// Optional element 'ns2:customerBillingAddressChange' of XSD type 'ns2:boolean'
        std::string *customerBillingAddressChange;
        /// Optional element 'ns2:customerEmailChange' of XSD type 'ns2:boolean'
        std::string *customerEmailChange;
        /// Optional element 'ns2:customerHasCheckingAccount' of XSD type 'ns2:boolean'
        std::string *customerHasCheckingAccount;
        /// Optional element 'ns2:customerHasSavingsAccount' of XSD type 'ns2:boolean'
        std::string *customerHasSavingsAccount;
        /// Optional element 'ns2:customerPasswordChange' of XSD type 'ns2:boolean'
        std::string *customerPasswordChange;
        /// Optional element 'ns2:customerPhoneChange' of XSD type 'ns2:boolean'
        std::string *customerPhoneChange;
        /// Optional element 'ns2:customerRegistrationDate' of XSD type 'xsd:string'
        std::string *customerRegistrationDate;
        /// Optional element 'ns2:customerTypeFlag' of XSD type 'xsd:string'
        std::string *customerTypeFlag;
        /// Optional element 'ns2:grossHouseholdIncome' of XSD type 'ns2:amount'
        std::string *grossHouseholdIncome;
        /// Optional element 'ns2:householdIncomeCurrency' of XSD type 'xsd:string'
        std::string *householdIncomeCurrency;
        /// Optional element 'ns2:itemCategory' of XSD type 'xsd:string'
        std::string *itemCategory;
        /// Optional element 'ns2:merchantPromotionCode' of XSD type 'xsd:string'
        std::string *merchantPromotionCode;
        /// Optional element 'ns2:preapprovalNumber' of XSD type 'xsd:string'
        std::string *preapprovalNumber;
        /// Optional element 'ns2:productDeliveryTypeIndicator' of XSD type 'xsd:string'
        std::string *productDeliveryTypeIndicator;
        /// Optional element 'ns2:residenceStatus' of XSD type 'xsd:string'
        std::string *residenceStatus;
        /// Optional element 'ns2:tcVersion' of XSD type 'xsd:string'
        std::string *tcVersion;
        /// Optional element 'ns2:yearsAtCurrentResidence' of XSD type 'xsd:integer'
        std::string *yearsAtCurrentResidence;
        /// Optional element 'ns2:yearsWithCurrentEmployer' of XSD type 'xsd:integer'
        std::string *yearsWithCurrentEmployer;
        /// Optional element 'ns2:employerStreet1' of XSD type 'xsd:string'
        std::string *employerStreet1;
        /// Optional element 'ns2:employerStreet2' of XSD type 'xsd:string'
        std::string *employerStreet2;
        /// Optional element 'ns2:employerCity' of XSD type 'xsd:string'
        std::string *employerCity;
        /// Optional element 'ns2:employerCompanyName' of XSD type 'xsd:string'
        std::string *employerCompanyName;
        /// Optional element 'ns2:employerCountry' of XSD type 'xsd:string'
        std::string *employerCountry;
        /// Optional element 'ns2:employerPhoneNumber' of XSD type 'xsd:string'
        std::string *employerPhoneNumber;
        /// Optional element 'ns2:employerPhoneType' of XSD type 'xsd:string'
        std::string *employerPhoneType;
        /// Optional element 'ns2:employerState' of XSD type 'xsd:string'
        std::string *employerState;
        /// Optional element 'ns2:employerPostalCode' of XSD type 'xsd:string'
        std::string *employerPostalCode;
        /// Optional element 'ns2:shipToPhoneType' of XSD type 'xsd:string'
        std::string *shipToPhoneType;
        /// Optional element 'ns2:billToPhoneType' of XSD type 'xsd:string'
        std::string *billToPhoneType;
        /// Optional element 'ns2:methodOfPayment' of XSD type 'xsd:string'
        std::string *methodOfPayment;
        /// Optional element 'ns2:productType' of XSD type 'xsd:string'
        std::string *productType;
        /// Optional element 'ns2:customerAuthenticatedByMerchant' of XSD type 'xsd:string'
        std::string *customerAuthenticatedByMerchant;
        /// Optional element 'ns2:backOfficeIndicator' of XSD type 'xsd:string'
        std::string *backOfficeIndicator;
        /// Optional element 'ns2:shipToEqualsBillToNameIndicator' of XSD type 'xsd:string'
        std::string *shipToEqualsBillToNameIndicator;
        /// Optional element 'ns2:shipToEqualsBillToAddressIndicator' of XSD type 'xsd:string'
        std::string *shipToEqualsBillToAddressIndicator;
        /// Optional element 'ns2:alternateIPAddress' of XSD type 'xsd:string'
        std::string *alternateIPAddress;
        /// Optional element 'ns2:businessLegalName' of XSD type 'xsd:string'
        std::string *businessLegalName;
        /// Optional element 'ns2:dbaName' of XSD type 'xsd:string'
        std::string *dbaName;
        /// Optional element 'ns2:businessAddress1' of XSD type 'xsd:string'
        std::string *businessAddress1;
        /// Optional element 'ns2:businessAddress2' of XSD type 'xsd:string'
        std::string *businessAddress2;
        /// Optional element 'ns2:businessCity' of XSD type 'xsd:string'
        std::string *businessCity;
        /// Optional element 'ns2:businessState' of XSD type 'xsd:string'
        std::string *businessState;
        /// Optional element 'ns2:businessPostalCode' of XSD type 'xsd:string'
        std::string *businessPostalCode;
        /// Optional element 'ns2:businessCountry' of XSD type 'xsd:string'
        std::string *businessCountry;
        /// Optional element 'ns2:businessMainPhone' of XSD type 'xsd:string'
        std::string *businessMainPhone;
        /// Optional element 'ns2:userID' of XSD type 'xsd:string'
        std::string *userID;
        /// Optional element 'ns2:pin' of XSD type 'xsd:string'
        std::string *pin;
        /// Optional element 'ns2:adminLastName' of XSD type 'xsd:string'
        std::string *adminLastName;
        /// Optional element 'ns2:adminFirstName' of XSD type 'xsd:string'
        std::string *adminFirstName;
        /// Optional element 'ns2:adminPhone' of XSD type 'xsd:string'
        std::string *adminPhone;
        /// Optional element 'ns2:adminFax' of XSD type 'xsd:string'
        std::string *adminFax;
        /// Optional element 'ns2:adminEmailAddress' of XSD type 'xsd:string'
        std::string *adminEmailAddress;
        /// Optional element 'ns2:adminTitle' of XSD type 'xsd:string'
        std::string *adminTitle;
        /// Optional element 'ns2:supervisorLastName' of XSD type 'xsd:string'
        std::string *supervisorLastName;
        /// Optional element 'ns2:supervisorFirstName' of XSD type 'xsd:string'
        std::string *supervisorFirstName;
        /// Optional element 'ns2:supervisorEmailAddress' of XSD type 'xsd:string'
        std::string *supervisorEmailAddress;
        /// Optional element 'ns2:businessDAndBNumber' of XSD type 'xsd:string'
        std::string *businessDAndBNumber;
        /// Optional element 'ns2:businessTaxID' of XSD type 'xsd:string'
        std::string *businessTaxID;
        /// Optional element 'ns2:businessNAICSCode' of XSD type 'xsd:string'
        std::string *businessNAICSCode;
        /// Optional element 'ns2:businessType' of XSD type 'xsd:string'
        std::string *businessType;
        /// Optional element 'ns2:businessYearsInBusiness' of XSD type 'xsd:string'
        std::string *businessYearsInBusiness;
        /// Optional element 'ns2:businessNumberOfEmployees' of XSD type 'xsd:string'
        std::string *businessNumberOfEmployees;
        /// Optional element 'ns2:businessPONumber' of XSD type 'xsd:string'
        std::string *businessPONumber;
        /// Optional element 'ns2:businessLoanType' of XSD type 'xsd:string'
        std::string *businessLoanType;
        /// Optional element 'ns2:businessApplicationID' of XSD type 'xsd:string'
        std::string *businessApplicationID;
        /// Optional element 'ns2:businessProductCode' of XSD type 'xsd:string'
        std::string *businessProductCode;
        /// Optional element 'ns2:pgLastName' of XSD type 'xsd:string'
        std::string *pgLastName;
        /// Optional element 'ns2:pgFirstName' of XSD type 'xsd:string'
        std::string *pgFirstName;
        /// Optional element 'ns2:pgSSN' of XSD type 'xsd:string'
        std::string *pgSSN;
        /// Optional element 'ns2:pgDateOfBirth' of XSD type 'xsd:string'
        std::string *pgDateOfBirth;
        /// Optional element 'ns2:pgAnnualIncome' of XSD type 'xsd:string'
        std::string *pgAnnualIncome;
        /// Optional element 'ns2:pgIncomeCurrencyType' of XSD type 'xsd:string'
        std::string *pgIncomeCurrencyType;
        /// Optional element 'ns2:pgResidenceStatus' of XSD type 'xsd:string'
        std::string *pgResidenceStatus;
        /// Optional element 'ns2:pgCheckingAccountIndicator' of XSD type 'xsd:string'
        std::string *pgCheckingAccountIndicator;
        /// Optional element 'ns2:pgSavingsAccountIndicator' of XSD type 'xsd:string'
        std::string *pgSavingsAccountIndicator;
        /// Optional element 'ns2:pgYearsAtEmployer' of XSD type 'xsd:string'
        std::string *pgYearsAtEmployer;
        /// Optional element 'ns2:pgYearsAtResidence' of XSD type 'xsd:string'
        std::string *pgYearsAtResidence;
        /// Optional element 'ns2:pgHomeAddress1' of XSD type 'xsd:string'
        std::string *pgHomeAddress1;
        /// Optional element 'ns2:pgHomeAddress2' of XSD type 'xsd:string'
        std::string *pgHomeAddress2;
        /// Optional element 'ns2:pgHomeCity' of XSD type 'xsd:string'
        std::string *pgHomeCity;
        /// Optional element 'ns2:pgHomeState' of XSD type 'xsd:string'
        std::string *pgHomeState;
        /// Optional element 'ns2:pgHomePostalCode' of XSD type 'xsd:string'
        std::string *pgHomePostalCode;
        /// Optional element 'ns2:pgHomeCountry' of XSD type 'xsd:string'
        std::string *pgHomeCountry;
        /// Optional element 'ns2:pgEmailAddress' of XSD type 'xsd:string'
        std::string *pgEmailAddress;
        /// Optional element 'ns2:pgHomePhone' of XSD type 'xsd:string'
        std::string *pgHomePhone;
        /// Optional element 'ns2:pgTitle' of XSD type 'xsd:string'
        std::string *pgTitle;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__BML
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__BML; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__BML, default initialized and not managed by a soap context
        virtual ns2__BML *soap_alloc(void) const { return SOAP_NEW(ns2__BML); }
      public:
        /// Constructor with initializations
        ns2__BML()
        {
          customerBillingAddressChange = (std::string *)0;
          customerEmailChange = (std::string *)0;
          customerHasCheckingAccount = (std::string *)0;
          customerHasSavingsAccount = (std::string *)0;
          customerPasswordChange = (std::string *)0;
          customerPhoneChange = (std::string *)0;
          customerRegistrationDate = (std::string *)0;
          customerTypeFlag = (std::string *)0;
          grossHouseholdIncome = (std::string *)0;
          householdIncomeCurrency = (std::string *)0;
          itemCategory = (std::string *)0;
          merchantPromotionCode = (std::string *)0;
          preapprovalNumber = (std::string *)0;
          productDeliveryTypeIndicator = (std::string *)0;
          residenceStatus = (std::string *)0;
          tcVersion = (std::string *)0;
          yearsAtCurrentResidence = (std::string *)0;
          yearsWithCurrentEmployer = (std::string *)0;
          employerStreet1 = (std::string *)0;
          employerStreet2 = (std::string *)0;
          employerCity = (std::string *)0;
          employerCompanyName = (std::string *)0;
          employerCountry = (std::string *)0;
          employerPhoneNumber = (std::string *)0;
          employerPhoneType = (std::string *)0;
          employerState = (std::string *)0;
          employerPostalCode = (std::string *)0;
          shipToPhoneType = (std::string *)0;
          billToPhoneType = (std::string *)0;
          methodOfPayment = (std::string *)0;
          productType = (std::string *)0;
          customerAuthenticatedByMerchant = (std::string *)0;
          backOfficeIndicator = (std::string *)0;
          shipToEqualsBillToNameIndicator = (std::string *)0;
          shipToEqualsBillToAddressIndicator = (std::string *)0;
          alternateIPAddress = (std::string *)0;
          businessLegalName = (std::string *)0;
          dbaName = (std::string *)0;
          businessAddress1 = (std::string *)0;
          businessAddress2 = (std::string *)0;
          businessCity = (std::string *)0;
          businessState = (std::string *)0;
          businessPostalCode = (std::string *)0;
          businessCountry = (std::string *)0;
          businessMainPhone = (std::string *)0;
          userID = (std::string *)0;
          pin = (std::string *)0;
          adminLastName = (std::string *)0;
          adminFirstName = (std::string *)0;
          adminPhone = (std::string *)0;
          adminFax = (std::string *)0;
          adminEmailAddress = (std::string *)0;
          adminTitle = (std::string *)0;
          supervisorLastName = (std::string *)0;
          supervisorFirstName = (std::string *)0;
          supervisorEmailAddress = (std::string *)0;
          businessDAndBNumber = (std::string *)0;
          businessTaxID = (std::string *)0;
          businessNAICSCode = (std::string *)0;
          businessType = (std::string *)0;
          businessYearsInBusiness = (std::string *)0;
          businessNumberOfEmployees = (std::string *)0;
          businessPONumber = (std::string *)0;
          businessLoanType = (std::string *)0;
          businessApplicationID = (std::string *)0;
          businessProductCode = (std::string *)0;
          pgLastName = (std::string *)0;
          pgFirstName = (std::string *)0;
          pgSSN = (std::string *)0;
          pgDateOfBirth = (std::string *)0;
          pgAnnualIncome = (std::string *)0;
          pgIncomeCurrencyType = (std::string *)0;
          pgResidenceStatus = (std::string *)0;
          pgCheckingAccountIndicator = (std::string *)0;
          pgSavingsAccountIndicator = (std::string *)0;
          pgYearsAtEmployer = (std::string *)0;
          pgYearsAtResidence = (std::string *)0;
          pgHomeAddress1 = (std::string *)0;
          pgHomeAddress2 = (std::string *)0;
          pgHomeCity = (std::string *)0;
          pgHomeState = (std::string *)0;
          pgHomePostalCode = (std::string *)0;
          pgHomeCountry = (std::string *)0;
          pgEmailAddress = (std::string *)0;
          pgHomePhone = (std::string *)0;
          pgTitle = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__BML() { }
        /// Friend allocator used by soap_new_ns2__BML(struct soap*, int)
        friend SOAP_FMAC1 ns2__BML * SOAP_FMAC2 soap_instantiate_ns2__BML(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:390 */
#ifndef SOAP_TYPE_ns2__OtherTax
#define SOAP_TYPE_ns2__OtherTax (189)
/* complex XSD type 'ns2:OtherTax': */
class SOAP_CMAC ns2__OtherTax {
      public:
        /// Optional element 'ns2:vatTaxAmount' of XSD type 'ns2:amount'
        std::string *vatTaxAmount;
        /// Optional element 'ns2:vatTaxRate' of XSD type 'ns2:amount'
        std::string *vatTaxRate;
        /// Optional element 'ns2:vatTaxAmountSign' of XSD type 'xsd:string'
        std::string *vatTaxAmountSign;
        /// Optional element 'ns2:alternateTaxAmount' of XSD type 'ns2:amount'
        std::string *alternateTaxAmount;
        /// Optional element 'ns2:alternateTaxIndicator' of XSD type 'xsd:string'
        std::string *alternateTaxIndicator;
        /// Optional element 'ns2:alternateTaxID' of XSD type 'xsd:string'
        std::string *alternateTaxID;
        /// Optional element 'ns2:localTaxAmount' of XSD type 'ns2:amount'
        std::string *localTaxAmount;
        /// Optional element 'ns2:localTaxIndicator' of XSD type 'xsd:integer'
        std::string *localTaxIndicator;
        /// Optional element 'ns2:nationalTaxAmount' of XSD type 'ns2:amount'
        std::string *nationalTaxAmount;
        /// Optional element 'ns2:nationalTaxIndicator' of XSD type 'xsd:integer'
        std::string *nationalTaxIndicator;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__OtherTax
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__OtherTax; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__OtherTax, default initialized and not managed by a soap context
        virtual ns2__OtherTax *soap_alloc(void) const { return SOAP_NEW(ns2__OtherTax); }
      public:
        /// Constructor with initializations
        ns2__OtherTax()
        {
          vatTaxAmount = (std::string *)0;
          vatTaxRate = (std::string *)0;
          vatTaxAmountSign = (std::string *)0;
          alternateTaxAmount = (std::string *)0;
          alternateTaxIndicator = (std::string *)0;
          alternateTaxID = (std::string *)0;
          localTaxAmount = (std::string *)0;
          localTaxIndicator = (std::string *)0;
          nationalTaxAmount = (std::string *)0;
          nationalTaxIndicator = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__OtherTax() { }
        /// Friend allocator used by soap_new_ns2__OtherTax(struct soap*, int)
        friend SOAP_FMAC1 ns2__OtherTax * SOAP_FMAC2 soap_instantiate_ns2__OtherTax(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:393 */
#ifndef SOAP_TYPE_ns2__Aft
#define SOAP_TYPE_ns2__Aft (190)
/* complex XSD type 'ns2:Aft': */
class SOAP_CMAC ns2__Aft {
      public:
        /// Optional element 'ns2:indicator' of XSD type 'xsd:string'
        std::string *indicator;
        /// Optional element 'ns2:serviceFee' of XSD type 'xsd:string'
        std::string *serviceFee;
        /// Optional element 'ns2:foreignExchangeFee' of XSD type 'xsd:string'
        std::string *foreignExchangeFee;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Aft
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__Aft; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Aft, default initialized and not managed by a soap context
        virtual ns2__Aft *soap_alloc(void) const { return SOAP_NEW(ns2__Aft); }
      public:
        /// Constructor with initializations
        ns2__Aft()
        {
          indicator = (std::string *)0;
          serviceFee = (std::string *)0;
          foreignExchangeFee = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__Aft() { }
        /// Friend allocator used by soap_new_ns2__Aft(struct soap*, int)
        friend SOAP_FMAC1 ns2__Aft * SOAP_FMAC2 soap_instantiate_ns2__Aft(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:396 */
#ifndef SOAP_TYPE_ns2__Wallet
#define SOAP_TYPE_ns2__Wallet (191)
/* complex XSD type 'ns2:Wallet': */
class SOAP_CMAC ns2__Wallet {
      public:
        /// Optional element 'ns2:type' of XSD type 'xsd:string'
        std::string *type;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Wallet
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__Wallet; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Wallet, default initialized and not managed by a soap context
        virtual ns2__Wallet *soap_alloc(void) const { return SOAP_NEW(ns2__Wallet); }
      public:
        /// Constructor with initializations
        ns2__Wallet()
        {
          type = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__Wallet() { }
        /// Friend allocator used by soap_new_ns2__Wallet(struct soap*, int)
        friend SOAP_FMAC1 ns2__Wallet * SOAP_FMAC2 soap_instantiate_ns2__Wallet(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:399 */
#ifndef SOAP_TYPE_ns2__PurchaseTotals
#define SOAP_TYPE_ns2__PurchaseTotals (192)
/* complex XSD type 'ns2:PurchaseTotals': */
class SOAP_CMAC ns2__PurchaseTotals {
      public:
        /// Optional element 'ns2:currency' of XSD type 'xsd:string'
        std::string *currency;
        /// Optional element 'ns2:discountAmount' of XSD type 'ns2:amount'
        std::string *discountAmount;
        /// Optional element 'ns2:discountAmountSign' of XSD type 'xsd:string'
        std::string *discountAmountSign;
        /// Optional element 'ns2:discountManagementIndicator' of XSD type 'xsd:string'
        std::string *discountManagementIndicator;
        /// Optional element 'ns2:taxAmount' of XSD type 'ns2:amount'
        std::string *taxAmount;
        /// Optional element 'ns2:dutyAmount' of XSD type 'ns2:amount'
        std::string *dutyAmount;
        /// Optional element 'ns2:dutyAmountSign' of XSD type 'xsd:string'
        std::string *dutyAmountSign;
        /// Optional element 'ns2:grandTotalAmount' of XSD type 'ns2:amount'
        std::string *grandTotalAmount;
        /// Optional element 'ns2:freightAmount' of XSD type 'ns2:amount'
        std::string *freightAmount;
        /// Optional element 'ns2:freightAmountSign' of XSD type 'xsd:string'
        std::string *freightAmountSign;
        /// Optional element 'ns2:foreignAmount' of XSD type 'ns2:amount'
        std::string *foreignAmount;
        /// Optional element 'ns2:foreignCurrency' of XSD type 'xsd:string'
        std::string *foreignCurrency;
        /// Optional element 'ns2:originalAmount' of XSD type 'ns2:amount'
        std::string *originalAmount;
        /// Optional element 'ns2:originalCurrency' of XSD type 'xsd:string'
        std::string *originalCurrency;
        /// Optional element 'ns2:exchangeRate' of XSD type 'ns2:amount'
        std::string *exchangeRate;
        /// Optional element 'ns2:exchangeRateTimeStamp' of XSD type 'xsd:string'
        std::string *exchangeRateTimeStamp;
        /// Optional element 'ns2:additionalAmountType0' of XSD type 'xsd:string'
        std::string *additionalAmountType0;
        /// Optional element 'ns2:additionalAmount0' of XSD type 'xsd:string'
        std::string *additionalAmount0;
        /// Optional element 'ns2:additionalAmountType1' of XSD type 'xsd:string'
        std::string *additionalAmountType1;
        /// Optional element 'ns2:additionalAmount1' of XSD type 'xsd:string'
        std::string *additionalAmount1;
        /// Optional element 'ns2:additionalAmountType2' of XSD type 'xsd:string'
        std::string *additionalAmountType2;
        /// Optional element 'ns2:additionalAmount2' of XSD type 'xsd:string'
        std::string *additionalAmount2;
        /// Optional element 'ns2:additionalAmountType3' of XSD type 'xsd:string'
        std::string *additionalAmountType3;
        /// Optional element 'ns2:additionalAmount3' of XSD type 'xsd:string'
        std::string *additionalAmount3;
        /// Optional element 'ns2:additionalAmountType4' of XSD type 'xsd:string'
        std::string *additionalAmountType4;
        /// Optional element 'ns2:additionalAmount4' of XSD type 'xsd:string'
        std::string *additionalAmount4;
        /// Optional element 'ns2:serviceFeeAmount' of XSD type 'ns2:amount'
        std::string *serviceFeeAmount;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PurchaseTotals
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PurchaseTotals; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PurchaseTotals, default initialized and not managed by a soap context
        virtual ns2__PurchaseTotals *soap_alloc(void) const { return SOAP_NEW(ns2__PurchaseTotals); }
      public:
        /// Constructor with initializations
        ns2__PurchaseTotals()
        {
          currency = (std::string *)0;
          discountAmount = (std::string *)0;
          discountAmountSign = (std::string *)0;
          discountManagementIndicator = (std::string *)0;
          taxAmount = (std::string *)0;
          dutyAmount = (std::string *)0;
          dutyAmountSign = (std::string *)0;
          grandTotalAmount = (std::string *)0;
          freightAmount = (std::string *)0;
          freightAmountSign = (std::string *)0;
          foreignAmount = (std::string *)0;
          foreignCurrency = (std::string *)0;
          originalAmount = (std::string *)0;
          originalCurrency = (std::string *)0;
          exchangeRate = (std::string *)0;
          exchangeRateTimeStamp = (std::string *)0;
          additionalAmountType0 = (std::string *)0;
          additionalAmount0 = (std::string *)0;
          additionalAmountType1 = (std::string *)0;
          additionalAmount1 = (std::string *)0;
          additionalAmountType2 = (std::string *)0;
          additionalAmount2 = (std::string *)0;
          additionalAmountType3 = (std::string *)0;
          additionalAmount3 = (std::string *)0;
          additionalAmountType4 = (std::string *)0;
          additionalAmount4 = (std::string *)0;
          serviceFeeAmount = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PurchaseTotals() { }
        /// Friend allocator used by soap_new_ns2__PurchaseTotals(struct soap*, int)
        friend SOAP_FMAC1 ns2__PurchaseTotals * SOAP_FMAC2 soap_instantiate_ns2__PurchaseTotals(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:402 */
#ifndef SOAP_TYPE_ns2__FundingTotals
#define SOAP_TYPE_ns2__FundingTotals (193)
/* complex XSD type 'ns2:FundingTotals': */
class SOAP_CMAC ns2__FundingTotals {
      public:
        /// Optional element 'ns2:currency' of XSD type 'xsd:string'
        std::string *currency;
        /// Optional element 'ns2:grandTotalAmount' of XSD type 'ns2:amount'
        std::string *grandTotalAmount;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__FundingTotals
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__FundingTotals; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__FundingTotals, default initialized and not managed by a soap context
        virtual ns2__FundingTotals *soap_alloc(void) const { return SOAP_NEW(ns2__FundingTotals); }
      public:
        /// Constructor with initializations
        ns2__FundingTotals()
        {
          currency = (std::string *)0;
          grandTotalAmount = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__FundingTotals() { }
        /// Friend allocator used by soap_new_ns2__FundingTotals(struct soap*, int)
        friend SOAP_FMAC1 ns2__FundingTotals * SOAP_FMAC2 soap_instantiate_ns2__FundingTotals(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:405 */
#ifndef SOAP_TYPE_ns2__GECC
#define SOAP_TYPE_ns2__GECC (194)
/* complex XSD type 'ns2:GECC': */
class SOAP_CMAC ns2__GECC {
      public:
        /// Optional element 'ns2:saleType' of XSD type 'xsd:string'
        std::string *saleType;
        /// Optional element 'ns2:planNumber' of XSD type 'xsd:string'
        std::string *planNumber;
        /// Optional element 'ns2:sequenceNumber' of XSD type 'xsd:string'
        std::string *sequenceNumber;
        /// Optional element 'ns2:promotionEndDate' of XSD type 'xsd:string'
        std::string *promotionEndDate;
        /// Optional element 'ns2:promotionPlan' of XSD type 'xsd:string'
        std::string *promotionPlan;
        /// Sequence of 0 to 7 elements 'ns2:line' of XSD type 'xsd:string'
        std::vector<std::string> line;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__GECC
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__GECC; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__GECC, default initialized and not managed by a soap context
        virtual ns2__GECC *soap_alloc(void) const { return SOAP_NEW(ns2__GECC); }
      public:
        /// Constructor with initializations
        ns2__GECC()
        {
          saleType = (std::string *)0;
          planNumber = (std::string *)0;
          sequenceNumber = (std::string *)0;
          promotionEndDate = (std::string *)0;
          promotionPlan = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__GECC() { }
        /// Friend allocator used by soap_new_ns2__GECC(struct soap*, int)
        friend SOAP_FMAC1 ns2__GECC * SOAP_FMAC2 soap_instantiate_ns2__GECC(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:408 */
#ifndef SOAP_TYPE_ns2__UCAF
#define SOAP_TYPE_ns2__UCAF (195)
/* complex XSD type 'ns2:UCAF': */
class SOAP_CMAC ns2__UCAF {
      public:
        /// Optional element 'ns2:authenticationData' of XSD type 'xsd:string'
        std::string *authenticationData;
        /// Optional element 'ns2:collectionIndicator' of XSD type 'xsd:string'
        std::string *collectionIndicator;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__UCAF
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__UCAF; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__UCAF, default initialized and not managed by a soap context
        virtual ns2__UCAF *soap_alloc(void) const { return SOAP_NEW(ns2__UCAF); }
      public:
        /// Constructor with initializations
        ns2__UCAF()
        {
          authenticationData = (std::string *)0;
          collectionIndicator = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__UCAF() { }
        /// Friend allocator used by soap_new_ns2__UCAF(struct soap*, int)
        friend SOAP_FMAC1 ns2__UCAF * SOAP_FMAC2 soap_instantiate_ns2__UCAF(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:411 */
#ifndef SOAP_TYPE_ns2__FundTransfer
#define SOAP_TYPE_ns2__FundTransfer (196)
/* complex XSD type 'ns2:FundTransfer': */
class SOAP_CMAC ns2__FundTransfer {
      public:
        /// Optional element 'ns2:accountNumber' of XSD type 'xsd:string'
        std::string *accountNumber;
        /// Optional element 'ns2:accountName' of XSD type 'xsd:string'
        std::string *accountName;
        /// Optional element 'ns2:bankCheckDigit' of XSD type 'xsd:string'
        std::string *bankCheckDigit;
        /// Optional element 'ns2:iban' of XSD type 'xsd:string'
        std::string *iban;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__FundTransfer
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__FundTransfer; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__FundTransfer, default initialized and not managed by a soap context
        virtual ns2__FundTransfer *soap_alloc(void) const { return SOAP_NEW(ns2__FundTransfer); }
      public:
        /// Constructor with initializations
        ns2__FundTransfer()
        {
          accountNumber = (std::string *)0;
          accountName = (std::string *)0;
          bankCheckDigit = (std::string *)0;
          iban = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__FundTransfer() { }
        /// Friend allocator used by soap_new_ns2__FundTransfer(struct soap*, int)
        friend SOAP_FMAC1 ns2__FundTransfer * SOAP_FMAC2 soap_instantiate_ns2__FundTransfer(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:414 */
#ifndef SOAP_TYPE_ns2__BankInfo
#define SOAP_TYPE_ns2__BankInfo (197)
/* complex XSD type 'ns2:BankInfo': */
class SOAP_CMAC ns2__BankInfo {
      public:
        /// Optional element 'ns2:bankCode' of XSD type 'xsd:string'
        std::string *bankCode;
        /// Optional element 'ns2:name' of XSD type 'xsd:string'
        std::string *name;
        /// Optional element 'ns2:address' of XSD type 'xsd:string'
        std::string *address;
        /// Optional element 'ns2:city' of XSD type 'xsd:string'
        std::string *city;
        /// Optional element 'ns2:country' of XSD type 'xsd:string'
        std::string *country;
        /// Optional element 'ns2:branchCode' of XSD type 'xsd:string'
        std::string *branchCode;
        /// Optional element 'ns2:swiftCode' of XSD type 'xsd:string'
        std::string *swiftCode;
        /// Optional element 'ns2:sortCode' of XSD type 'xsd:string'
        std::string *sortCode;
        /// Optional element 'ns2:issuerID' of XSD type 'xsd:string'
        std::string *issuerID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__BankInfo
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__BankInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__BankInfo, default initialized and not managed by a soap context
        virtual ns2__BankInfo *soap_alloc(void) const { return SOAP_NEW(ns2__BankInfo); }
      public:
        /// Constructor with initializations
        ns2__BankInfo()
        {
          bankCode = (std::string *)0;
          name = (std::string *)0;
          address = (std::string *)0;
          city = (std::string *)0;
          country = (std::string *)0;
          branchCode = (std::string *)0;
          swiftCode = (std::string *)0;
          sortCode = (std::string *)0;
          issuerID = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__BankInfo() { }
        /// Friend allocator used by soap_new_ns2__BankInfo(struct soap*, int)
        friend SOAP_FMAC1 ns2__BankInfo * SOAP_FMAC2 soap_instantiate_ns2__BankInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:417 */
#ifndef SOAP_TYPE_ns2__RecurringSubscriptionInfo
#define SOAP_TYPE_ns2__RecurringSubscriptionInfo (198)
/* complex XSD type 'ns2:RecurringSubscriptionInfo': */
class SOAP_CMAC ns2__RecurringSubscriptionInfo {
      public:
        /// Optional element 'ns2:subscriptionID' of XSD type 'xsd:string'
        std::string *subscriptionID;
        /// Optional element 'ns2:status' of XSD type 'xsd:string'
        std::string *status;
        /// Optional element 'ns2:amount' of XSD type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:numberOfPayments' of XSD type 'xsd:integer'
        std::string *numberOfPayments;
        /// Optional element 'ns2:numberOfPaymentsToAdd' of XSD type 'xsd:integer'
        std::string *numberOfPaymentsToAdd;
        /// Optional element 'ns2:automaticRenew' of XSD type 'ns2:boolean'
        std::string *automaticRenew;
        /// Optional element 'ns2:frequency' of XSD type 'xsd:string'
        std::string *frequency;
        /// Optional element 'ns2:startDate' of XSD type 'xsd:string'
        std::string *startDate;
        /// Optional element 'ns2:endDate' of XSD type 'xsd:string'
        std::string *endDate;
        /// Optional element 'ns2:approvalRequired' of XSD type 'ns2:boolean'
        std::string *approvalRequired;
        /// Optional element 'ns2:event' of XSD type 'ns2:PaySubscriptionEvent'
        ns2__PaySubscriptionEvent *event;
        /// Optional element 'ns2:billPayment' of XSD type 'ns2:boolean'
        std::string *billPayment;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__RecurringSubscriptionInfo
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__RecurringSubscriptionInfo; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__RecurringSubscriptionInfo, default initialized and not managed by a soap context
        virtual ns2__RecurringSubscriptionInfo *soap_alloc(void) const { return SOAP_NEW(ns2__RecurringSubscriptionInfo); }
      public:
        /// Constructor with initializations
        ns2__RecurringSubscriptionInfo()
        {
          subscriptionID = (std::string *)0;
          status = (std::string *)0;
          amount = (std::string *)0;
          numberOfPayments = (std::string *)0;
          numberOfPaymentsToAdd = (std::string *)0;
          automaticRenew = (std::string *)0;
          frequency = (std::string *)0;
          startDate = (std::string *)0;
          endDate = (std::string *)0;
          approvalRequired = (std::string *)0;
          event = (ns2__PaySubscriptionEvent *)0;
          billPayment = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__RecurringSubscriptionInfo() { }
        /// Friend allocator used by soap_new_ns2__RecurringSubscriptionInfo(struct soap*, int)
        friend SOAP_FMAC1 ns2__RecurringSubscriptionInfo * SOAP_FMAC2 soap_instantiate_ns2__RecurringSubscriptionInfo(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:420 */
#ifndef SOAP_TYPE_ns2__PaySubscriptionEvent
#define SOAP_TYPE_ns2__PaySubscriptionEvent (199)
/* complex XSD type 'ns2:PaySubscriptionEvent': */
class SOAP_CMAC ns2__PaySubscriptionEvent {
      public:
        /// Optional element 'ns2:amount' of XSD type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:approvedBy' of XSD type 'xsd:string'
        std::string *approvedBy;
        /// Optional element 'ns2:number' of XSD type 'xsd:integer'
        std::string *number;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PaySubscriptionEvent
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PaySubscriptionEvent; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PaySubscriptionEvent, default initialized and not managed by a soap context
        virtual ns2__PaySubscriptionEvent *soap_alloc(void) const { return SOAP_NEW(ns2__PaySubscriptionEvent); }
      public:
        /// Constructor with initializations
        ns2__PaySubscriptionEvent()
        {
          amount = (std::string *)0;
          approvedBy = (std::string *)0;
          number = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PaySubscriptionEvent() { }
        /// Friend allocator used by soap_new_ns2__PaySubscriptionEvent(struct soap*, int)
        friend SOAP_FMAC1 ns2__PaySubscriptionEvent * SOAP_FMAC2 soap_instantiate_ns2__PaySubscriptionEvent(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:423 */
#ifndef SOAP_TYPE_ns2__Subscription
#define SOAP_TYPE_ns2__Subscription (200)
/* complex XSD type 'ns2:Subscription': */
class SOAP_CMAC ns2__Subscription {
      public:
        /// Optional element 'ns2:title' of XSD type 'xsd:string'
        std::string *title;
        /// Optional element 'ns2:paymentMethod' of XSD type 'xsd:string'
        std::string *paymentMethod;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Subscription
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__Subscription; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Subscription, default initialized and not managed by a soap context
        virtual ns2__Subscription *soap_alloc(void) const { return SOAP_NEW(ns2__Subscription); }
      public:
        /// Constructor with initializations
        ns2__Subscription()
        {
          title = (std::string *)0;
          paymentMethod = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__Subscription() { }
        /// Friend allocator used by soap_new_ns2__Subscription(struct soap*, int)
        friend SOAP_FMAC1 ns2__Subscription * SOAP_FMAC2 soap_instantiate_ns2__Subscription(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:426 */
#ifndef SOAP_TYPE_ns2__PaymentNetworkToken
#define SOAP_TYPE_ns2__PaymentNetworkToken (201)
/* complex XSD type 'ns2:PaymentNetworkToken': */
class SOAP_CMAC ns2__PaymentNetworkToken {
      public:
        /// Optional element 'ns2:requestorID' of XSD type 'xsd:string'
        std::string *requestorID;
        /// Optional element 'ns2:transactionType' of XSD type 'xsd:string'
        std::string *transactionType;
        /// Optional element 'ns2:assuranceLevel' of XSD type 'xsd:string'
        std::string *assuranceLevel;
        /// Optional element 'ns2:accountStatus' of XSD type 'xsd:string'
        std::string *accountStatus;
        /// Optional element 'ns2:originalCardCategory' of XSD type 'xsd:string'
        std::string *originalCardCategory;
        /// Optional element 'ns2:deviceTechType' of XSD type 'xsd:string'
        std::string *deviceTechType;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PaymentNetworkToken
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PaymentNetworkToken; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PaymentNetworkToken, default initialized and not managed by a soap context
        virtual ns2__PaymentNetworkToken *soap_alloc(void) const { return SOAP_NEW(ns2__PaymentNetworkToken); }
      public:
        /// Constructor with initializations
        ns2__PaymentNetworkToken()
        {
          requestorID = (std::string *)0;
          transactionType = (std::string *)0;
          assuranceLevel = (std::string *)0;
          accountStatus = (std::string *)0;
          originalCardCategory = (std::string *)0;
          deviceTechType = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PaymentNetworkToken() { }
        /// Friend allocator used by soap_new_ns2__PaymentNetworkToken(struct soap*, int)
        friend SOAP_FMAC1 ns2__PaymentNetworkToken * SOAP_FMAC2 soap_instantiate_ns2__PaymentNetworkToken(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:429 */
#ifndef SOAP_TYPE_ns2__DecisionManager
#define SOAP_TYPE_ns2__DecisionManager (202)
/* complex XSD type 'ns2:DecisionManager': */
class SOAP_CMAC ns2__DecisionManager {
      public:
        /// Optional element 'ns2:enabled' of XSD type 'ns2:boolean'
        std::string *enabled;
        /// Optional element 'ns2:profile' of XSD type 'xsd:string'
        std::string *profile;
        /// Optional element 'ns2:travelData' of XSD type 'ns2:DecisionManagerTravelData'
        ns2__DecisionManagerTravelData *travelData;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__DecisionManager
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__DecisionManager; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__DecisionManager, default initialized and not managed by a soap context
        virtual ns2__DecisionManager *soap_alloc(void) const { return SOAP_NEW(ns2__DecisionManager); }
      public:
        /// Constructor with initializations
        ns2__DecisionManager()
        {
          enabled = (std::string *)0;
          profile = (std::string *)0;
          travelData = (ns2__DecisionManagerTravelData *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__DecisionManager() { }
        /// Friend allocator used by soap_new_ns2__DecisionManager(struct soap*, int)
        friend SOAP_FMAC1 ns2__DecisionManager * SOAP_FMAC2 soap_instantiate_ns2__DecisionManager(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:432 */
#ifndef SOAP_TYPE_ns2__DecisionManagerTravelData
#define SOAP_TYPE_ns2__DecisionManagerTravelData (203)
/* complex XSD type 'ns2:DecisionManagerTravelData': */
class SOAP_CMAC ns2__DecisionManagerTravelData {
      public:
        /// Sequence of 0 to 100 elements 'ns2:leg' of XSD type 'ns2:DecisionManagerTravelLeg'
        std::vector<ns2__DecisionManagerTravelLeg *> leg;
        /// Optional element 'ns2:departureDateTime' of XSD type 'ns2:dateTime'
        std::string *departureDateTime;
        /// Optional element 'ns2:completeRoute' of XSD type 'xsd:string'
        std::string *completeRoute;
        /// Optional element 'ns2:journeyType' of XSD type 'xsd:string'
        std::string *journeyType;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__DecisionManagerTravelData
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__DecisionManagerTravelData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__DecisionManagerTravelData, default initialized and not managed by a soap context
        virtual ns2__DecisionManagerTravelData *soap_alloc(void) const { return SOAP_NEW(ns2__DecisionManagerTravelData); }
      public:
        /// Constructor with initializations
        ns2__DecisionManagerTravelData()
        {
          departureDateTime = (std::string *)0;
          completeRoute = (std::string *)0;
          journeyType = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__DecisionManagerTravelData() { }
        /// Friend allocator used by soap_new_ns2__DecisionManagerTravelData(struct soap*, int)
        friend SOAP_FMAC1 ns2__DecisionManagerTravelData * SOAP_FMAC2 soap_instantiate_ns2__DecisionManagerTravelData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:435 */
#ifndef SOAP_TYPE_ns2__DecisionManagerTravelLeg
#define SOAP_TYPE_ns2__DecisionManagerTravelLeg (204)
/* complex XSD type 'ns2:DecisionManagerTravelLeg': */
class SOAP_CMAC ns2__DecisionManagerTravelLeg {
      public:
        /// Optional element 'ns2:origin' of XSD type 'xsd:string'
        std::string *origin;
        /// Optional element 'ns2:destination' of XSD type 'xsd:string'
        std::string *destination;
        /// optional attribute 'id' of XSD type 'xsd:integer'
        std::string *id;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__DecisionManagerTravelLeg
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__DecisionManagerTravelLeg; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__DecisionManagerTravelLeg, default initialized and not managed by a soap context
        virtual ns2__DecisionManagerTravelLeg *soap_alloc(void) const { return SOAP_NEW(ns2__DecisionManagerTravelLeg); }
      public:
        /// Constructor with initializations
        ns2__DecisionManagerTravelLeg()
        {
          origin = (std::string *)0;
          destination = (std::string *)0;
          id = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__DecisionManagerTravelLeg() { }
        /// Friend allocator used by soap_new_ns2__DecisionManagerTravelLeg(struct soap*, int)
        friend SOAP_FMAC1 ns2__DecisionManagerTravelLeg * SOAP_FMAC2 soap_instantiate_ns2__DecisionManagerTravelLeg(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:438 */
#ifndef SOAP_TYPE_ns2__Batch
#define SOAP_TYPE_ns2__Batch (205)
/* complex XSD type 'ns2:Batch': */
class SOAP_CMAC ns2__Batch {
      public:
        /// Optional element 'ns2:batchID' of XSD type 'xsd:string'
        std::string *batchID;
        /// Optional element 'ns2:recordID' of XSD type 'xsd:string'
        std::string *recordID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Batch
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__Batch; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Batch, default initialized and not managed by a soap context
        virtual ns2__Batch *soap_alloc(void) const { return SOAP_NEW(ns2__Batch); }
      public:
        /// Constructor with initializations
        ns2__Batch()
        {
          batchID = (std::string *)0;
          recordID = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__Batch() { }
        /// Friend allocator used by soap_new_ns2__Batch(struct soap*, int)
        friend SOAP_FMAC1 ns2__Batch * SOAP_FMAC2 soap_instantiate_ns2__Batch(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:441 */
#ifndef SOAP_TYPE_ns2__PayPal
#define SOAP_TYPE_ns2__PayPal (206)
/* complex XSD type 'ns2:PayPal': */
class SOAP_CMAC ns2__PayPal {
      public:
        std::vector<char *> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPal
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PayPal; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPal, default initialized and not managed by a soap context
        virtual ns2__PayPal *soap_alloc(void) const { return SOAP_NEW(ns2__PayPal); }
      public:
        /// Constructor with initializations
        ns2__PayPal()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__PayPal() { }
        /// Friend allocator used by soap_new_ns2__PayPal(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPal * SOAP_FMAC2 soap_instantiate_ns2__PayPal(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:444 */
#ifndef SOAP_TYPE_ns2__JPO
#define SOAP_TYPE_ns2__JPO (207)
/* complex XSD type 'ns2:JPO': */
class SOAP_CMAC ns2__JPO {
      public:
        /// Optional element 'ns2:paymentMethod' of XSD type 'xsd:integer'
        std::string *paymentMethod;
        /// Optional element 'ns2:bonusAmount' of XSD type 'ns2:amount'
        std::string *bonusAmount;
        /// Optional element 'ns2:bonuses' of XSD type 'xsd:integer'
        std::string *bonuses;
        /// Optional element 'ns2:installments' of XSD type 'xsd:integer'
        std::string *installments;
        /// Optional element 'ns2:firstBillingMonth' of XSD type 'xsd:integer'
        std::string *firstBillingMonth;
        /// Optional element 'ns2:jccaTerminalID' of XSD type 'xsd:integer'
        std::string *jccaTerminalID;
        /// Optional element 'ns2:issuerMessage' of XSD type 'xsd:integer'
        std::string *issuerMessage;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__JPO
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__JPO; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__JPO, default initialized and not managed by a soap context
        virtual ns2__JPO *soap_alloc(void) const { return SOAP_NEW(ns2__JPO); }
      public:
        /// Constructor with initializations
        ns2__JPO()
        {
          paymentMethod = (std::string *)0;
          bonusAmount = (std::string *)0;
          bonuses = (std::string *)0;
          installments = (std::string *)0;
          firstBillingMonth = (std::string *)0;
          jccaTerminalID = (std::string *)0;
          issuerMessage = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__JPO() { }
        /// Friend allocator used by soap_new_ns2__JPO(struct soap*, int)
        friend SOAP_FMAC1 ns2__JPO * SOAP_FMAC2 soap_instantiate_ns2__JPO(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:447 */
#ifndef SOAP_TYPE_ns2__Token
#define SOAP_TYPE_ns2__Token (208)
/* complex XSD type 'ns2:Token': */
class SOAP_CMAC ns2__Token {
      public:
        /// Optional element 'ns2:prefix' of XSD type 'xsd:string'
        std::string *prefix;
        /// Optional element 'ns2:suffix' of XSD type 'xsd:string'
        std::string *suffix;
        /// Optional element 'ns2:expirationMonth' of XSD type 'xsd:string'
        std::string *expirationMonth;
        /// Optional element 'ns2:expirationYear' of XSD type 'xsd:string'
        std::string *expirationYear;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Token
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__Token; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Token, default initialized and not managed by a soap context
        virtual ns2__Token *soap_alloc(void) const { return SOAP_NEW(ns2__Token); }
      public:
        /// Constructor with initializations
        ns2__Token()
        {
          prefix = (std::string *)0;
          suffix = (std::string *)0;
          expirationMonth = (std::string *)0;
          expirationYear = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__Token() { }
        /// Friend allocator used by soap_new_ns2__Token(struct soap*, int)
        friend SOAP_FMAC1 ns2__Token * SOAP_FMAC2 soap_instantiate_ns2__Token(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:450 */
#ifndef SOAP_TYPE_ns2__AP
#define SOAP_TYPE_ns2__AP (209)
/* complex XSD type 'ns2:AP': */
class SOAP_CMAC ns2__AP {
      public:
        /// Optional element 'ns2:orderID' of XSD type 'xsd:string'
        std::string *orderID;
        /// Optional element 'ns2:customerRepresentativeID' of XSD type 'xsd:string'
        std::string *customerRepresentativeID;
        /// Optional element 'ns2:productDescription' of XSD type 'xsd:string'
        std::string *productDescription;
        /// Optional element 'ns2:settlementCurrency' of XSD type 'xsd:string'
        std::string *settlementCurrency;
        /// Optional element 'ns2:subtotalAmount' of XSD type 'xsd:string'
        std::string *subtotalAmount;
        /// Optional element 'ns2:shippingAmount' of XSD type 'xsd:string'
        std::string *shippingAmount;
        /// Optional element 'ns2:handlingAmount' of XSD type 'xsd:string'
        std::string *handlingAmount;
        /// Optional element 'ns2:shippingHandlingAmount' of XSD type 'xsd:string'
        std::string *shippingHandlingAmount;
        /// Optional element 'ns2:additionalAmount' of XSD type 'xsd:string'
        std::string *additionalAmount;
        /// Optional element 'ns2:taxAmount' of XSD type 'xsd:string'
        std::string *taxAmount;
        /// Optional element 'ns2:giftWrapAmount' of XSD type 'xsd:string'
        std::string *giftWrapAmount;
        /// Optional element 'ns2:discountAmount' of XSD type 'xsd:string'
        std::string *discountAmount;
        /// Optional element 'ns2:purchaseID' of XSD type 'xsd:string'
        std::string *purchaseID;
        /// Optional element 'ns2:productID' of XSD type 'xsd:string'
        std::string *productID;
        /// Optional element 'ns2:device' of XSD type 'ns2:APDevice'
        ns2__APDevice *device;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__AP
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__AP; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__AP, default initialized and not managed by a soap context
        virtual ns2__AP *soap_alloc(void) const { return SOAP_NEW(ns2__AP); }
      public:
        /// Constructor with initializations
        ns2__AP()
        {
          orderID = (std::string *)0;
          customerRepresentativeID = (std::string *)0;
          productDescription = (std::string *)0;
          settlementCurrency = (std::string *)0;
          subtotalAmount = (std::string *)0;
          shippingAmount = (std::string *)0;
          handlingAmount = (std::string *)0;
          shippingHandlingAmount = (std::string *)0;
          additionalAmount = (std::string *)0;
          taxAmount = (std::string *)0;
          giftWrapAmount = (std::string *)0;
          discountAmount = (std::string *)0;
          purchaseID = (std::string *)0;
          productID = (std::string *)0;
          device = (ns2__APDevice *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__AP() { }
        /// Friend allocator used by soap_new_ns2__AP(struct soap*, int)
        friend SOAP_FMAC1 ns2__AP * SOAP_FMAC2 soap_instantiate_ns2__AP(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:453 */
#ifndef SOAP_TYPE_ns2__APDevice
#define SOAP_TYPE_ns2__APDevice (210)
/* complex XSD type 'ns2:APDevice': */
class SOAP_CMAC ns2__APDevice {
      public:
        /// Optional element 'ns2:id' of XSD type 'xsd:string'
        std::string *id;
        /// Optional element 'ns2:type' of XSD type 'xsd:string'
        std::string *type;
        /// Optional element 'ns2:userAgent' of XSD type 'xsd:string'
        std::string *userAgent;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__APDevice
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__APDevice; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__APDevice, default initialized and not managed by a soap context
        virtual ns2__APDevice *soap_alloc(void) const { return SOAP_NEW(ns2__APDevice); }
      public:
        /// Constructor with initializations
        ns2__APDevice()
        {
          id = (std::string *)0;
          type = (std::string *)0;
          userAgent = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__APDevice() { }
        /// Friend allocator used by soap_new_ns2__APDevice(struct soap*, int)
        friend SOAP_FMAC1 ns2__APDevice * SOAP_FMAC2 soap_instantiate_ns2__APDevice(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:456 */
#ifndef SOAP_TYPE_ns2__APAuthService
#define SOAP_TYPE_ns2__APAuthService (211)
/* complex XSD type 'ns2:APAuthService': */
class SOAP_CMAC ns2__APAuthService {
      public:
        /// Optional element 'ns2:cancelURL' of XSD type 'xsd:string'
        std::string *cancelURL;
        /// Optional element 'ns2:successURL' of XSD type 'xsd:string'
        std::string *successURL;
        /// Optional element 'ns2:failureURL' of XSD type 'xsd:string'
        std::string *failureURL;
        /// Optional element 'ns2:overridePaymentMethod' of XSD type 'xsd:string'
        std::string *overridePaymentMethod;
        /// Optional element 'ns2:reconciliationID' of XSD type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:preapprovalToken' of XSD type 'xsd:string'
        std::string *preapprovalToken;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__APAuthService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__APAuthService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__APAuthService, default initialized and not managed by a soap context
        virtual ns2__APAuthService *soap_alloc(void) const { return SOAP_NEW(ns2__APAuthService); }
      public:
        /// Constructor with initializations
        ns2__APAuthService()
        {
          cancelURL = (std::string *)0;
          successURL = (std::string *)0;
          failureURL = (std::string *)0;
          overridePaymentMethod = (std::string *)0;
          reconciliationID = (std::string *)0;
          preapprovalToken = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__APAuthService() { }
        /// Friend allocator used by soap_new_ns2__APAuthService(struct soap*, int)
        friend SOAP_FMAC1 ns2__APAuthService * SOAP_FMAC2 soap_instantiate_ns2__APAuthService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:459 */
#ifndef SOAP_TYPE_ns2__APAuthReversalService
#define SOAP_TYPE_ns2__APAuthReversalService (212)
/* complex XSD type 'ns2:APAuthReversalService': */
class SOAP_CMAC ns2__APAuthReversalService {
      public:
        /// Optional element 'ns2:authRequestID' of XSD type 'xsd:string'
        std::string *authRequestID;
        /// Optional element 'ns2:reconciliationID' of XSD type 'xsd:string'
        std::string *reconciliationID;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__APAuthReversalService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__APAuthReversalService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__APAuthReversalService, default initialized and not managed by a soap context
        virtual ns2__APAuthReversalService *soap_alloc(void) const { return SOAP_NEW(ns2__APAuthReversalService); }
      public:
        /// Constructor with initializations
        ns2__APAuthReversalService()
        {
          authRequestID = (std::string *)0;
          reconciliationID = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__APAuthReversalService() { }
        /// Friend allocator used by soap_new_ns2__APAuthReversalService(struct soap*, int)
        friend SOAP_FMAC1 ns2__APAuthReversalService * SOAP_FMAC2 soap_instantiate_ns2__APAuthReversalService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:462 */
#ifndef SOAP_TYPE_ns2__APCaptureService
#define SOAP_TYPE_ns2__APCaptureService (213)
/* complex XSD type 'ns2:APCaptureService': */
class SOAP_CMAC ns2__APCaptureService {
      public:
        /// Optional element 'ns2:authRequestID' of XSD type 'xsd:string'
        std::string *authRequestID;
        /// Optional element 'ns2:reconciliationID' of XSD type 'xsd:string'
        std::string *reconciliationID;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__APCaptureService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__APCaptureService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__APCaptureService, default initialized and not managed by a soap context
        virtual ns2__APCaptureService *soap_alloc(void) const { return SOAP_NEW(ns2__APCaptureService); }
      public:
        /// Constructor with initializations
        ns2__APCaptureService()
        {
          authRequestID = (std::string *)0;
          reconciliationID = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__APCaptureService() { }
        /// Friend allocator used by soap_new_ns2__APCaptureService(struct soap*, int)
        friend SOAP_FMAC1 ns2__APCaptureService * SOAP_FMAC2 soap_instantiate_ns2__APCaptureService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:465 */
#ifndef SOAP_TYPE_ns2__APOptionsService
#define SOAP_TYPE_ns2__APOptionsService (214)
/* complex XSD type 'ns2:APOptionsService': */
class SOAP_CMAC ns2__APOptionsService {
      public:
        /// Optional element 'ns2:limit' of XSD type 'xsd:string'
        std::string *limit;
        /// Optional element 'ns2:offset' of XSD type 'xsd:string'
        std::string *offset;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__APOptionsService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__APOptionsService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__APOptionsService, default initialized and not managed by a soap context
        virtual ns2__APOptionsService *soap_alloc(void) const { return SOAP_NEW(ns2__APOptionsService); }
      public:
        /// Constructor with initializations
        ns2__APOptionsService()
        {
          limit = (std::string *)0;
          offset = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__APOptionsService() { }
        /// Friend allocator used by soap_new_ns2__APOptionsService(struct soap*, int)
        friend SOAP_FMAC1 ns2__APOptionsService * SOAP_FMAC2 soap_instantiate_ns2__APOptionsService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:468 */
#ifndef SOAP_TYPE_ns2__APRefundService
#define SOAP_TYPE_ns2__APRefundService (215)
/* complex XSD type 'ns2:APRefundService': */
class SOAP_CMAC ns2__APRefundService {
      public:
        /// Optional element 'ns2:captureRequestID' of XSD type 'xsd:string'
        std::string *captureRequestID;
        /// Optional element 'ns2:refundRequestID' of XSD type 'xsd:string'
        std::string *refundRequestID;
        /// Optional element 'ns2:reason' of XSD type 'xsd:string'
        std::string *reason;
        /// Optional element 'ns2:note' of XSD type 'xsd:string'
        std::string *note;
        /// Optional element 'ns2:apInitiateRequestID' of XSD type 'xsd:string'
        std::string *apInitiateRequestID;
        /// Optional element 'ns2:returnRef' of XSD type 'xsd:string'
        std::string *returnRef;
        /// Optional element 'ns2:reconciliationID' of XSD type 'xsd:string'
        std::string *reconciliationID;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__APRefundService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__APRefundService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__APRefundService, default initialized and not managed by a soap context
        virtual ns2__APRefundService *soap_alloc(void) const { return SOAP_NEW(ns2__APRefundService); }
      public:
        /// Constructor with initializations
        ns2__APRefundService()
        {
          captureRequestID = (std::string *)0;
          refundRequestID = (std::string *)0;
          reason = (std::string *)0;
          note = (std::string *)0;
          apInitiateRequestID = (std::string *)0;
          returnRef = (std::string *)0;
          reconciliationID = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__APRefundService() { }
        /// Friend allocator used by soap_new_ns2__APRefundService(struct soap*, int)
        friend SOAP_FMAC1 ns2__APRefundService * SOAP_FMAC2 soap_instantiate_ns2__APRefundService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:471 */
#ifndef SOAP_TYPE_ns2__APSaleService
#define SOAP_TYPE_ns2__APSaleService (216)
/* complex XSD type 'ns2:APSaleService': */
class SOAP_CMAC ns2__APSaleService {
      public:
        /// Optional element 'ns2:cancelURL' of XSD type 'xsd:string'
        std::string *cancelURL;
        /// Optional element 'ns2:successURL' of XSD type 'xsd:string'
        std::string *successURL;
        /// Optional element 'ns2:failureURL' of XSD type 'xsd:string'
        std::string *failureURL;
        /// Optional element 'ns2:reconciliationID' of XSD type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:overridePaymentMethod' of XSD type 'xsd:string'
        std::string *overridePaymentMethod;
        /// Optional element 'ns2:paymentOptionID' of XSD type 'xsd:string'
        std::string *paymentOptionID;
        /// Optional element 'ns2:transactionTimeout' of XSD type 'xsd:string'
        std::string *transactionTimeout;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__APSaleService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__APSaleService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__APSaleService, default initialized and not managed by a soap context
        virtual ns2__APSaleService *soap_alloc(void) const { return SOAP_NEW(ns2__APSaleService); }
      public:
        /// Constructor with initializations
        ns2__APSaleService()
        {
          cancelURL = (std::string *)0;
          successURL = (std::string *)0;
          failureURL = (std::string *)0;
          reconciliationID = (std::string *)0;
          overridePaymentMethod = (std::string *)0;
          paymentOptionID = (std::string *)0;
          transactionTimeout = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__APSaleService() { }
        /// Friend allocator used by soap_new_ns2__APSaleService(struct soap*, int)
        friend SOAP_FMAC1 ns2__APSaleService * SOAP_FMAC2 soap_instantiate_ns2__APSaleService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:474 */
#ifndef SOAP_TYPE_ns2__APCheckOutDetailsService
#define SOAP_TYPE_ns2__APCheckOutDetailsService (217)
/* complex XSD type 'ns2:APCheckOutDetailsService': */
class SOAP_CMAC ns2__APCheckOutDetailsService {
      public:
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__APCheckOutDetailsService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__APCheckOutDetailsService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__APCheckOutDetailsService, default initialized and not managed by a soap context
        virtual ns2__APCheckOutDetailsService *soap_alloc(void) const { return SOAP_NEW(ns2__APCheckOutDetailsService); }
      public:
        /// Constructor with initializations
        ns2__APCheckOutDetailsService()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__APCheckOutDetailsService() { }
        /// Friend allocator used by soap_new_ns2__APCheckOutDetailsService(struct soap*, int)
        friend SOAP_FMAC1 ns2__APCheckOutDetailsService * SOAP_FMAC2 soap_instantiate_ns2__APCheckOutDetailsService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:477 */
#ifndef SOAP_TYPE_ns2__APTransactionDetailsService
#define SOAP_TYPE_ns2__APTransactionDetailsService (218)
/* complex XSD type 'ns2:APTransactionDetailsService': */
class SOAP_CMAC ns2__APTransactionDetailsService {
      public:
        /// Optional element 'ns2:transactionDetailsRequestID' of XSD type 'xsd:string'
        std::string *transactionDetailsRequestID;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__APTransactionDetailsService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__APTransactionDetailsService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__APTransactionDetailsService, default initialized and not managed by a soap context
        virtual ns2__APTransactionDetailsService *soap_alloc(void) const { return SOAP_NEW(ns2__APTransactionDetailsService); }
      public:
        /// Constructor with initializations
        ns2__APTransactionDetailsService()
        {
          transactionDetailsRequestID = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__APTransactionDetailsService() { }
        /// Friend allocator used by soap_new_ns2__APTransactionDetailsService(struct soap*, int)
        friend SOAP_FMAC1 ns2__APTransactionDetailsService * SOAP_FMAC2 soap_instantiate_ns2__APTransactionDetailsService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:480 */
#ifndef SOAP_TYPE_ns2__APConfirmPurchaseService
#define SOAP_TYPE_ns2__APConfirmPurchaseService (219)
/* complex XSD type 'ns2:APConfirmPurchaseService': */
class SOAP_CMAC ns2__APConfirmPurchaseService {
      public:
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__APConfirmPurchaseService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__APConfirmPurchaseService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__APConfirmPurchaseService, default initialized and not managed by a soap context
        virtual ns2__APConfirmPurchaseService *soap_alloc(void) const { return SOAP_NEW(ns2__APConfirmPurchaseService); }
      public:
        /// Constructor with initializations
        ns2__APConfirmPurchaseService()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__APConfirmPurchaseService() { }
        /// Friend allocator used by soap_new_ns2__APConfirmPurchaseService(struct soap*, int)
        friend SOAP_FMAC1 ns2__APConfirmPurchaseService * SOAP_FMAC2 soap_instantiate_ns2__APConfirmPurchaseService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:483 */
#ifndef SOAP_TYPE_ns2__PayPalGetTxnDetailsService
#define SOAP_TYPE_ns2__PayPalGetTxnDetailsService (220)
/* complex XSD type 'ns2:PayPalGetTxnDetailsService': */
class SOAP_CMAC ns2__PayPalGetTxnDetailsService {
      public:
        /// Optional element 'ns2:transactionID' of XSD type 'xsd:string'
        std::string *transactionID;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalGetTxnDetailsService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PayPalGetTxnDetailsService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalGetTxnDetailsService, default initialized and not managed by a soap context
        virtual ns2__PayPalGetTxnDetailsService *soap_alloc(void) const { return SOAP_NEW(ns2__PayPalGetTxnDetailsService); }
      public:
        /// Constructor with initializations
        ns2__PayPalGetTxnDetailsService()
        {
          transactionID = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PayPalGetTxnDetailsService() { }
        /// Friend allocator used by soap_new_ns2__PayPalGetTxnDetailsService(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalGetTxnDetailsService * SOAP_FMAC2 soap_instantiate_ns2__PayPalGetTxnDetailsService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:486 */
#ifndef SOAP_TYPE_ns2__PayPalTransactionSearchService
#define SOAP_TYPE_ns2__PayPalTransactionSearchService (221)
/* complex XSD type 'ns2:PayPalTransactionSearchService': */
class SOAP_CMAC ns2__PayPalTransactionSearchService {
      public:
        /// Optional element 'ns2:startDate' of XSD type 'xsd:string'
        std::string *startDate;
        /// Optional element 'ns2:endDate' of XSD type 'xsd:string'
        std::string *endDate;
        /// Optional element 'ns2:paypalCustomerEmail' of XSD type 'xsd:string'
        std::string *paypalCustomerEmail;
        /// Optional element 'ns2:paypalReceiptId' of XSD type 'xsd:string'
        std::string *paypalReceiptId;
        /// Optional element 'ns2:transactionID' of XSD type 'xsd:string'
        std::string *transactionID;
        /// Optional element 'ns2:invoiceNumber' of XSD type 'xsd:string'
        std::string *invoiceNumber;
        /// Optional element 'ns2:grandTotalAmount' of XSD type 'ns2:amount'
        std::string *grandTotalAmount;
        /// Optional element 'ns2:currency' of XSD type 'xsd:string'
        std::string *currency;
        /// Optional element 'ns2:paymentStatus' of XSD type 'xsd:string'
        std::string *paymentStatus;
        /// Optional element 'ns2:payerSalutation' of XSD type 'xsd:string'
        std::string *payerSalutation;
        /// Optional element 'ns2:payerFirstname' of XSD type 'xsd:string'
        std::string *payerFirstname;
        /// Optional element 'ns2:payerMiddlename' of XSD type 'xsd:string'
        std::string *payerMiddlename;
        /// Optional element 'ns2:payerLastname' of XSD type 'xsd:string'
        std::string *payerLastname;
        /// Optional element 'ns2:payerSuffix' of XSD type 'xsd:string'
        std::string *payerSuffix;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalTransactionSearchService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PayPalTransactionSearchService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalTransactionSearchService, default initialized and not managed by a soap context
        virtual ns2__PayPalTransactionSearchService *soap_alloc(void) const { return SOAP_NEW(ns2__PayPalTransactionSearchService); }
      public:
        /// Constructor with initializations
        ns2__PayPalTransactionSearchService()
        {
          startDate = (std::string *)0;
          endDate = (std::string *)0;
          paypalCustomerEmail = (std::string *)0;
          paypalReceiptId = (std::string *)0;
          transactionID = (std::string *)0;
          invoiceNumber = (std::string *)0;
          grandTotalAmount = (std::string *)0;
          currency = (std::string *)0;
          paymentStatus = (std::string *)0;
          payerSalutation = (std::string *)0;
          payerFirstname = (std::string *)0;
          payerMiddlename = (std::string *)0;
          payerLastname = (std::string *)0;
          payerSuffix = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PayPalTransactionSearchService() { }
        /// Friend allocator used by soap_new_ns2__PayPalTransactionSearchService(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalTransactionSearchService * SOAP_FMAC2 soap_instantiate_ns2__PayPalTransactionSearchService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:489 */
#ifndef SOAP_TYPE_ns2__Recipient
#define SOAP_TYPE_ns2__Recipient (222)
/* complex XSD type 'ns2:Recipient': */
class SOAP_CMAC ns2__Recipient {
      public:
        /// Optional element 'ns2:dateOfBirth' of XSD type 'xsd:string'
        std::string *dateOfBirth;
        /// Optional element 'ns2:postalCode' of XSD type 'xsd:string'
        std::string *postalCode;
        /// Optional element 'ns2:accountID' of XSD type 'xsd:string'
        std::string *accountID;
        /// Optional element 'ns2:lastName' of XSD type 'xsd:string'
        std::string *lastName;
        /// Optional element 'ns2:name' of XSD type 'xsd:string'
        std::string *name;
        /// Optional element 'ns2:billingAmount' of XSD type 'ns2:amount'
        std::string *billingAmount;
        /// Optional element 'ns2:billingCurrency' of XSD type 'xsd:string'
        std::string *billingCurrency;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Recipient
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__Recipient; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Recipient, default initialized and not managed by a soap context
        virtual ns2__Recipient *soap_alloc(void) const { return SOAP_NEW(ns2__Recipient); }
      public:
        /// Constructor with initializations
        ns2__Recipient()
        {
          dateOfBirth = (std::string *)0;
          postalCode = (std::string *)0;
          accountID = (std::string *)0;
          lastName = (std::string *)0;
          name = (std::string *)0;
          billingAmount = (std::string *)0;
          billingCurrency = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__Recipient() { }
        /// Friend allocator used by soap_new_ns2__Recipient(struct soap*, int)
        friend SOAP_FMAC1 ns2__Recipient * SOAP_FMAC2 soap_instantiate_ns2__Recipient(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:492 */
#ifndef SOAP_TYPE_ns2__Sender
#define SOAP_TYPE_ns2__Sender (223)
/* complex XSD type 'ns2:Sender': */
class SOAP_CMAC ns2__Sender {
      public:
        /// Optional element 'ns2:referenceNumber' of XSD type 'xsd:string'
        std::string *referenceNumber;
        /// Optional element 'ns2:sourceOfFunds' of XSD type 'xsd:string'
        std::string *sourceOfFunds;
        /// Optional element 'ns2:name' of XSD type 'xsd:string'
        std::string *name;
        /// Optional element 'ns2:address' of XSD type 'xsd:string'
        std::string *address;
        /// Optional element 'ns2:city' of XSD type 'xsd:string'
        std::string *city;
        /// Optional element 'ns2:state' of XSD type 'xsd:string'
        std::string *state;
        /// Optional element 'ns2:postalCode' of XSD type 'xsd:string'
        std::string *postalCode;
        /// Optional element 'ns2:country' of XSD type 'xsd:string'
        std::string *country;
        /// Optional element 'ns2:accountNumber' of XSD type 'xsd:string'
        std::string *accountNumber;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Sender
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__Sender; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Sender, default initialized and not managed by a soap context
        virtual ns2__Sender *soap_alloc(void) const { return SOAP_NEW(ns2__Sender); }
      public:
        /// Constructor with initializations
        ns2__Sender()
        {
          referenceNumber = (std::string *)0;
          sourceOfFunds = (std::string *)0;
          name = (std::string *)0;
          address = (std::string *)0;
          city = (std::string *)0;
          state = (std::string *)0;
          postalCode = (std::string *)0;
          country = (std::string *)0;
          accountNumber = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__Sender() { }
        /// Friend allocator used by soap_new_ns2__Sender(struct soap*, int)
        friend SOAP_FMAC1 ns2__Sender * SOAP_FMAC2 soap_instantiate_ns2__Sender(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:495 */
#ifndef SOAP_TYPE_ns2__RequestMessage
#define SOAP_TYPE_ns2__RequestMessage (224)
/* complex XSD type 'ns2:RequestMessage': */
class SOAP_CMAC ns2__RequestMessage {
      public:
        /// Optional element 'ns2:merchantID' of XSD type 'xsd:string'
        std::string *merchantID;
        /// Optional element 'ns2:merchantReferenceCode' of XSD type 'xsd:string'
        std::string *merchantReferenceCode;
        /// Optional element 'ns2:debtIndicator' of XSD type 'ns2:boolean'
        std::string *debtIndicator;
        /// Optional element 'ns2:clientLibrary' of XSD type 'xsd:string'
        std::string *clientLibrary;
        /// Optional element 'ns2:clientLibraryVersion' of XSD type 'xsd:string'
        std::string *clientLibraryVersion;
        /// Optional element 'ns2:clientEnvironment' of XSD type 'xsd:string'
        std::string *clientEnvironment;
        /// Optional element 'ns2:clientSecurityLibraryVersion' of XSD type 'xsd:string'
        std::string *clientSecurityLibraryVersion;
        /// Optional element 'ns2:clientApplication' of XSD type 'xsd:string'
        std::string *clientApplication;
        /// Optional element 'ns2:clientApplicationVersion' of XSD type 'xsd:string'
        std::string *clientApplicationVersion;
        /// Optional element 'ns2:clientApplicationUser' of XSD type 'xsd:string'
        std::string *clientApplicationUser;
        /// Optional element 'ns2:routingCode' of XSD type 'xsd:string'
        std::string *routingCode;
        /// Optional element 'ns2:comments' of XSD type 'xsd:string'
        std::string *comments;
        /// Optional element 'ns2:returnURL' of XSD type 'xsd:string'
        std::string *returnURL;
        /// Optional element 'ns2:invoiceHeader' of XSD type 'ns2:InvoiceHeader'
        ns2__InvoiceHeader *invoiceHeader;
        /// Optional element 'ns2:aggregatorMerchantIdentifier' of XSD type 'xsd:string'
        std::string *aggregatorMerchantIdentifier;
        /// Optional element 'ns2:customerID' of XSD type 'xsd:string'
        std::string *customerID;
        /// Optional element 'ns2:customerFirstName' of XSD type 'xsd:string'
        std::string *customerFirstName;
        /// Optional element 'ns2:customerLastName' of XSD type 'xsd:string'
        std::string *customerLastName;
        /// Optional element 'ns2:billTo' of XSD type 'ns2:BillTo'
        ns2__BillTo *billTo;
        /// Optional element 'ns2:shipTo' of XSD type 'ns2:ShipTo'
        ns2__ShipTo *shipTo;
        /// Optional element 'ns2:personalId' of XSD type 'ns2:PersonalId'
        ns2__PersonalId *personalId;
        /// Optional element 'ns2:shipFrom' of XSD type 'ns2:ShipFrom'
        ns2__ShipFrom *shipFrom;
        /// Sequence of 0 to 1000 elements 'ns2:item' of XSD type 'ns2:Item'
        std::vector<ns2__Item *> item;
        /// Optional element 'ns2:purchaseTotals' of XSD type 'ns2:PurchaseTotals'
        ns2__PurchaseTotals *purchaseTotals;
        /// Optional element 'ns2:fundingTotals' of XSD type 'ns2:FundingTotals'
        ns2__FundingTotals *fundingTotals;
        /// Optional element 'ns2:dcc' of XSD type 'ns2:DCC'
        ns2__DCC *dcc;
        /// Optional element 'ns2:pos' of XSD type 'ns2:Pos'
        ns2__Pos *pos;
        /// Optional element 'ns2:encryptedPayment' of XSD type 'ns2:EncryptedPayment'
        ns2__EncryptedPayment *encryptedPayment;
        /// Optional element 'ns2:installment' of XSD type 'ns2:Installment'
        ns2__Installment *installment;
        /// Optional element 'ns2:card' of XSD type 'ns2:Card'
        ns2__Card *card;
        /// Optional element 'ns2:check' of XSD type 'ns2:Check'
        ns2__Check *check;
        /// Optional element 'ns2:bml' of XSD type 'ns2:BML'
        ns2__BML *bml;
        /// Optional element 'ns2:gecc' of XSD type 'ns2:GECC'
        ns2__GECC *gecc;
        /// Optional element 'ns2:ucaf' of XSD type 'ns2:UCAF'
        ns2__UCAF *ucaf;
        /// Optional element 'ns2:fundTransfer' of XSD type 'ns2:FundTransfer'
        ns2__FundTransfer *fundTransfer;
        /// Optional element 'ns2:bankInfo' of XSD type 'ns2:BankInfo'
        ns2__BankInfo *bankInfo;
        /// Optional element 'ns2:subscription' of XSD type 'ns2:Subscription'
        ns2__Subscription *subscription;
        /// Optional element 'ns2:recurringSubscriptionInfo' of XSD type 'ns2:RecurringSubscriptionInfo'
        ns2__RecurringSubscriptionInfo *recurringSubscriptionInfo;
        /// Optional element 'ns2:decisionManager' of XSD type 'ns2:DecisionManager'
        ns2__DecisionManager *decisionManager;
        /// Optional element 'ns2:otherTax' of XSD type 'ns2:OtherTax'
        ns2__OtherTax *otherTax;
        /// Optional element 'ns2:paypal' of XSD type 'ns2:PayPal'
        ns2__PayPal *paypal;
        /// Optional element 'ns2:merchantDefinedData' of XSD type 'ns2:MerchantDefinedData'
        ns2__MerchantDefinedData *merchantDefinedData;
        /// Optional element 'ns2:merchantSecureData' of XSD type 'ns2:MerchantSecureData'
        ns2__MerchantSecureData *merchantSecureData;
        /// Optional element 'ns2:jpo' of XSD type 'ns2:JPO'
        ns2__JPO *jpo;
        /// Optional element 'ns2:orderRequestToken' of XSD type 'xsd:string'
        std::string *orderRequestToken;
        /// Optional element 'ns2:linkToRequest' of XSD type 'xsd:string'
        std::string *linkToRequest;
        /// Optional element 'ns2:serviceFee' of XSD type 'ns2:ServiceFee'
        ns2__ServiceFee *serviceFee;
        /// Optional element 'ns2:ccAuthService' of XSD type 'ns2:CCAuthService'
        ns2__CCAuthService *ccAuthService;
        /// Optional element 'ns2:octService' of XSD type 'ns2:OCTService'
        ns2__OCTService *octService;
        /// Optional element 'ns2:verificationService' of XSD type 'ns2:VerificationService'
        ns2__VerificationService *verificationService;
        /// Optional element 'ns2:ccSaleService' of XSD type 'ns2:CCSaleService'
        ns2__CCSaleService *ccSaleService;
        /// Optional element 'ns2:ccSaleCreditService' of XSD type 'ns2:CCSaleCreditService'
        ns2__CCSaleCreditService *ccSaleCreditService;
        /// Optional element 'ns2:ccSaleReversalService' of XSD type 'ns2:CCSaleReversalService'
        ns2__CCSaleReversalService *ccSaleReversalService;
        /// Optional element 'ns2:ccIncrementalAuthService' of XSD type 'ns2:CCIncrementalAuthService'
        ns2__CCIncrementalAuthService *ccIncrementalAuthService;
        /// Optional element 'ns2:ccCaptureService' of XSD type 'ns2:CCCaptureService'
        ns2__CCCaptureService *ccCaptureService;
        /// Optional element 'ns2:ccCreditService' of XSD type 'ns2:CCCreditService'
        ns2__CCCreditService *ccCreditService;
        /// Optional element 'ns2:ccAuthReversalService' of XSD type 'ns2:CCAuthReversalService'
        ns2__CCAuthReversalService *ccAuthReversalService;
        /// Optional element 'ns2:ccAutoAuthReversalService' of XSD type 'ns2:CCAutoAuthReversalService'
        ns2__CCAutoAuthReversalService *ccAutoAuthReversalService;
        /// Optional element 'ns2:ccDCCService' of XSD type 'ns2:CCDCCService'
        ns2__CCDCCService *ccDCCService;
        /// Optional element 'ns2:serviceFeeCalculateService' of XSD type 'ns2:ServiceFeeCalculateService'
        ns2__ServiceFeeCalculateService *serviceFeeCalculateService;
        /// Optional element 'ns2:ecDebitService' of XSD type 'ns2:ECDebitService'
        ns2__ECDebitService *ecDebitService;
        /// Optional element 'ns2:ecCreditService' of XSD type 'ns2:ECCreditService'
        ns2__ECCreditService *ecCreditService;
        /// Optional element 'ns2:ecAuthenticateService' of XSD type 'ns2:ECAuthenticateService'
        ns2__ECAuthenticateService *ecAuthenticateService;
        /// Optional element 'ns2:payerAuthEnrollService' of XSD type 'ns2:PayerAuthEnrollService'
        ns2__PayerAuthEnrollService *payerAuthEnrollService;
        /// Optional element 'ns2:payerAuthValidateService' of XSD type 'ns2:PayerAuthValidateService'
        ns2__PayerAuthValidateService *payerAuthValidateService;
        /// Optional element 'ns2:taxService' of XSD type 'ns2:TaxService'
        ns2__TaxService *taxService;
        /// Optional element 'ns2:dmeService' of XSD type 'ns2:DMEService'
        ns2__DMEService *dmeService;
        /// Optional element 'ns2:afsService' of XSD type 'ns2:AFSService'
        ns2__AFSService *afsService;
        /// Optional element 'ns2:davService' of XSD type 'ns2:DAVService'
        ns2__DAVService *davService;
        /// Optional element 'ns2:exportService' of XSD type 'ns2:ExportService'
        ns2__ExportService *exportService;
        /// Optional element 'ns2:fxRatesService' of XSD type 'ns2:FXRatesService'
        ns2__FXRatesService *fxRatesService;
        /// Optional element 'ns2:bankTransferService' of XSD type 'ns2:BankTransferService'
        ns2__BankTransferService *bankTransferService;
        /// Optional element 'ns2:bankTransferRefundService' of XSD type 'ns2:BankTransferRefundService'
        ns2__BankTransferRefundService *bankTransferRefundService;
        /// Optional element 'ns2:bankTransferRealTimeService' of XSD type 'ns2:BankTransferRealTimeService'
        ns2__BankTransferRealTimeService *bankTransferRealTimeService;
        /// Optional element 'ns2:directDebitMandateService' of XSD type 'ns2:DirectDebitMandateService'
        ns2__DirectDebitMandateService *directDebitMandateService;
        /// Optional element 'ns2:directDebitService' of XSD type 'ns2:DirectDebitService'
        ns2__DirectDebitService *directDebitService;
        /// Optional element 'ns2:directDebitRefundService' of XSD type 'ns2:DirectDebitRefundService'
        ns2__DirectDebitRefundService *directDebitRefundService;
        /// Optional element 'ns2:directDebitValidateService' of XSD type 'ns2:DirectDebitValidateService'
        ns2__DirectDebitValidateService *directDebitValidateService;
        /// Optional element 'ns2:paySubscriptionCreateService' of XSD type 'ns2:PaySubscriptionCreateService'
        ns2__PaySubscriptionCreateService *paySubscriptionCreateService;
        /// Optional element 'ns2:paySubscriptionUpdateService' of XSD type 'ns2:PaySubscriptionUpdateService'
        ns2__PaySubscriptionUpdateService *paySubscriptionUpdateService;
        /// Optional element 'ns2:paySubscriptionEventUpdateService' of XSD type 'ns2:PaySubscriptionEventUpdateService'
        ns2__PaySubscriptionEventUpdateService *paySubscriptionEventUpdateService;
        /// Optional element 'ns2:paySubscriptionRetrieveService' of XSD type 'ns2:PaySubscriptionRetrieveService'
        ns2__PaySubscriptionRetrieveService *paySubscriptionRetrieveService;
        /// Optional element 'ns2:paySubscriptionDeleteService' of XSD type 'ns2:PaySubscriptionDeleteService'
        ns2__PaySubscriptionDeleteService *paySubscriptionDeleteService;
        /// Optional element 'ns2:payPalPaymentService' of XSD type 'ns2:PayPalPaymentService'
        ns2__PayPalPaymentService *payPalPaymentService;
        /// Optional element 'ns2:payPalCreditService' of XSD type 'ns2:PayPalCreditService'
        ns2__PayPalCreditService *payPalCreditService;
        /// Optional element 'ns2:voidService' of XSD type 'ns2:VoidService'
        ns2__VoidService *voidService;
        /// Optional element 'ns2:businessRules' of XSD type 'ns2:BusinessRules'
        ns2__BusinessRules *businessRules;
        /// Optional element 'ns2:pinlessDebitService' of XSD type 'ns2:PinlessDebitService'
        ns2__PinlessDebitService *pinlessDebitService;
        /// Optional element 'ns2:pinlessDebitValidateService' of XSD type 'ns2:PinlessDebitValidateService'
        ns2__PinlessDebitValidateService *pinlessDebitValidateService;
        /// Optional element 'ns2:pinlessDebitReversalService' of XSD type 'ns2:PinlessDebitReversalService'
        ns2__PinlessDebitReversalService *pinlessDebitReversalService;
        /// Optional element 'ns2:batch' of XSD type 'ns2:Batch'
        ns2__Batch *batch;
        /// Optional element 'ns2:airlineData' of XSD type 'ns2:AirlineData'
        ns2__AirlineData *airlineData;
        /// Optional element 'ns2:ancillaryData' of XSD type 'ns2:AncillaryData'
        ns2__AncillaryData *ancillaryData;
        /// Optional element 'ns2:lodgingData' of XSD type 'ns2:LodgingData'
        ns2__LodgingData *lodgingData;
        /// Optional element 'ns2:payPalButtonCreateService' of XSD type 'ns2:PayPalButtonCreateService'
        ns2__PayPalButtonCreateService *payPalButtonCreateService;
        /// Optional element 'ns2:payPalPreapprovedPaymentService' of XSD type 'ns2:PayPalPreapprovedPaymentService'
        ns2__PayPalPreapprovedPaymentService *payPalPreapprovedPaymentService;
        /// Optional element 'ns2:payPalPreapprovedUpdateService' of XSD type 'ns2:PayPalPreapprovedUpdateService'
        ns2__PayPalPreapprovedUpdateService *payPalPreapprovedUpdateService;
        /// Optional element 'ns2:riskUpdateService' of XSD type 'ns2:RiskUpdateService'
        ns2__RiskUpdateService *riskUpdateService;
        /// Optional element 'ns2:fraudUpdateService' of XSD type 'ns2:FraudUpdateService'
        ns2__FraudUpdateService *fraudUpdateService;
        /// Optional element 'ns2:caseManagementActionService' of XSD type 'ns2:CaseManagementActionService'
        ns2__CaseManagementActionService *caseManagementActionService;
        /// Sequence of 0 to 999 elements 'ns2:reserved' of XSD type 'ns2:RequestReserved'
        std::vector<ns2__RequestReserved *> reserved;
        /// Optional element 'ns2:deviceFingerprintID' of XSD type 'xsd:string'
        std::string *deviceFingerprintID;
        /// Optional element 'ns2:deviceFingerprintRaw' of XSD type 'ns2:boolean'
        std::string *deviceFingerprintRaw;
        /// Optional element 'ns2:deviceFingerprintHash' of XSD type 'xsd:string'
        std::string *deviceFingerprintHash;
        /// Optional element 'ns2:payPalRefundService' of XSD type 'ns2:PayPalRefundService'
        ns2__PayPalRefundService *payPalRefundService;
        /// Optional element 'ns2:payPalAuthReversalService' of XSD type 'ns2:PayPalAuthReversalService'
        ns2__PayPalAuthReversalService *payPalAuthReversalService;
        /// Optional element 'ns2:payPalDoCaptureService' of XSD type 'ns2:PayPalDoCaptureService'
        ns2__PayPalDoCaptureService *payPalDoCaptureService;
        /// Optional element 'ns2:payPalEcDoPaymentService' of XSD type 'ns2:PayPalEcDoPaymentService'
        ns2__PayPalEcDoPaymentService *payPalEcDoPaymentService;
        /// Optional element 'ns2:payPalEcGetDetailsService' of XSD type 'ns2:PayPalEcGetDetailsService'
        ns2__PayPalEcGetDetailsService *payPalEcGetDetailsService;
        /// Optional element 'ns2:payPalEcSetService' of XSD type 'ns2:PayPalEcSetService'
        ns2__PayPalEcSetService *payPalEcSetService;
        /// Optional element 'ns2:payPalEcOrderSetupService' of XSD type 'ns2:PayPalEcOrderSetupService'
        ns2__PayPalEcOrderSetupService *payPalEcOrderSetupService;
        /// Optional element 'ns2:payPalAuthorizationService' of XSD type 'ns2:PayPalAuthorizationService'
        ns2__PayPalAuthorizationService *payPalAuthorizationService;
        /// Optional element 'ns2:payPalUpdateAgreementService' of XSD type 'ns2:PayPalUpdateAgreementService'
        ns2__PayPalUpdateAgreementService *payPalUpdateAgreementService;
        /// Optional element 'ns2:payPalCreateAgreementService' of XSD type 'ns2:PayPalCreateAgreementService'
        ns2__PayPalCreateAgreementService *payPalCreateAgreementService;
        /// Optional element 'ns2:payPalDoRefTransactionService' of XSD type 'ns2:PayPalDoRefTransactionService'
        ns2__PayPalDoRefTransactionService *payPalDoRefTransactionService;
        /// Optional element 'ns2:chinaPaymentService' of XSD type 'ns2:ChinaPaymentService'
        ns2__ChinaPaymentService *chinaPaymentService;
        /// Optional element 'ns2:chinaRefundService' of XSD type 'ns2:ChinaRefundService'
        ns2__ChinaRefundService *chinaRefundService;
        /// Optional element 'ns2:boletoPaymentService' of XSD type 'ns2:BoletoPaymentService'
        ns2__BoletoPaymentService *boletoPaymentService;
        /// Optional element 'ns2:apPaymentType' of XSD type 'xsd:string'
        std::string *apPaymentType;
        /// Optional element 'ns2:apInitiateService' of XSD type 'ns2:APInitiateService'
        ns2__APInitiateService *apInitiateService;
        /// Optional element 'ns2:apCheckStatusService' of XSD type 'ns2:APCheckStatusService'
        ns2__APCheckStatusService *apCheckStatusService;
        /// Optional element 'ns2:ignoreCardExpiration' of XSD type 'ns2:boolean'
        std::string *ignoreCardExpiration;
        /// Optional element 'ns2:reportGroup' of XSD type 'xsd:string'
        std::string *reportGroup;
        /// Optional element 'ns2:processorID' of XSD type 'xsd:string'
        std::string *processorID;
        /// Optional element 'ns2:thirdPartyCertificationNumber' of XSD type 'xsd:string'
        std::string *thirdPartyCertificationNumber;
        /// Optional element 'ns2:transactionLocalDateTime' of XSD type 'ns2:dateTime'
        std::string *transactionLocalDateTime;
        /// Optional element 'ns2:solutionProviderTransactionID' of XSD type 'xsd:string'
        std::string *solutionProviderTransactionID;
        /// Optional element 'ns2:surchargeAmount' of XSD type 'ns2:amount'
        std::string *surchargeAmount;
        /// Optional element 'ns2:surchargeSign' of XSD type 'xsd:string'
        std::string *surchargeSign;
        /// Optional element 'ns2:pinDataEncryptedPIN' of XSD type 'xsd:string'
        std::string *pinDataEncryptedPIN;
        /// Optional element 'ns2:pinDataKeySerialNumber' of XSD type 'xsd:string'
        std::string *pinDataKeySerialNumber;
        /// Optional element 'ns2:cashbackAmount' of XSD type 'ns2:amount'
        std::string *cashbackAmount;
        /// Optional element 'ns2:pinDebitPurchaseService' of XSD type 'ns2:PinDebitPurchaseService'
        ns2__PinDebitPurchaseService *pinDebitPurchaseService;
        /// Optional element 'ns2:pinDebitCreditService' of XSD type 'ns2:PinDebitCreditService'
        ns2__PinDebitCreditService *pinDebitCreditService;
        /// Optional element 'ns2:pinDebitReversalService' of XSD type 'ns2:PinDebitReversalService'
        ns2__PinDebitReversalService *pinDebitReversalService;
        /// Optional element 'ns2:ap' of XSD type 'ns2:AP'
        ns2__AP *ap;
        /// Optional element 'ns2:apAuthService' of XSD type 'ns2:APAuthService'
        ns2__APAuthService *apAuthService;
        /// Optional element 'ns2:apAuthReversalService' of XSD type 'ns2:APAuthReversalService'
        ns2__APAuthReversalService *apAuthReversalService;
        /// Optional element 'ns2:apCaptureService' of XSD type 'ns2:APCaptureService'
        ns2__APCaptureService *apCaptureService;
        /// Optional element 'ns2:apOptionsService' of XSD type 'ns2:APOptionsService'
        ns2__APOptionsService *apOptionsService;
        /// Optional element 'ns2:apRefundService' of XSD type 'ns2:APRefundService'
        ns2__APRefundService *apRefundService;
        /// Optional element 'ns2:apSaleService' of XSD type 'ns2:APSaleService'
        ns2__APSaleService *apSaleService;
        /// Optional element 'ns2:apCheckoutDetailsService' of XSD type 'ns2:APCheckOutDetailsService'
        ns2__APCheckOutDetailsService *apCheckoutDetailsService;
        /// Optional element 'ns2:apTransactionDetailsService' of XSD type 'ns2:APTransactionDetailsService'
        ns2__APTransactionDetailsService *apTransactionDetailsService;
        /// Optional element 'ns2:apConfirmPurchaseService' of XSD type 'ns2:APConfirmPurchaseService'
        ns2__APConfirmPurchaseService *apConfirmPurchaseService;
        /// Optional element 'ns2:payPalGetTxnDetailsService' of XSD type 'ns2:PayPalGetTxnDetailsService'
        ns2__PayPalGetTxnDetailsService *payPalGetTxnDetailsService;
        /// Optional element 'ns2:payPalTransactionSearchService' of XSD type 'ns2:PayPalTransactionSearchService'
        ns2__PayPalTransactionSearchService *payPalTransactionSearchService;
        /// Optional element 'ns2:ccDCCUpdateService' of XSD type 'ns2:CCDCCUpdateService'
        ns2__CCDCCUpdateService *ccDCCUpdateService;
        /// Optional element 'ns2:emvRequest' of XSD type 'ns2:EmvRequest'
        ns2__EmvRequest *emvRequest;
        /// Optional element 'ns2:merchantTransactionIdentifier' of XSD type 'xsd:string'
        std::string *merchantTransactionIdentifier;
        /// Optional element 'ns2:hostedDataCreateService' of XSD type 'ns2:HostedDataCreateService'
        ns2__HostedDataCreateService *hostedDataCreateService;
        /// Optional element 'ns2:hostedDataRetrieveService' of XSD type 'ns2:HostedDataRetrieveService'
        ns2__HostedDataRetrieveService *hostedDataRetrieveService;
        /// Optional element 'ns2:merchantCategoryCode' of XSD type 'xsd:string'
        std::string *merchantCategoryCode;
        /// Optional element 'ns2:salesSlipNumber' of XSD type 'xsd:string'
        std::string *salesSlipNumber;
        /// Optional element 'ns2:merchandiseCode' of XSD type 'xsd:string'
        std::string *merchandiseCode;
        /// Optional element 'ns2:merchandiseDescription' of XSD type 'xsd:string'
        std::string *merchandiseDescription;
        /// Optional element 'ns2:paymentInitiationChannel' of XSD type 'xsd:string'
        std::string *paymentInitiationChannel;
        /// Optional element 'ns2:extendedCreditTotalCount' of XSD type 'xsd:string'
        std::string *extendedCreditTotalCount;
        /// Optional element 'ns2:authIndicator' of XSD type 'xsd:string'
        std::string *authIndicator;
        /// Optional element 'ns2:paymentNetworkToken' of XSD type 'ns2:PaymentNetworkToken'
        ns2__PaymentNetworkToken *paymentNetworkToken;
        /// Optional element 'ns2:recipient' of XSD type 'ns2:Recipient'
        ns2__Recipient *recipient;
        /// Optional element 'ns2:sender' of XSD type 'ns2:Sender'
        ns2__Sender *sender;
        /// Optional element 'ns2:autoRentalData' of XSD type 'ns2:AutoRentalData'
        ns2__AutoRentalData *autoRentalData;
        /// Optional element 'ns2:paymentSolution' of XSD type 'xsd:string'
        std::string *paymentSolution;
        /// Optional element 'ns2:vc' of XSD type 'ns2:VC'
        ns2__VC *vc;
        /// Optional element 'ns2:decryptVisaCheckoutDataService' of XSD type 'ns2:DecryptVisaCheckoutDataService'
        ns2__DecryptVisaCheckoutDataService *decryptVisaCheckoutDataService;
        /// Optional element 'ns2:taxManagementIndicator' of XSD type 'xsd:string'
        std::string *taxManagementIndicator;
        /// Sequence of 0 to 100 elements 'ns2:promotionGroup' of XSD type 'ns2:PromotionGroup'
        std::vector<ns2__PromotionGroup *> promotionGroup;
        /// Optional element 'ns2:wallet' of XSD type 'ns2:Wallet'
        ns2__Wallet *wallet;
        /// Optional element 'ns2:aft' of XSD type 'ns2:Aft'
        ns2__Aft *aft;
        /// Optional element 'ns2:balanceInquiry' of XSD type 'ns2:boolean'
        std::string *balanceInquiry;
        /// Optional element 'ns2:prenoteTransaction' of XSD type 'ns2:boolean'
        std::string *prenoteTransaction;
        /// Optional element 'ns2:encryptPaymentDataService' of XSD type 'ns2:EncryptPaymentDataService'
        ns2__EncryptPaymentDataService *encryptPaymentDataService;
        /// Optional element 'ns2:nationalNetDomesticData' of XSD type 'xsd:string'
        std::string *nationalNetDomesticData;
        /// Optional element 'ns2:subsequentAuth' of XSD type 'xsd:string'
        std::string *subsequentAuth;
        /// Optional element 'ns2:binLookupService' of XSD type 'ns2:BinLookupService'
        ns2__BinLookupService *binLookupService;
        /// Optional element 'ns2:verificationCode' of XSD type 'xsd:string'
        std::string *verificationCode;
        /// Optional element 'ns2:mobileNumber' of XSD type 'xsd:string'
        std::string *mobileNumber;
        /// Optional element 'ns2:issuer' of XSD type 'ns2:issuer'
        ns2__issuer *issuer;
        /// Optional element 'ns2:partnerSolutionID' of XSD type 'xsd:string'
        std::string *partnerSolutionID;
        /// Optional element 'ns2:developerID' of XSD type 'xsd:string'
        std::string *developerID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__RequestMessage
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__RequestMessage; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__RequestMessage, default initialized and not managed by a soap context
        virtual ns2__RequestMessage *soap_alloc(void) const { return SOAP_NEW(ns2__RequestMessage); }
      public:
        /// Constructor with initializations
        ns2__RequestMessage()
        {
          merchantID = (std::string *)0;
          merchantReferenceCode = (std::string *)0;
          debtIndicator = (std::string *)0;
          clientLibrary = (std::string *)0;
          clientLibraryVersion = (std::string *)0;
          clientEnvironment = (std::string *)0;
          clientSecurityLibraryVersion = (std::string *)0;
          clientApplication = (std::string *)0;
          clientApplicationVersion = (std::string *)0;
          clientApplicationUser = (std::string *)0;
          routingCode = (std::string *)0;
          comments = (std::string *)0;
          returnURL = (std::string *)0;
          invoiceHeader = (ns2__InvoiceHeader *)0;
          aggregatorMerchantIdentifier = (std::string *)0;
          customerID = (std::string *)0;
          customerFirstName = (std::string *)0;
          customerLastName = (std::string *)0;
          billTo = (ns2__BillTo *)0;
          shipTo = (ns2__ShipTo *)0;
          personalId = (ns2__PersonalId *)0;
          shipFrom = (ns2__ShipFrom *)0;
          purchaseTotals = (ns2__PurchaseTotals *)0;
          fundingTotals = (ns2__FundingTotals *)0;
          dcc = (ns2__DCC *)0;
          pos = (ns2__Pos *)0;
          encryptedPayment = (ns2__EncryptedPayment *)0;
          installment = (ns2__Installment *)0;
          card = (ns2__Card *)0;
          check = (ns2__Check *)0;
          bml = (ns2__BML *)0;
          gecc = (ns2__GECC *)0;
          ucaf = (ns2__UCAF *)0;
          fundTransfer = (ns2__FundTransfer *)0;
          bankInfo = (ns2__BankInfo *)0;
          subscription = (ns2__Subscription *)0;
          recurringSubscriptionInfo = (ns2__RecurringSubscriptionInfo *)0;
          decisionManager = (ns2__DecisionManager *)0;
          otherTax = (ns2__OtherTax *)0;
          paypal = (ns2__PayPal *)0;
          merchantDefinedData = (ns2__MerchantDefinedData *)0;
          merchantSecureData = (ns2__MerchantSecureData *)0;
          jpo = (ns2__JPO *)0;
          orderRequestToken = (std::string *)0;
          linkToRequest = (std::string *)0;
          serviceFee = (ns2__ServiceFee *)0;
          ccAuthService = (ns2__CCAuthService *)0;
          octService = (ns2__OCTService *)0;
          verificationService = (ns2__VerificationService *)0;
          ccSaleService = (ns2__CCSaleService *)0;
          ccSaleCreditService = (ns2__CCSaleCreditService *)0;
          ccSaleReversalService = (ns2__CCSaleReversalService *)0;
          ccIncrementalAuthService = (ns2__CCIncrementalAuthService *)0;
          ccCaptureService = (ns2__CCCaptureService *)0;
          ccCreditService = (ns2__CCCreditService *)0;
          ccAuthReversalService = (ns2__CCAuthReversalService *)0;
          ccAutoAuthReversalService = (ns2__CCAutoAuthReversalService *)0;
          ccDCCService = (ns2__CCDCCService *)0;
          serviceFeeCalculateService = (ns2__ServiceFeeCalculateService *)0;
          ecDebitService = (ns2__ECDebitService *)0;
          ecCreditService = (ns2__ECCreditService *)0;
          ecAuthenticateService = (ns2__ECAuthenticateService *)0;
          payerAuthEnrollService = (ns2__PayerAuthEnrollService *)0;
          payerAuthValidateService = (ns2__PayerAuthValidateService *)0;
          taxService = (ns2__TaxService *)0;
          dmeService = (ns2__DMEService *)0;
          afsService = (ns2__AFSService *)0;
          davService = (ns2__DAVService *)0;
          exportService = (ns2__ExportService *)0;
          fxRatesService = (ns2__FXRatesService *)0;
          bankTransferService = (ns2__BankTransferService *)0;
          bankTransferRefundService = (ns2__BankTransferRefundService *)0;
          bankTransferRealTimeService = (ns2__BankTransferRealTimeService *)0;
          directDebitMandateService = (ns2__DirectDebitMandateService *)0;
          directDebitService = (ns2__DirectDebitService *)0;
          directDebitRefundService = (ns2__DirectDebitRefundService *)0;
          directDebitValidateService = (ns2__DirectDebitValidateService *)0;
          paySubscriptionCreateService = (ns2__PaySubscriptionCreateService *)0;
          paySubscriptionUpdateService = (ns2__PaySubscriptionUpdateService *)0;
          paySubscriptionEventUpdateService = (ns2__PaySubscriptionEventUpdateService *)0;
          paySubscriptionRetrieveService = (ns2__PaySubscriptionRetrieveService *)0;
          paySubscriptionDeleteService = (ns2__PaySubscriptionDeleteService *)0;
          payPalPaymentService = (ns2__PayPalPaymentService *)0;
          payPalCreditService = (ns2__PayPalCreditService *)0;
          voidService = (ns2__VoidService *)0;
          businessRules = (ns2__BusinessRules *)0;
          pinlessDebitService = (ns2__PinlessDebitService *)0;
          pinlessDebitValidateService = (ns2__PinlessDebitValidateService *)0;
          pinlessDebitReversalService = (ns2__PinlessDebitReversalService *)0;
          batch = (ns2__Batch *)0;
          airlineData = (ns2__AirlineData *)0;
          ancillaryData = (ns2__AncillaryData *)0;
          lodgingData = (ns2__LodgingData *)0;
          payPalButtonCreateService = (ns2__PayPalButtonCreateService *)0;
          payPalPreapprovedPaymentService = (ns2__PayPalPreapprovedPaymentService *)0;
          payPalPreapprovedUpdateService = (ns2__PayPalPreapprovedUpdateService *)0;
          riskUpdateService = (ns2__RiskUpdateService *)0;
          fraudUpdateService = (ns2__FraudUpdateService *)0;
          caseManagementActionService = (ns2__CaseManagementActionService *)0;
          deviceFingerprintID = (std::string *)0;
          deviceFingerprintRaw = (std::string *)0;
          deviceFingerprintHash = (std::string *)0;
          payPalRefundService = (ns2__PayPalRefundService *)0;
          payPalAuthReversalService = (ns2__PayPalAuthReversalService *)0;
          payPalDoCaptureService = (ns2__PayPalDoCaptureService *)0;
          payPalEcDoPaymentService = (ns2__PayPalEcDoPaymentService *)0;
          payPalEcGetDetailsService = (ns2__PayPalEcGetDetailsService *)0;
          payPalEcSetService = (ns2__PayPalEcSetService *)0;
          payPalEcOrderSetupService = (ns2__PayPalEcOrderSetupService *)0;
          payPalAuthorizationService = (ns2__PayPalAuthorizationService *)0;
          payPalUpdateAgreementService = (ns2__PayPalUpdateAgreementService *)0;
          payPalCreateAgreementService = (ns2__PayPalCreateAgreementService *)0;
          payPalDoRefTransactionService = (ns2__PayPalDoRefTransactionService *)0;
          chinaPaymentService = (ns2__ChinaPaymentService *)0;
          chinaRefundService = (ns2__ChinaRefundService *)0;
          boletoPaymentService = (ns2__BoletoPaymentService *)0;
          apPaymentType = (std::string *)0;
          apInitiateService = (ns2__APInitiateService *)0;
          apCheckStatusService = (ns2__APCheckStatusService *)0;
          ignoreCardExpiration = (std::string *)0;
          reportGroup = (std::string *)0;
          processorID = (std::string *)0;
          thirdPartyCertificationNumber = (std::string *)0;
          transactionLocalDateTime = (std::string *)0;
          solutionProviderTransactionID = (std::string *)0;
          surchargeAmount = (std::string *)0;
          surchargeSign = (std::string *)0;
          pinDataEncryptedPIN = (std::string *)0;
          pinDataKeySerialNumber = (std::string *)0;
          cashbackAmount = (std::string *)0;
          pinDebitPurchaseService = (ns2__PinDebitPurchaseService *)0;
          pinDebitCreditService = (ns2__PinDebitCreditService *)0;
          pinDebitReversalService = (ns2__PinDebitReversalService *)0;
          ap = (ns2__AP *)0;
          apAuthService = (ns2__APAuthService *)0;
          apAuthReversalService = (ns2__APAuthReversalService *)0;
          apCaptureService = (ns2__APCaptureService *)0;
          apOptionsService = (ns2__APOptionsService *)0;
          apRefundService = (ns2__APRefundService *)0;
          apSaleService = (ns2__APSaleService *)0;
          apCheckoutDetailsService = (ns2__APCheckOutDetailsService *)0;
          apTransactionDetailsService = (ns2__APTransactionDetailsService *)0;
          apConfirmPurchaseService = (ns2__APConfirmPurchaseService *)0;
          payPalGetTxnDetailsService = (ns2__PayPalGetTxnDetailsService *)0;
          payPalTransactionSearchService = (ns2__PayPalTransactionSearchService *)0;
          ccDCCUpdateService = (ns2__CCDCCUpdateService *)0;
          emvRequest = (ns2__EmvRequest *)0;
          merchantTransactionIdentifier = (std::string *)0;
          hostedDataCreateService = (ns2__HostedDataCreateService *)0;
          hostedDataRetrieveService = (ns2__HostedDataRetrieveService *)0;
          merchantCategoryCode = (std::string *)0;
          salesSlipNumber = (std::string *)0;
          merchandiseCode = (std::string *)0;
          merchandiseDescription = (std::string *)0;
          paymentInitiationChannel = (std::string *)0;
          extendedCreditTotalCount = (std::string *)0;
          authIndicator = (std::string *)0;
          paymentNetworkToken = (ns2__PaymentNetworkToken *)0;
          recipient = (ns2__Recipient *)0;
          sender = (ns2__Sender *)0;
          autoRentalData = (ns2__AutoRentalData *)0;
          paymentSolution = (std::string *)0;
          vc = (ns2__VC *)0;
          decryptVisaCheckoutDataService = (ns2__DecryptVisaCheckoutDataService *)0;
          taxManagementIndicator = (std::string *)0;
          wallet = (ns2__Wallet *)0;
          aft = (ns2__Aft *)0;
          balanceInquiry = (std::string *)0;
          prenoteTransaction = (std::string *)0;
          encryptPaymentDataService = (ns2__EncryptPaymentDataService *)0;
          nationalNetDomesticData = (std::string *)0;
          subsequentAuth = (std::string *)0;
          binLookupService = (ns2__BinLookupService *)0;
          verificationCode = (std::string *)0;
          mobileNumber = (std::string *)0;
          issuer = (ns2__issuer *)0;
          partnerSolutionID = (std::string *)0;
          developerID = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__RequestMessage() { }
        /// Friend allocator used by soap_new_ns2__RequestMessage(struct soap*, int)
        friend SOAP_FMAC1 ns2__RequestMessage * SOAP_FMAC2 soap_instantiate_ns2__RequestMessage(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:498 */
#ifndef SOAP_TYPE_ns2__VC
#define SOAP_TYPE_ns2__VC (225)
/* complex XSD type 'ns2:VC': */
class SOAP_CMAC ns2__VC {
      public:
        /// Optional element 'ns2:orderID' of XSD type 'xsd:string'
        std::string *orderID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__VC
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__VC; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__VC, default initialized and not managed by a soap context
        virtual ns2__VC *soap_alloc(void) const { return SOAP_NEW(ns2__VC); }
      public:
        /// Constructor with initializations
        ns2__VC()
        {
          orderID = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__VC() { }
        /// Friend allocator used by soap_new_ns2__VC(struct soap*, int)
        friend SOAP_FMAC1 ns2__VC * SOAP_FMAC2 soap_instantiate_ns2__VC(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:501 */
#ifndef SOAP_TYPE_ns2__DecryptVisaCheckoutDataService
#define SOAP_TYPE_ns2__DecryptVisaCheckoutDataService (226)
/* complex XSD type 'ns2:DecryptVisaCheckoutDataService': */
class SOAP_CMAC ns2__DecryptVisaCheckoutDataService {
      public:
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__DecryptVisaCheckoutDataService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__DecryptVisaCheckoutDataService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__DecryptVisaCheckoutDataService, default initialized and not managed by a soap context
        virtual ns2__DecryptVisaCheckoutDataService *soap_alloc(void) const { return SOAP_NEW(ns2__DecryptVisaCheckoutDataService); }
      public:
        /// Constructor with initializations
        ns2__DecryptVisaCheckoutDataService()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__DecryptVisaCheckoutDataService() { }
        /// Friend allocator used by soap_new_ns2__DecryptVisaCheckoutDataService(struct soap*, int)
        friend SOAP_FMAC1 ns2__DecryptVisaCheckoutDataService * SOAP_FMAC2 soap_instantiate_ns2__DecryptVisaCheckoutDataService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:504 */
#ifndef SOAP_TYPE_ns2__DCC
#define SOAP_TYPE_ns2__DCC (227)
/* complex XSD type 'ns2:DCC': */
class SOAP_CMAC ns2__DCC {
      public:
        /// Optional element 'ns2:dccIndicator' of XSD type 'xsd:integer'
        std::string *dccIndicator;
        /// Optional element 'ns2:referenceNumber' of XSD type 'xsd:string'
        std::string *referenceNumber;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__DCC
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__DCC; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__DCC, default initialized and not managed by a soap context
        virtual ns2__DCC *soap_alloc(void) const { return SOAP_NEW(ns2__DCC); }
      public:
        /// Constructor with initializations
        ns2__DCC()
        {
          dccIndicator = (std::string *)0;
          referenceNumber = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__DCC() { }
        /// Friend allocator used by soap_new_ns2__DCC(struct soap*, int)
        friend SOAP_FMAC1 ns2__DCC * SOAP_FMAC2 soap_instantiate_ns2__DCC(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:507 */
#ifndef SOAP_TYPE_ns2__Promotion
#define SOAP_TYPE_ns2__Promotion (228)
/* complex XSD type 'ns2:Promotion': */
class SOAP_CMAC ns2__Promotion {
      public:
        /// Optional element 'ns2:discountedAmount' of XSD type 'ns2:amount'
        std::string *discountedAmount;
        /// Optional element 'ns2:type' of XSD type 'xsd:string'
        std::string *type;
        /// Optional element 'ns2:code' of XSD type 'xsd:string'
        std::string *code;
        /// Optional element 'ns2:receiptData' of XSD type 'xsd:string'
        std::string *receiptData;
        /// Optional element 'ns2:discountApplied' of XSD type 'ns2:amount'
        std::string *discountApplied;
        /// Optional element 'ns2:description' of XSD type 'xsd:string'
        std::string *description;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Promotion
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__Promotion; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Promotion, default initialized and not managed by a soap context
        virtual ns2__Promotion *soap_alloc(void) const { return SOAP_NEW(ns2__Promotion); }
      public:
        /// Constructor with initializations
        ns2__Promotion()
        {
          discountedAmount = (std::string *)0;
          type = (std::string *)0;
          code = (std::string *)0;
          receiptData = (std::string *)0;
          discountApplied = (std::string *)0;
          description = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__Promotion() { }
        /// Friend allocator used by soap_new_ns2__Promotion(struct soap*, int)
        friend SOAP_FMAC1 ns2__Promotion * SOAP_FMAC2 soap_instantiate_ns2__Promotion(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:510 */
#ifndef SOAP_TYPE_ns2__PromotionGroup
#define SOAP_TYPE_ns2__PromotionGroup (229)
/* complex XSD type 'ns2:PromotionGroup': */
class SOAP_CMAC ns2__PromotionGroup {
      public:
        /// Optional element 'ns2:subtotalAmount' of XSD type 'ns2:amount'
        std::string *subtotalAmount;
        /// Optional element 'ns2:taxRate' of XSD type 'ns2:amount'
        std::string *taxRate;
        /// optional attribute 'id' of XSD type 'xsd:integer'
        std::string *id;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PromotionGroup
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PromotionGroup; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PromotionGroup, default initialized and not managed by a soap context
        virtual ns2__PromotionGroup *soap_alloc(void) const { return SOAP_NEW(ns2__PromotionGroup); }
      public:
        /// Constructor with initializations
        ns2__PromotionGroup()
        {
          subtotalAmount = (std::string *)0;
          taxRate = (std::string *)0;
          id = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PromotionGroup() { }
        /// Friend allocator used by soap_new_ns2__PromotionGroup(struct soap*, int)
        friend SOAP_FMAC1 ns2__PromotionGroup * SOAP_FMAC2 soap_instantiate_ns2__PromotionGroup(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:513 */
#ifndef SOAP_TYPE_ns2__PromotionGroupReply
#define SOAP_TYPE_ns2__PromotionGroupReply (230)
/* complex XSD type 'ns2:PromotionGroupReply': */
class SOAP_CMAC ns2__PromotionGroupReply {
      public:
        /// Optional element 'ns2:discountApplied' of XSD type 'ns2:amount'
        std::string *discountApplied;
        /// optional attribute 'id' of XSD type 'xsd:integer'
        std::string *id;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PromotionGroupReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PromotionGroupReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PromotionGroupReply, default initialized and not managed by a soap context
        virtual ns2__PromotionGroupReply *soap_alloc(void) const { return SOAP_NEW(ns2__PromotionGroupReply); }
      public:
        /// Constructor with initializations
        ns2__PromotionGroupReply()
        {
          discountApplied = (std::string *)0;
          id = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PromotionGroupReply() { }
        /// Friend allocator used by soap_new_ns2__PromotionGroupReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__PromotionGroupReply * SOAP_FMAC2 soap_instantiate_ns2__PromotionGroupReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:516 */
#ifndef SOAP_TYPE_ns2__CCAuthReply
#define SOAP_TYPE_ns2__CCAuthReply (231)
/* complex XSD type 'ns2:CCAuthReply': */
class SOAP_CMAC ns2__CCAuthReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:amount' of XSD type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:authorizationCode' of XSD type 'xsd:string'
        std::string *authorizationCode;
        /// Optional element 'ns2:avsCode' of XSD type 'xsd:string'
        std::string *avsCode;
        /// Optional element 'ns2:avsCodeRaw' of XSD type 'xsd:string'
        std::string *avsCodeRaw;
        /// Optional element 'ns2:cvCode' of XSD type 'xsd:string'
        std::string *cvCode;
        /// Optional element 'ns2:cvCodeRaw' of XSD type 'xsd:string'
        std::string *cvCodeRaw;
        /// Optional element 'ns2:personalIDCode' of XSD type 'xsd:string'
        std::string *personalIDCode;
        /// Optional element 'ns2:authorizedDateTime' of XSD type 'ns2:dateTime'
        std::string *authorizedDateTime;
        /// Optional element 'ns2:processorResponse' of XSD type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:bmlAccountNumber' of XSD type 'xsd:string'
        std::string *bmlAccountNumber;
        /// Optional element 'ns2:authFactorCode' of XSD type 'xsd:string'
        std::string *authFactorCode;
        /// Optional element 'ns2:reconciliationID' of XSD type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:fundingTotals' of XSD type 'ns2:FundingTotals'
        ns2__FundingTotals *fundingTotals;
        /// Optional element 'ns2:fxQuoteID' of XSD type 'xsd:string'
        std::string *fxQuoteID;
        /// Optional element 'ns2:fxQuoteRate' of XSD type 'ns2:dateTime'
        std::string *fxQuoteRate;
        /// Optional element 'ns2:fxQuoteType' of XSD type 'xsd:string'
        std::string *fxQuoteType;
        /// Optional element 'ns2:fxQuoteExpirationDateTime' of XSD type 'ns2:dateTime'
        std::string *fxQuoteExpirationDateTime;
        /// Optional element 'ns2:authRecord' of XSD type 'xsd:string'
        std::string *authRecord;
        /// Optional element 'ns2:merchantAdviceCode' of XSD type 'xsd:string'
        std::string *merchantAdviceCode;
        /// Optional element 'ns2:merchantAdviceCodeRaw' of XSD type 'xsd:string'
        std::string *merchantAdviceCodeRaw;
        /// Optional element 'ns2:cavvResponseCode' of XSD type 'xsd:string'
        std::string *cavvResponseCode;
        /// Optional element 'ns2:cavvResponseCodeRaw' of XSD type 'xsd:string'
        std::string *cavvResponseCodeRaw;
        /// Optional element 'ns2:authenticationXID' of XSD type 'xsd:string'
        std::string *authenticationXID;
        /// Optional element 'ns2:authorizationXID' of XSD type 'xsd:string'
        std::string *authorizationXID;
        /// Optional element 'ns2:processorCardType' of XSD type 'xsd:string'
        std::string *processorCardType;
        /// Optional element 'ns2:accountBalance' of XSD type 'ns2:amount'
        std::string *accountBalance;
        /// Optional element 'ns2:forwardCode' of XSD type 'xsd:string'
        std::string *forwardCode;
        /// Optional element 'ns2:enhancedDataEnabled' of XSD type 'xsd:string'
        std::string *enhancedDataEnabled;
        /// Optional element 'ns2:referralResponseNumber' of XSD type 'xsd:string'
        std::string *referralResponseNumber;
        /// Optional element 'ns2:subResponseCode' of XSD type 'xsd:string'
        std::string *subResponseCode;
        /// Optional element 'ns2:approvedAmount' of XSD type 'xsd:string'
        std::string *approvedAmount;
        /// Optional element 'ns2:creditLine' of XSD type 'xsd:string'
        std::string *creditLine;
        /// Optional element 'ns2:approvedTerms' of XSD type 'xsd:string'
        std::string *approvedTerms;
        /// Optional element 'ns2:paymentNetworkTransactionID' of XSD type 'xsd:string'
        std::string *paymentNetworkTransactionID;
        /// Optional element 'ns2:cardCategory' of XSD type 'xsd:string'
        std::string *cardCategory;
        /// Optional element 'ns2:ownerMerchantID' of XSD type 'xsd:string'
        std::string *ownerMerchantID;
        /// Optional element 'ns2:requestAmount' of XSD type 'ns2:amount'
        std::string *requestAmount;
        /// Optional element 'ns2:requestCurrency' of XSD type 'xsd:string'
        std::string *requestCurrency;
        /// Optional element 'ns2:accountBalanceCurrency' of XSD type 'xsd:string'
        std::string *accountBalanceCurrency;
        /// Optional element 'ns2:accountBalanceSign' of XSD type 'xsd:string'
        std::string *accountBalanceSign;
        /// Optional element 'ns2:amountType' of XSD type 'xsd:string'
        std::string *amountType;
        /// Optional element 'ns2:accountType' of XSD type 'xsd:string'
        std::string *accountType;
        /// Optional element 'ns2:affluenceIndicator' of XSD type 'xsd:string'
        std::string *affluenceIndicator;
        /// Optional element 'ns2:evEmail' of XSD type 'xsd:string'
        std::string *evEmail;
        /// Optional element 'ns2:evPhoneNumber' of XSD type 'xsd:string'
        std::string *evPhoneNumber;
        /// Optional element 'ns2:evPostalCode' of XSD type 'xsd:string'
        std::string *evPostalCode;
        /// Optional element 'ns2:evName' of XSD type 'xsd:string'
        std::string *evName;
        /// Optional element 'ns2:evStreet' of XSD type 'xsd:string'
        std::string *evStreet;
        /// Optional element 'ns2:evEmailRaw' of XSD type 'xsd:string'
        std::string *evEmailRaw;
        /// Optional element 'ns2:evPhoneNumberRaw' of XSD type 'xsd:string'
        std::string *evPhoneNumberRaw;
        /// Optional element 'ns2:evPostalCodeRaw' of XSD type 'xsd:string'
        std::string *evPostalCodeRaw;
        /// Optional element 'ns2:evNameRaw' of XSD type 'xsd:string'
        std::string *evNameRaw;
        /// Optional element 'ns2:evStreetRaw' of XSD type 'xsd:string'
        std::string *evStreetRaw;
        /// Optional element 'ns2:cardGroup' of XSD type 'xsd:string'
        std::string *cardGroup;
        /// Optional element 'ns2:posData' of XSD type 'xsd:string'
        std::string *posData;
        /// Optional element 'ns2:transactionID' of XSD type 'xsd:string'
        std::string *transactionID;
        /// Optional element 'ns2:cardIssuerCountry' of XSD type 'xsd:string'
        std::string *cardIssuerCountry;
        /// Optional element 'ns2:cardRegulated' of XSD type 'xsd:string'
        std::string *cardRegulated;
        /// Optional element 'ns2:cardCommercial' of XSD type 'xsd:string'
        std::string *cardCommercial;
        /// Optional element 'ns2:cardPrepaid' of XSD type 'xsd:string'
        std::string *cardPrepaid;
        /// Optional element 'ns2:cardPayroll' of XSD type 'xsd:string'
        std::string *cardPayroll;
        /// Optional element 'ns2:cardHealthcare' of XSD type 'xsd:string'
        std::string *cardHealthcare;
        /// Optional element 'ns2:cardSignatureDebit' of XSD type 'xsd:string'
        std::string *cardSignatureDebit;
        /// Optional element 'ns2:cardPINlessDebit' of XSD type 'xsd:string'
        std::string *cardPINlessDebit;
        /// Optional element 'ns2:cardLevel3Eligible' of XSD type 'xsd:string'
        std::string *cardLevel3Eligible;
        /// Optional element 'ns2:processorTransactionID' of XSD type 'xsd:string'
        std::string *processorTransactionID;
        /// Optional element 'ns2:providerReasonCode' of XSD type 'xsd:string'
        std::string *providerReasonCode;
        /// Optional element 'ns2:providerReasonDescription' of XSD type 'xsd:string'
        std::string *providerReasonDescription;
        /// Optional element 'ns2:providerPassThroughData' of XSD type 'xsd:string'
        std::string *providerPassThroughData;
        /// Optional element 'ns2:providerCVNResponseCode' of XSD type 'xsd:string'
        std::string *providerCVNResponseCode;
        /// Optional element 'ns2:providerAVSResponseCode' of XSD type 'xsd:string'
        std::string *providerAVSResponseCode;
        /// Optional element 'ns2:providerAcquirerBankCode' of XSD type 'xsd:string'
        std::string *providerAcquirerBankCode;
        /// Optional element 'ns2:paymentCardService' of XSD type 'xsd:string'
        std::string *paymentCardService;
        /// Optional element 'ns2:paymentCardServiceResult' of XSD type 'xsd:string'
        std::string *paymentCardServiceResult;
        /// Optional element 'ns2:transactionQualification' of XSD type 'xsd:string'
        std::string *transactionQualification;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__CCAuthReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__CCAuthReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__CCAuthReply, default initialized and not managed by a soap context
        virtual ns2__CCAuthReply *soap_alloc(void) const { return SOAP_NEW(ns2__CCAuthReply); }
      public:
        /// Constructor with initializations
        ns2__CCAuthReply()
        {
          amount = (std::string *)0;
          authorizationCode = (std::string *)0;
          avsCode = (std::string *)0;
          avsCodeRaw = (std::string *)0;
          cvCode = (std::string *)0;
          cvCodeRaw = (std::string *)0;
          personalIDCode = (std::string *)0;
          authorizedDateTime = (std::string *)0;
          processorResponse = (std::string *)0;
          bmlAccountNumber = (std::string *)0;
          authFactorCode = (std::string *)0;
          reconciliationID = (std::string *)0;
          fundingTotals = (ns2__FundingTotals *)0;
          fxQuoteID = (std::string *)0;
          fxQuoteRate = (std::string *)0;
          fxQuoteType = (std::string *)0;
          fxQuoteExpirationDateTime = (std::string *)0;
          authRecord = (std::string *)0;
          merchantAdviceCode = (std::string *)0;
          merchantAdviceCodeRaw = (std::string *)0;
          cavvResponseCode = (std::string *)0;
          cavvResponseCodeRaw = (std::string *)0;
          authenticationXID = (std::string *)0;
          authorizationXID = (std::string *)0;
          processorCardType = (std::string *)0;
          accountBalance = (std::string *)0;
          forwardCode = (std::string *)0;
          enhancedDataEnabled = (std::string *)0;
          referralResponseNumber = (std::string *)0;
          subResponseCode = (std::string *)0;
          approvedAmount = (std::string *)0;
          creditLine = (std::string *)0;
          approvedTerms = (std::string *)0;
          paymentNetworkTransactionID = (std::string *)0;
          cardCategory = (std::string *)0;
          ownerMerchantID = (std::string *)0;
          requestAmount = (std::string *)0;
          requestCurrency = (std::string *)0;
          accountBalanceCurrency = (std::string *)0;
          accountBalanceSign = (std::string *)0;
          amountType = (std::string *)0;
          accountType = (std::string *)0;
          affluenceIndicator = (std::string *)0;
          evEmail = (std::string *)0;
          evPhoneNumber = (std::string *)0;
          evPostalCode = (std::string *)0;
          evName = (std::string *)0;
          evStreet = (std::string *)0;
          evEmailRaw = (std::string *)0;
          evPhoneNumberRaw = (std::string *)0;
          evPostalCodeRaw = (std::string *)0;
          evNameRaw = (std::string *)0;
          evStreetRaw = (std::string *)0;
          cardGroup = (std::string *)0;
          posData = (std::string *)0;
          transactionID = (std::string *)0;
          cardIssuerCountry = (std::string *)0;
          cardRegulated = (std::string *)0;
          cardCommercial = (std::string *)0;
          cardPrepaid = (std::string *)0;
          cardPayroll = (std::string *)0;
          cardHealthcare = (std::string *)0;
          cardSignatureDebit = (std::string *)0;
          cardPINlessDebit = (std::string *)0;
          cardLevel3Eligible = (std::string *)0;
          processorTransactionID = (std::string *)0;
          providerReasonCode = (std::string *)0;
          providerReasonDescription = (std::string *)0;
          providerPassThroughData = (std::string *)0;
          providerCVNResponseCode = (std::string *)0;
          providerAVSResponseCode = (std::string *)0;
          providerAcquirerBankCode = (std::string *)0;
          paymentCardService = (std::string *)0;
          paymentCardServiceResult = (std::string *)0;
          transactionQualification = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__CCAuthReply() { }
        /// Friend allocator used by soap_new_ns2__CCAuthReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__CCAuthReply * SOAP_FMAC2 soap_instantiate_ns2__CCAuthReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:519 */
#ifndef SOAP_TYPE_ns2__OCTReply
#define SOAP_TYPE_ns2__OCTReply (232)
/* complex XSD type 'ns2:OCTReply': */
class SOAP_CMAC ns2__OCTReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:requestDateTime' of XSD type 'ns2:dateTime'
        std::string *requestDateTime;
        /// Optional element 'ns2:reconciliationID' of XSD type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:processorResponse' of XSD type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:approvalCode' of XSD type 'xsd:string'
        std::string *approvalCode;
        /// Optional element 'ns2:amount' of XSD type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:paymentNetworkTransactionID' of XSD type 'xsd:string'
        std::string *paymentNetworkTransactionID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__OCTReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__OCTReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__OCTReply, default initialized and not managed by a soap context
        virtual ns2__OCTReply *soap_alloc(void) const { return SOAP_NEW(ns2__OCTReply); }
      public:
        /// Constructor with initializations
        ns2__OCTReply()
        {
          requestDateTime = (std::string *)0;
          reconciliationID = (std::string *)0;
          processorResponse = (std::string *)0;
          approvalCode = (std::string *)0;
          amount = (std::string *)0;
          paymentNetworkTransactionID = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__OCTReply() { }
        /// Friend allocator used by soap_new_ns2__OCTReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__OCTReply * SOAP_FMAC2 soap_instantiate_ns2__OCTReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:522 */
#ifndef SOAP_TYPE_ns2__VerificationReply
#define SOAP_TYPE_ns2__VerificationReply (233)
/* complex XSD type 'ns2:VerificationReply': */
class SOAP_CMAC ns2__VerificationReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:processorTransactionID' of XSD type 'xsd:string'
        std::string *processorTransactionID;
        /// Optional element 'ns2:processorResponse' of XSD type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:verifiedDateTime' of XSD type 'xsd:string'
        std::string *verifiedDateTime;
        /// Optional element 'ns2:reconciliationID' of XSD type 'xsd:string'
        std::string *reconciliationID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__VerificationReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__VerificationReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__VerificationReply, default initialized and not managed by a soap context
        virtual ns2__VerificationReply *soap_alloc(void) const { return SOAP_NEW(ns2__VerificationReply); }
      public:
        /// Constructor with initializations
        ns2__VerificationReply()
        {
          processorTransactionID = (std::string *)0;
          processorResponse = (std::string *)0;
          verifiedDateTime = (std::string *)0;
          reconciliationID = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__VerificationReply() { }
        /// Friend allocator used by soap_new_ns2__VerificationReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__VerificationReply * SOAP_FMAC2 soap_instantiate_ns2__VerificationReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:525 */
#ifndef SOAP_TYPE_ns2__CCSaleReply
#define SOAP_TYPE_ns2__CCSaleReply (234)
/* complex XSD type 'ns2:CCSaleReply': */
class SOAP_CMAC ns2__CCSaleReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:amount' of XSD type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:authorizationCode' of XSD type 'xsd:string'
        std::string *authorizationCode;
        /// Optional element 'ns2:processorResponse' of XSD type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:avsCode' of XSD type 'xsd:string'
        std::string *avsCode;
        /// Optional element 'ns2:avsCodeRaw' of XSD type 'xsd:string'
        std::string *avsCodeRaw;
        /// Optional element 'ns2:cvCode' of XSD type 'xsd:string'
        std::string *cvCode;
        /// Optional element 'ns2:cvCodeRaw' of XSD type 'xsd:string'
        std::string *cvCodeRaw;
        /// Optional element 'ns2:cavvResponseCode' of XSD type 'xsd:string'
        std::string *cavvResponseCode;
        /// Optional element 'ns2:cavvResponseCodeRaw' of XSD type 'xsd:string'
        std::string *cavvResponseCodeRaw;
        /// Optional element 'ns2:cardGroup' of XSD type 'xsd:string'
        std::string *cardGroup;
        /// Optional element 'ns2:paymentNetworkTransactionID' of XSD type 'xsd:string'
        std::string *paymentNetworkTransactionID;
        /// Optional element 'ns2:cardCategory' of XSD type 'xsd:string'
        std::string *cardCategory;
        /// Optional element 'ns2:accountBalance' of XSD type 'ns2:amount'
        std::string *accountBalance;
        /// Optional element 'ns2:authorizedDateTime' of XSD type 'ns2:dateTime'
        std::string *authorizedDateTime;
        /// Optional element 'ns2:requestAmount' of XSD type 'ns2:amount'
        std::string *requestAmount;
        /// Optional element 'ns2:reconciliationID' of XSD type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:accountBalanceCurrency' of XSD type 'xsd:string'
        std::string *accountBalanceCurrency;
        /// Optional element 'ns2:accountBalanceSign' of XSD type 'xsd:string'
        std::string *accountBalanceSign;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__CCSaleReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__CCSaleReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__CCSaleReply, default initialized and not managed by a soap context
        virtual ns2__CCSaleReply *soap_alloc(void) const { return SOAP_NEW(ns2__CCSaleReply); }
      public:
        /// Constructor with initializations
        ns2__CCSaleReply()
        {
          amount = (std::string *)0;
          authorizationCode = (std::string *)0;
          processorResponse = (std::string *)0;
          avsCode = (std::string *)0;
          avsCodeRaw = (std::string *)0;
          cvCode = (std::string *)0;
          cvCodeRaw = (std::string *)0;
          cavvResponseCode = (std::string *)0;
          cavvResponseCodeRaw = (std::string *)0;
          cardGroup = (std::string *)0;
          paymentNetworkTransactionID = (std::string *)0;
          cardCategory = (std::string *)0;
          accountBalance = (std::string *)0;
          authorizedDateTime = (std::string *)0;
          requestAmount = (std::string *)0;
          reconciliationID = (std::string *)0;
          accountBalanceCurrency = (std::string *)0;
          accountBalanceSign = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__CCSaleReply() { }
        /// Friend allocator used by soap_new_ns2__CCSaleReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__CCSaleReply * SOAP_FMAC2 soap_instantiate_ns2__CCSaleReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:528 */
#ifndef SOAP_TYPE_ns2__CCSaleCreditReply
#define SOAP_TYPE_ns2__CCSaleCreditReply (235)
/* complex XSD type 'ns2:CCSaleCreditReply': */
class SOAP_CMAC ns2__CCSaleCreditReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:amount' of XSD type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:authorizationCode' of XSD type 'xsd:string'
        std::string *authorizationCode;
        /// Optional element 'ns2:processorResponse' of XSD type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:authorizedDateTime' of XSD type 'ns2:dateTime'
        std::string *authorizedDateTime;
        /// Optional element 'ns2:reconciliationID' of XSD type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:paymentNetworkTransactionID' of XSD type 'xsd:string'
        std::string *paymentNetworkTransactionID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__CCSaleCreditReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__CCSaleCreditReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__CCSaleCreditReply, default initialized and not managed by a soap context
        virtual ns2__CCSaleCreditReply *soap_alloc(void) const { return SOAP_NEW(ns2__CCSaleCreditReply); }
      public:
        /// Constructor with initializations
        ns2__CCSaleCreditReply()
        {
          amount = (std::string *)0;
          authorizationCode = (std::string *)0;
          processorResponse = (std::string *)0;
          authorizedDateTime = (std::string *)0;
          reconciliationID = (std::string *)0;
          paymentNetworkTransactionID = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__CCSaleCreditReply() { }
        /// Friend allocator used by soap_new_ns2__CCSaleCreditReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__CCSaleCreditReply * SOAP_FMAC2 soap_instantiate_ns2__CCSaleCreditReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:531 */
#ifndef SOAP_TYPE_ns2__CCSaleReversalReply
#define SOAP_TYPE_ns2__CCSaleReversalReply (236)
/* complex XSD type 'ns2:CCSaleReversalReply': */
class SOAP_CMAC ns2__CCSaleReversalReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:amount' of XSD type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:authorizationCode' of XSD type 'xsd:string'
        std::string *authorizationCode;
        /// Optional element 'ns2:processorResponse' of XSD type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:reconciliationID' of XSD type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:requestDateTime' of XSD type 'ns2:dateTime'
        std::string *requestDateTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__CCSaleReversalReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__CCSaleReversalReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__CCSaleReversalReply, default initialized and not managed by a soap context
        virtual ns2__CCSaleReversalReply *soap_alloc(void) const { return SOAP_NEW(ns2__CCSaleReversalReply); }
      public:
        /// Constructor with initializations
        ns2__CCSaleReversalReply()
        {
          amount = (std::string *)0;
          authorizationCode = (std::string *)0;
          processorResponse = (std::string *)0;
          reconciliationID = (std::string *)0;
          requestDateTime = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__CCSaleReversalReply() { }
        /// Friend allocator used by soap_new_ns2__CCSaleReversalReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__CCSaleReversalReply * SOAP_FMAC2 soap_instantiate_ns2__CCSaleReversalReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:534 */
#ifndef SOAP_TYPE_ns2__CCIncrementalAuthReply
#define SOAP_TYPE_ns2__CCIncrementalAuthReply (237)
/* complex XSD type 'ns2:CCIncrementalAuthReply': */
class SOAP_CMAC ns2__CCIncrementalAuthReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:amount' of XSD type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:authorizationCode' of XSD type 'xsd:string'
        std::string *authorizationCode;
        /// Optional element 'ns2:processorResponse' of XSD type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:authorizedDateTime' of XSD type 'ns2:dateTime'
        std::string *authorizedDateTime;
        /// Optional element 'ns2:reconciliationID' of XSD type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:paymentNetworkTransactionID' of XSD type 'xsd:string'
        std::string *paymentNetworkTransactionID;
        /// Optional element 'ns2:cardCategory' of XSD type 'xsd:string'
        std::string *cardCategory;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__CCIncrementalAuthReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__CCIncrementalAuthReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__CCIncrementalAuthReply, default initialized and not managed by a soap context
        virtual ns2__CCIncrementalAuthReply *soap_alloc(void) const { return SOAP_NEW(ns2__CCIncrementalAuthReply); }
      public:
        /// Constructor with initializations
        ns2__CCIncrementalAuthReply()
        {
          amount = (std::string *)0;
          authorizationCode = (std::string *)0;
          processorResponse = (std::string *)0;
          authorizedDateTime = (std::string *)0;
          reconciliationID = (std::string *)0;
          paymentNetworkTransactionID = (std::string *)0;
          cardCategory = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__CCIncrementalAuthReply() { }
        /// Friend allocator used by soap_new_ns2__CCIncrementalAuthReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__CCIncrementalAuthReply * SOAP_FMAC2 soap_instantiate_ns2__CCIncrementalAuthReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:537 */
#ifndef SOAP_TYPE_ns2__CCCaptureReply
#define SOAP_TYPE_ns2__CCCaptureReply (238)
/* complex XSD type 'ns2:CCCaptureReply': */
class SOAP_CMAC ns2__CCCaptureReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:requestDateTime' of XSD type 'ns2:dateTime'
        std::string *requestDateTime;
        /// Optional element 'ns2:amount' of XSD type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:reconciliationID' of XSD type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:fundingTotals' of XSD type 'ns2:FundingTotals'
        ns2__FundingTotals *fundingTotals;
        /// Optional element 'ns2:fxQuoteID' of XSD type 'xsd:string'
        std::string *fxQuoteID;
        /// Optional element 'ns2:fxQuoteRate' of XSD type 'ns2:dateTime'
        std::string *fxQuoteRate;
        /// Optional element 'ns2:fxQuoteType' of XSD type 'xsd:string'
        std::string *fxQuoteType;
        /// Optional element 'ns2:fxQuoteExpirationDateTime' of XSD type 'ns2:dateTime'
        std::string *fxQuoteExpirationDateTime;
        /// Optional element 'ns2:purchasingLevel3Enabled' of XSD type 'xsd:string'
        std::string *purchasingLevel3Enabled;
        /// Optional element 'ns2:enhancedDataEnabled' of XSD type 'xsd:string'
        std::string *enhancedDataEnabled;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__CCCaptureReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__CCCaptureReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__CCCaptureReply, default initialized and not managed by a soap context
        virtual ns2__CCCaptureReply *soap_alloc(void) const { return SOAP_NEW(ns2__CCCaptureReply); }
      public:
        /// Constructor with initializations
        ns2__CCCaptureReply()
        {
          requestDateTime = (std::string *)0;
          amount = (std::string *)0;
          reconciliationID = (std::string *)0;
          fundingTotals = (ns2__FundingTotals *)0;
          fxQuoteID = (std::string *)0;
          fxQuoteRate = (std::string *)0;
          fxQuoteType = (std::string *)0;
          fxQuoteExpirationDateTime = (std::string *)0;
          purchasingLevel3Enabled = (std::string *)0;
          enhancedDataEnabled = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__CCCaptureReply() { }
        /// Friend allocator used by soap_new_ns2__CCCaptureReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__CCCaptureReply * SOAP_FMAC2 soap_instantiate_ns2__CCCaptureReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:540 */
#ifndef SOAP_TYPE_ns2__ServiceFeeCalculateReply
#define SOAP_TYPE_ns2__ServiceFeeCalculateReply (239)
/* complex XSD type 'ns2:ServiceFeeCalculateReply': */
class SOAP_CMAC ns2__ServiceFeeCalculateReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:amount' of XSD type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:requestDateTime' of XSD type 'ns2:dateTime'
        std::string *requestDateTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ServiceFeeCalculateReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ServiceFeeCalculateReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ServiceFeeCalculateReply, default initialized and not managed by a soap context
        virtual ns2__ServiceFeeCalculateReply *soap_alloc(void) const { return SOAP_NEW(ns2__ServiceFeeCalculateReply); }
      public:
        /// Constructor with initializations
        ns2__ServiceFeeCalculateReply()
        {
          amount = (std::string *)0;
          requestDateTime = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__ServiceFeeCalculateReply() { }
        /// Friend allocator used by soap_new_ns2__ServiceFeeCalculateReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__ServiceFeeCalculateReply * SOAP_FMAC2 soap_instantiate_ns2__ServiceFeeCalculateReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:543 */
#ifndef SOAP_TYPE_ns2__CCCreditReply
#define SOAP_TYPE_ns2__CCCreditReply (240)
/* complex XSD type 'ns2:CCCreditReply': */
class SOAP_CMAC ns2__CCCreditReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:requestDateTime' of XSD type 'ns2:dateTime'
        std::string *requestDateTime;
        /// Optional element 'ns2:amount' of XSD type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:reconciliationID' of XSD type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:purchasingLevel3Enabled' of XSD type 'xsd:string'
        std::string *purchasingLevel3Enabled;
        /// Optional element 'ns2:enhancedDataEnabled' of XSD type 'xsd:string'
        std::string *enhancedDataEnabled;
        /// Optional element 'ns2:authorizationXID' of XSD type 'xsd:string'
        std::string *authorizationXID;
        /// Optional element 'ns2:forwardCode' of XSD type 'xsd:string'
        std::string *forwardCode;
        /// Optional element 'ns2:ownerMerchantID' of XSD type 'xsd:string'
        std::string *ownerMerchantID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__CCCreditReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__CCCreditReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__CCCreditReply, default initialized and not managed by a soap context
        virtual ns2__CCCreditReply *soap_alloc(void) const { return SOAP_NEW(ns2__CCCreditReply); }
      public:
        /// Constructor with initializations
        ns2__CCCreditReply()
        {
          requestDateTime = (std::string *)0;
          amount = (std::string *)0;
          reconciliationID = (std::string *)0;
          purchasingLevel3Enabled = (std::string *)0;
          enhancedDataEnabled = (std::string *)0;
          authorizationXID = (std::string *)0;
          forwardCode = (std::string *)0;
          ownerMerchantID = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__CCCreditReply() { }
        /// Friend allocator used by soap_new_ns2__CCCreditReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__CCCreditReply * SOAP_FMAC2 soap_instantiate_ns2__CCCreditReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:546 */
#ifndef SOAP_TYPE_ns2__PinDebitPurchaseReply
#define SOAP_TYPE_ns2__PinDebitPurchaseReply (241)
/* complex XSD type 'ns2:PinDebitPurchaseReply': */
class SOAP_CMAC ns2__PinDebitPurchaseReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:processorResponse' of XSD type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:authorizationCode' of XSD type 'xsd:string'
        std::string *authorizationCode;
        /// Optional element 'ns2:reconciliationID' of XSD type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:networkCode' of XSD type 'xsd:string'
        std::string *networkCode;
        /// Optional element 'ns2:transactionID' of XSD type 'xsd:string'
        std::string *transactionID;
        /// Optional element 'ns2:requestAmount' of XSD type 'ns2:amount'
        std::string *requestAmount;
        /// Optional element 'ns2:requestCurrency' of XSD type 'xsd:string'
        std::string *requestCurrency;
        /// Optional element 'ns2:amount' of XSD type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:dateTime' of XSD type 'ns2:dateTime'
        std::string *dateTime;
        /// Optional element 'ns2:accountType' of XSD type 'xsd:string'
        std::string *accountType;
        /// Optional element 'ns2:amountType' of XSD type 'xsd:string'
        std::string *amountType;
        /// Optional element 'ns2:accountBalance' of XSD type 'xsd:string'
        std::string *accountBalance;
        /// Optional element 'ns2:accountBalanceCurrency' of XSD type 'xsd:string'
        std::string *accountBalanceCurrency;
        /// Optional element 'ns2:accountBalanceSign' of XSD type 'xsd:string'
        std::string *accountBalanceSign;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PinDebitPurchaseReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PinDebitPurchaseReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PinDebitPurchaseReply, default initialized and not managed by a soap context
        virtual ns2__PinDebitPurchaseReply *soap_alloc(void) const { return SOAP_NEW(ns2__PinDebitPurchaseReply); }
      public:
        /// Constructor with initializations
        ns2__PinDebitPurchaseReply()
        {
          processorResponse = (std::string *)0;
          authorizationCode = (std::string *)0;
          reconciliationID = (std::string *)0;
          networkCode = (std::string *)0;
          transactionID = (std::string *)0;
          requestAmount = (std::string *)0;
          requestCurrency = (std::string *)0;
          amount = (std::string *)0;
          dateTime = (std::string *)0;
          accountType = (std::string *)0;
          amountType = (std::string *)0;
          accountBalance = (std::string *)0;
          accountBalanceCurrency = (std::string *)0;
          accountBalanceSign = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PinDebitPurchaseReply() { }
        /// Friend allocator used by soap_new_ns2__PinDebitPurchaseReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__PinDebitPurchaseReply * SOAP_FMAC2 soap_instantiate_ns2__PinDebitPurchaseReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:549 */
#ifndef SOAP_TYPE_ns2__PinDebitCreditReply
#define SOAP_TYPE_ns2__PinDebitCreditReply (242)
/* complex XSD type 'ns2:PinDebitCreditReply': */
class SOAP_CMAC ns2__PinDebitCreditReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:processorResponse' of XSD type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:authorizationCode' of XSD type 'xsd:string'
        std::string *authorizationCode;
        /// Optional element 'ns2:reconciliationID' of XSD type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:networkCode' of XSD type 'xsd:string'
        std::string *networkCode;
        /// Optional element 'ns2:transactionID' of XSD type 'xsd:string'
        std::string *transactionID;
        /// Optional element 'ns2:amount' of XSD type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:dateTime' of XSD type 'ns2:dateTime'
        std::string *dateTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PinDebitCreditReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PinDebitCreditReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PinDebitCreditReply, default initialized and not managed by a soap context
        virtual ns2__PinDebitCreditReply *soap_alloc(void) const { return SOAP_NEW(ns2__PinDebitCreditReply); }
      public:
        /// Constructor with initializations
        ns2__PinDebitCreditReply()
        {
          processorResponse = (std::string *)0;
          authorizationCode = (std::string *)0;
          reconciliationID = (std::string *)0;
          networkCode = (std::string *)0;
          transactionID = (std::string *)0;
          amount = (std::string *)0;
          dateTime = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PinDebitCreditReply() { }
        /// Friend allocator used by soap_new_ns2__PinDebitCreditReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__PinDebitCreditReply * SOAP_FMAC2 soap_instantiate_ns2__PinDebitCreditReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:552 */
#ifndef SOAP_TYPE_ns2__PinDebitReversalReply
#define SOAP_TYPE_ns2__PinDebitReversalReply (243)
/* complex XSD type 'ns2:PinDebitReversalReply': */
class SOAP_CMAC ns2__PinDebitReversalReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:processorResponse' of XSD type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:reconciliationID' of XSD type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:amount' of XSD type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:dateTime' of XSD type 'ns2:dateTime'
        std::string *dateTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PinDebitReversalReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PinDebitReversalReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PinDebitReversalReply, default initialized and not managed by a soap context
        virtual ns2__PinDebitReversalReply *soap_alloc(void) const { return SOAP_NEW(ns2__PinDebitReversalReply); }
      public:
        /// Constructor with initializations
        ns2__PinDebitReversalReply()
        {
          processorResponse = (std::string *)0;
          reconciliationID = (std::string *)0;
          amount = (std::string *)0;
          dateTime = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PinDebitReversalReply() { }
        /// Friend allocator used by soap_new_ns2__PinDebitReversalReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__PinDebitReversalReply * SOAP_FMAC2 soap_instantiate_ns2__PinDebitReversalReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:555 */
#ifndef SOAP_TYPE_ns2__CCAuthReversalReply
#define SOAP_TYPE_ns2__CCAuthReversalReply (244)
/* complex XSD type 'ns2:CCAuthReversalReply': */
class SOAP_CMAC ns2__CCAuthReversalReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:amount' of XSD type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:authorizationCode' of XSD type 'xsd:string'
        std::string *authorizationCode;
        /// Optional element 'ns2:processorResponse' of XSD type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:requestDateTime' of XSD type 'ns2:dateTime'
        std::string *requestDateTime;
        /// Optional element 'ns2:forwardCode' of XSD type 'xsd:string'
        std::string *forwardCode;
        /// Optional element 'ns2:reconciliationID' of XSD type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:processorTransactionID' of XSD type 'xsd:string'
        std::string *processorTransactionID;
        /// Optional element 'ns2:paymentCardService' of XSD type 'xsd:string'
        std::string *paymentCardService;
        /// Optional element 'ns2:paymentCardServiceResult' of XSD type 'xsd:string'
        std::string *paymentCardServiceResult;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__CCAuthReversalReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__CCAuthReversalReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__CCAuthReversalReply, default initialized and not managed by a soap context
        virtual ns2__CCAuthReversalReply *soap_alloc(void) const { return SOAP_NEW(ns2__CCAuthReversalReply); }
      public:
        /// Constructor with initializations
        ns2__CCAuthReversalReply()
        {
          amount = (std::string *)0;
          authorizationCode = (std::string *)0;
          processorResponse = (std::string *)0;
          requestDateTime = (std::string *)0;
          forwardCode = (std::string *)0;
          reconciliationID = (std::string *)0;
          processorTransactionID = (std::string *)0;
          paymentCardService = (std::string *)0;
          paymentCardServiceResult = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__CCAuthReversalReply() { }
        /// Friend allocator used by soap_new_ns2__CCAuthReversalReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__CCAuthReversalReply * SOAP_FMAC2 soap_instantiate_ns2__CCAuthReversalReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:558 */
#ifndef SOAP_TYPE_ns2__CCAutoAuthReversalReply
#define SOAP_TYPE_ns2__CCAutoAuthReversalReply (245)
/* complex XSD type 'ns2:CCAutoAuthReversalReply': */
class SOAP_CMAC ns2__CCAutoAuthReversalReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:processorResponse' of XSD type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:result' of XSD type 'xsd:string'
        std::string *result;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__CCAutoAuthReversalReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__CCAutoAuthReversalReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__CCAutoAuthReversalReply, default initialized and not managed by a soap context
        virtual ns2__CCAutoAuthReversalReply *soap_alloc(void) const { return SOAP_NEW(ns2__CCAutoAuthReversalReply); }
      public:
        /// Constructor with initializations
        ns2__CCAutoAuthReversalReply()
        {
          processorResponse = (std::string *)0;
          result = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__CCAutoAuthReversalReply() { }
        /// Friend allocator used by soap_new_ns2__CCAutoAuthReversalReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__CCAutoAuthReversalReply * SOAP_FMAC2 soap_instantiate_ns2__CCAutoAuthReversalReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:561 */
#ifndef SOAP_TYPE_ns2__ECDebitReply
#define SOAP_TYPE_ns2__ECDebitReply (246)
/* complex XSD type 'ns2:ECDebitReply': */
class SOAP_CMAC ns2__ECDebitReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:settlementMethod' of XSD type 'xsd:string'
        std::string *settlementMethod;
        /// Optional element 'ns2:requestDateTime' of XSD type 'ns2:dateTime'
        std::string *requestDateTime;
        /// Optional element 'ns2:amount' of XSD type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:verificationLevel' of XSD type 'xsd:integer'
        std::string *verificationLevel;
        /// Optional element 'ns2:processorTransactionID' of XSD type 'xsd:string'
        std::string *processorTransactionID;
        /// Optional element 'ns2:reconciliationID' of XSD type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:processorResponse' of XSD type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:avsCode' of XSD type 'xsd:string'
        std::string *avsCode;
        /// Optional element 'ns2:avsCodeRaw' of XSD type 'xsd:string'
        std::string *avsCodeRaw;
        /// Optional element 'ns2:verificationCode' of XSD type 'xsd:string'
        std::string *verificationCode;
        /// Optional element 'ns2:verificationCodeRaw' of XSD type 'xsd:string'
        std::string *verificationCodeRaw;
        /// Optional element 'ns2:correctedAccountNumber' of XSD type 'xsd:string'
        std::string *correctedAccountNumber;
        /// Optional element 'ns2:correctedRoutingNumber' of XSD type 'xsd:string'
        std::string *correctedRoutingNumber;
        /// Optional element 'ns2:ownerMerchantID' of XSD type 'xsd:string'
        std::string *ownerMerchantID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ECDebitReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ECDebitReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ECDebitReply, default initialized and not managed by a soap context
        virtual ns2__ECDebitReply *soap_alloc(void) const { return SOAP_NEW(ns2__ECDebitReply); }
      public:
        /// Constructor with initializations
        ns2__ECDebitReply()
        {
          settlementMethod = (std::string *)0;
          requestDateTime = (std::string *)0;
          amount = (std::string *)0;
          verificationLevel = (std::string *)0;
          processorTransactionID = (std::string *)0;
          reconciliationID = (std::string *)0;
          processorResponse = (std::string *)0;
          avsCode = (std::string *)0;
          avsCodeRaw = (std::string *)0;
          verificationCode = (std::string *)0;
          verificationCodeRaw = (std::string *)0;
          correctedAccountNumber = (std::string *)0;
          correctedRoutingNumber = (std::string *)0;
          ownerMerchantID = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__ECDebitReply() { }
        /// Friend allocator used by soap_new_ns2__ECDebitReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__ECDebitReply * SOAP_FMAC2 soap_instantiate_ns2__ECDebitReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:564 */
#ifndef SOAP_TYPE_ns2__ECCreditReply
#define SOAP_TYPE_ns2__ECCreditReply (247)
/* complex XSD type 'ns2:ECCreditReply': */
class SOAP_CMAC ns2__ECCreditReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:settlementMethod' of XSD type 'xsd:string'
        std::string *settlementMethod;
        /// Optional element 'ns2:requestDateTime' of XSD type 'ns2:dateTime'
        std::string *requestDateTime;
        /// Optional element 'ns2:amount' of XSD type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:processorTransactionID' of XSD type 'xsd:string'
        std::string *processorTransactionID;
        /// Optional element 'ns2:reconciliationID' of XSD type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:processorResponse' of XSD type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:verificationCode' of XSD type 'xsd:string'
        std::string *verificationCode;
        /// Optional element 'ns2:verificationCodeRaw' of XSD type 'xsd:string'
        std::string *verificationCodeRaw;
        /// Optional element 'ns2:correctedAccountNumber' of XSD type 'xsd:string'
        std::string *correctedAccountNumber;
        /// Optional element 'ns2:correctedRoutingNumber' of XSD type 'xsd:string'
        std::string *correctedRoutingNumber;
        /// Optional element 'ns2:ownerMerchantID' of XSD type 'xsd:string'
        std::string *ownerMerchantID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ECCreditReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ECCreditReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ECCreditReply, default initialized and not managed by a soap context
        virtual ns2__ECCreditReply *soap_alloc(void) const { return SOAP_NEW(ns2__ECCreditReply); }
      public:
        /// Constructor with initializations
        ns2__ECCreditReply()
        {
          settlementMethod = (std::string *)0;
          requestDateTime = (std::string *)0;
          amount = (std::string *)0;
          processorTransactionID = (std::string *)0;
          reconciliationID = (std::string *)0;
          processorResponse = (std::string *)0;
          verificationCode = (std::string *)0;
          verificationCodeRaw = (std::string *)0;
          correctedAccountNumber = (std::string *)0;
          correctedRoutingNumber = (std::string *)0;
          ownerMerchantID = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__ECCreditReply() { }
        /// Friend allocator used by soap_new_ns2__ECCreditReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__ECCreditReply * SOAP_FMAC2 soap_instantiate_ns2__ECCreditReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:567 */
#ifndef SOAP_TYPE_ns2__ECAuthenticateReply
#define SOAP_TYPE_ns2__ECAuthenticateReply (248)
/* complex XSD type 'ns2:ECAuthenticateReply': */
class SOAP_CMAC ns2__ECAuthenticateReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:requestDateTime' of XSD type 'ns2:dateTime'
        std::string *requestDateTime;
        /// Optional element 'ns2:processorResponse' of XSD type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:reconciliationID' of XSD type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:checkpointSummary' of XSD type 'xsd:string'
        std::string *checkpointSummary;
        /// Optional element 'ns2:fraudShieldIndicators' of XSD type 'xsd:string'
        std::string *fraudShieldIndicators;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ECAuthenticateReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ECAuthenticateReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ECAuthenticateReply, default initialized and not managed by a soap context
        virtual ns2__ECAuthenticateReply *soap_alloc(void) const { return SOAP_NEW(ns2__ECAuthenticateReply); }
      public:
        /// Constructor with initializations
        ns2__ECAuthenticateReply()
        {
          requestDateTime = (std::string *)0;
          processorResponse = (std::string *)0;
          reconciliationID = (std::string *)0;
          checkpointSummary = (std::string *)0;
          fraudShieldIndicators = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__ECAuthenticateReply() { }
        /// Friend allocator used by soap_new_ns2__ECAuthenticateReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__ECAuthenticateReply * SOAP_FMAC2 soap_instantiate_ns2__ECAuthenticateReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:570 */
#ifndef SOAP_TYPE_ns2__PayerAuthEnrollReply
#define SOAP_TYPE_ns2__PayerAuthEnrollReply (249)
/* complex XSD type 'ns2:PayerAuthEnrollReply': */
class SOAP_CMAC ns2__PayerAuthEnrollReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:acsURL' of XSD type 'xsd:string'
        std::string *acsURL;
        /// Optional element 'ns2:commerceIndicator' of XSD type 'xsd:string'
        std::string *commerceIndicator;
        /// Optional element 'ns2:eci' of XSD type 'xsd:string'
        std::string *eci;
        /// Optional element 'ns2:paReq' of XSD type 'xsd:string'
        std::string *paReq;
        /// Optional element 'ns2:proxyPAN' of XSD type 'xsd:string'
        std::string *proxyPAN;
        /// Optional element 'ns2:xid' of XSD type 'xsd:string'
        std::string *xid;
        /// Optional element 'ns2:proofXML' of XSD type 'xsd:string'
        std::string *proofXML;
        /// Optional element 'ns2:ucafCollectionIndicator' of XSD type 'xsd:string'
        std::string *ucafCollectionIndicator;
        /// Optional element 'ns2:veresEnrolled' of XSD type 'xsd:string'
        std::string *veresEnrolled;
        /// Optional element 'ns2:authenticationPath' of XSD type 'xsd:string'
        std::string *authenticationPath;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayerAuthEnrollReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PayerAuthEnrollReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayerAuthEnrollReply, default initialized and not managed by a soap context
        virtual ns2__PayerAuthEnrollReply *soap_alloc(void) const { return SOAP_NEW(ns2__PayerAuthEnrollReply); }
      public:
        /// Constructor with initializations
        ns2__PayerAuthEnrollReply()
        {
          acsURL = (std::string *)0;
          commerceIndicator = (std::string *)0;
          eci = (std::string *)0;
          paReq = (std::string *)0;
          proxyPAN = (std::string *)0;
          xid = (std::string *)0;
          proofXML = (std::string *)0;
          ucafCollectionIndicator = (std::string *)0;
          veresEnrolled = (std::string *)0;
          authenticationPath = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PayerAuthEnrollReply() { }
        /// Friend allocator used by soap_new_ns2__PayerAuthEnrollReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayerAuthEnrollReply * SOAP_FMAC2 soap_instantiate_ns2__PayerAuthEnrollReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:573 */
#ifndef SOAP_TYPE_ns2__PayerAuthValidateReply
#define SOAP_TYPE_ns2__PayerAuthValidateReply (250)
/* complex XSD type 'ns2:PayerAuthValidateReply': */
class SOAP_CMAC ns2__PayerAuthValidateReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:authenticationResult' of XSD type 'xsd:string'
        std::string *authenticationResult;
        /// Optional element 'ns2:authenticationStatusMessage' of XSD type 'xsd:string'
        std::string *authenticationStatusMessage;
        /// Optional element 'ns2:cavv' of XSD type 'xsd:string'
        std::string *cavv;
        /// Optional element 'ns2:cavvAlgorithm' of XSD type 'xsd:string'
        std::string *cavvAlgorithm;
        /// Optional element 'ns2:commerceIndicator' of XSD type 'xsd:string'
        std::string *commerceIndicator;
        /// Optional element 'ns2:eci' of XSD type 'xsd:string'
        std::string *eci;
        /// Optional element 'ns2:eciRaw' of XSD type 'xsd:string'
        std::string *eciRaw;
        /// Optional element 'ns2:xid' of XSD type 'xsd:string'
        std::string *xid;
        /// Optional element 'ns2:ucafAuthenticationData' of XSD type 'xsd:string'
        std::string *ucafAuthenticationData;
        /// Optional element 'ns2:ucafCollectionIndicator' of XSD type 'xsd:string'
        std::string *ucafCollectionIndicator;
        /// Optional element 'ns2:paresStatus' of XSD type 'xsd:string'
        std::string *paresStatus;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayerAuthValidateReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PayerAuthValidateReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayerAuthValidateReply, default initialized and not managed by a soap context
        virtual ns2__PayerAuthValidateReply *soap_alloc(void) const { return SOAP_NEW(ns2__PayerAuthValidateReply); }
      public:
        /// Constructor with initializations
        ns2__PayerAuthValidateReply()
        {
          authenticationResult = (std::string *)0;
          authenticationStatusMessage = (std::string *)0;
          cavv = (std::string *)0;
          cavvAlgorithm = (std::string *)0;
          commerceIndicator = (std::string *)0;
          eci = (std::string *)0;
          eciRaw = (std::string *)0;
          xid = (std::string *)0;
          ucafAuthenticationData = (std::string *)0;
          ucafCollectionIndicator = (std::string *)0;
          paresStatus = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PayerAuthValidateReply() { }
        /// Friend allocator used by soap_new_ns2__PayerAuthValidateReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayerAuthValidateReply * SOAP_FMAC2 soap_instantiate_ns2__PayerAuthValidateReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:576 */
#ifndef SOAP_TYPE_ns2__TaxReplyItem
#define SOAP_TYPE_ns2__TaxReplyItem (251)
/* complex XSD type 'ns2:TaxReplyItem': */
class SOAP_CMAC ns2__TaxReplyItem {
      public:
        /// Optional element 'ns2:cityTaxAmount' of XSD type 'ns2:amount'
        std::string *cityTaxAmount;
        /// Optional element 'ns2:countyTaxAmount' of XSD type 'ns2:amount'
        std::string *countyTaxAmount;
        /// Optional element 'ns2:districtTaxAmount' of XSD type 'ns2:amount'
        std::string *districtTaxAmount;
        /// Optional element 'ns2:stateTaxAmount' of XSD type 'ns2:amount'
        std::string *stateTaxAmount;
        /// Required element 'ns2:totalTaxAmount' of XSD type 'ns2:amount'
        std::string totalTaxAmount;
        /// required attribute 'id' of XSD type 'xsd:integer'
        std::string id;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__TaxReplyItem
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__TaxReplyItem; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__TaxReplyItem, default initialized and not managed by a soap context
        virtual ns2__TaxReplyItem *soap_alloc(void) const { return SOAP_NEW(ns2__TaxReplyItem); }
      public:
        /// Constructor with initializations
        ns2__TaxReplyItem()
        {
          cityTaxAmount = (std::string *)0;
          countyTaxAmount = (std::string *)0;
          districtTaxAmount = (std::string *)0;
          stateTaxAmount = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__TaxReplyItem() { }
        /// Friend allocator used by soap_new_ns2__TaxReplyItem(struct soap*, int)
        friend SOAP_FMAC1 ns2__TaxReplyItem * SOAP_FMAC2 soap_instantiate_ns2__TaxReplyItem(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:579 */
#ifndef SOAP_TYPE_ns2__TaxReply
#define SOAP_TYPE_ns2__TaxReply (252)
/* complex XSD type 'ns2:TaxReply': */
class SOAP_CMAC ns2__TaxReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:currency' of XSD type 'xsd:string'
        std::string *currency;
        /// Optional element 'ns2:grandTotalAmount' of XSD type 'ns2:amount'
        std::string *grandTotalAmount;
        /// Optional element 'ns2:totalCityTaxAmount' of XSD type 'ns2:amount'
        std::string *totalCityTaxAmount;
        /// Optional element 'ns2:city' of XSD type 'xsd:string'
        std::string *city;
        /// Optional element 'ns2:totalCountyTaxAmount' of XSD type 'ns2:amount'
        std::string *totalCountyTaxAmount;
        /// Optional element 'ns2:county' of XSD type 'xsd:string'
        std::string *county;
        /// Optional element 'ns2:totalDistrictTaxAmount' of XSD type 'ns2:amount'
        std::string *totalDistrictTaxAmount;
        /// Optional element 'ns2:totalStateTaxAmount' of XSD type 'ns2:amount'
        std::string *totalStateTaxAmount;
        /// Optional element 'ns2:state' of XSD type 'xsd:string'
        std::string *state;
        /// Optional element 'ns2:totalTaxAmount' of XSD type 'ns2:amount'
        std::string *totalTaxAmount;
        /// Optional element 'ns2:postalCode' of XSD type 'xsd:string'
        std::string *postalCode;
        /// Optional element 'ns2:geocode' of XSD type 'xsd:string'
        std::string *geocode;
        /// Sequence of 0 to 1000 elements 'ns2:item' of XSD type 'ns2:TaxReplyItem'
        std::vector<ns2__TaxReplyItem *> item;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__TaxReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__TaxReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__TaxReply, default initialized and not managed by a soap context
        virtual ns2__TaxReply *soap_alloc(void) const { return SOAP_NEW(ns2__TaxReply); }
      public:
        /// Constructor with initializations
        ns2__TaxReply()
        {
          currency = (std::string *)0;
          grandTotalAmount = (std::string *)0;
          totalCityTaxAmount = (std::string *)0;
          city = (std::string *)0;
          totalCountyTaxAmount = (std::string *)0;
          county = (std::string *)0;
          totalDistrictTaxAmount = (std::string *)0;
          totalStateTaxAmount = (std::string *)0;
          state = (std::string *)0;
          totalTaxAmount = (std::string *)0;
          postalCode = (std::string *)0;
          geocode = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__TaxReply() { }
        /// Friend allocator used by soap_new_ns2__TaxReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__TaxReply * SOAP_FMAC2 soap_instantiate_ns2__TaxReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:582 */
#ifndef SOAP_TYPE_ns2__DeviceFingerprint
#define SOAP_TYPE_ns2__DeviceFingerprint (253)
/* complex XSD type 'ns2:DeviceFingerprint': */
class SOAP_CMAC ns2__DeviceFingerprint {
      public:
        /// Optional element 'ns2:cookiesEnabled' of XSD type 'ns2:boolean'
        std::string *cookiesEnabled;
        /// Optional element 'ns2:flashEnabled' of XSD type 'ns2:boolean'
        std::string *flashEnabled;
        /// Optional element 'ns2:hash' of XSD type 'xsd:string'
        std::string *hash;
        /// Optional element 'ns2:imagesEnabled' of XSD type 'ns2:boolean'
        std::string *imagesEnabled;
        /// Optional element 'ns2:javascriptEnabled' of XSD type 'ns2:boolean'
        std::string *javascriptEnabled;
        /// Optional element 'ns2:proxyIPAddress' of XSD type 'xsd:string'
        std::string *proxyIPAddress;
        /// Optional element 'ns2:proxyIPAddressActivities' of XSD type 'xsd:string'
        std::string *proxyIPAddressActivities;
        /// Optional element 'ns2:proxyIPAddressAttributes' of XSD type 'xsd:string'
        std::string *proxyIPAddressAttributes;
        /// Optional element 'ns2:proxyServerType' of XSD type 'xsd:string'
        std::string *proxyServerType;
        /// Optional element 'ns2:trueIPAddress' of XSD type 'xsd:string'
        std::string *trueIPAddress;
        /// Optional element 'ns2:trueIPAddressActivities' of XSD type 'xsd:string'
        std::string *trueIPAddressActivities;
        /// Optional element 'ns2:trueIPAddressAttributes' of XSD type 'xsd:string'
        std::string *trueIPAddressAttributes;
        /// Optional element 'ns2:trueIPAddressCity' of XSD type 'xsd:string'
        std::string *trueIPAddressCity;
        /// Optional element 'ns2:trueIPAddressCountry' of XSD type 'xsd:string'
        std::string *trueIPAddressCountry;
        /// Optional element 'ns2:smartID' of XSD type 'xsd:string'
        std::string *smartID;
        /// Optional element 'ns2:smartIDConfidenceLevel' of XSD type 'xsd:string'
        std::string *smartIDConfidenceLevel;
        /// Optional element 'ns2:screenResolution' of XSD type 'xsd:string'
        std::string *screenResolution;
        /// Optional element 'ns2:browserLanguage' of XSD type 'xsd:string'
        std::string *browserLanguage;
        /// Optional element 'ns2:agentType' of XSD type 'xsd:string'
        std::string *agentType;
        /// Optional element 'ns2:dateTime' of XSD type 'ns2:dateTime'
        std::string *dateTime;
        /// Optional element 'ns2:profileDuration' of XSD type 'xsd:integer'
        std::string *profileDuration;
        /// Optional element 'ns2:profiledURL' of XSD type 'xsd:string'
        std::string *profiledURL;
        /// Optional element 'ns2:timeOnPage' of XSD type 'xsd:integer'
        std::string *timeOnPage;
        /// Optional element 'ns2:deviceMatch' of XSD type 'xsd:string'
        std::string *deviceMatch;
        /// Optional element 'ns2:firstEncounter' of XSD type 'xsd:string'
        std::string *firstEncounter;
        /// Optional element 'ns2:flashOS' of XSD type 'xsd:string'
        std::string *flashOS;
        /// Optional element 'ns2:flashVersion' of XSD type 'xsd:string'
        std::string *flashVersion;
        /// Optional element 'ns2:deviceLatitude' of XSD type 'xsd:string'
        std::string *deviceLatitude;
        /// Optional element 'ns2:deviceLongitude' of XSD type 'xsd:string'
        std::string *deviceLongitude;
        /// Optional element 'ns2:gpsAccuracy' of XSD type 'xsd:string'
        std::string *gpsAccuracy;
        /// Optional element 'ns2:jbRoot' of XSD type 'xsd:integer'
        std::string *jbRoot;
        /// Optional element 'ns2:jbRootReason' of XSD type 'xsd:string'
        std::string *jbRootReason;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__DeviceFingerprint
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__DeviceFingerprint; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__DeviceFingerprint, default initialized and not managed by a soap context
        virtual ns2__DeviceFingerprint *soap_alloc(void) const { return SOAP_NEW(ns2__DeviceFingerprint); }
      public:
        /// Constructor with initializations
        ns2__DeviceFingerprint()
        {
          cookiesEnabled = (std::string *)0;
          flashEnabled = (std::string *)0;
          hash = (std::string *)0;
          imagesEnabled = (std::string *)0;
          javascriptEnabled = (std::string *)0;
          proxyIPAddress = (std::string *)0;
          proxyIPAddressActivities = (std::string *)0;
          proxyIPAddressAttributes = (std::string *)0;
          proxyServerType = (std::string *)0;
          trueIPAddress = (std::string *)0;
          trueIPAddressActivities = (std::string *)0;
          trueIPAddressAttributes = (std::string *)0;
          trueIPAddressCity = (std::string *)0;
          trueIPAddressCountry = (std::string *)0;
          smartID = (std::string *)0;
          smartIDConfidenceLevel = (std::string *)0;
          screenResolution = (std::string *)0;
          browserLanguage = (std::string *)0;
          agentType = (std::string *)0;
          dateTime = (std::string *)0;
          profileDuration = (std::string *)0;
          profiledURL = (std::string *)0;
          timeOnPage = (std::string *)0;
          deviceMatch = (std::string *)0;
          firstEncounter = (std::string *)0;
          flashOS = (std::string *)0;
          flashVersion = (std::string *)0;
          deviceLatitude = (std::string *)0;
          deviceLongitude = (std::string *)0;
          gpsAccuracy = (std::string *)0;
          jbRoot = (std::string *)0;
          jbRootReason = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__DeviceFingerprint() { }
        /// Friend allocator used by soap_new_ns2__DeviceFingerprint(struct soap*, int)
        friend SOAP_FMAC1 ns2__DeviceFingerprint * SOAP_FMAC2 soap_instantiate_ns2__DeviceFingerprint(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:585 */
#ifndef SOAP_TYPE_ns2__AFSReply
#define SOAP_TYPE_ns2__AFSReply (254)
/* complex XSD type 'ns2:AFSReply': */
class SOAP_CMAC ns2__AFSReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:afsResult' of XSD type 'xsd:integer'
        std::string *afsResult;
        /// Optional element 'ns2:hostSeverity' of XSD type 'xsd:integer'
        std::string *hostSeverity;
        /// Optional element 'ns2:consumerLocalTime' of XSD type 'xsd:string'
        std::string *consumerLocalTime;
        /// Optional element 'ns2:afsFactorCode' of XSD type 'xsd:string'
        std::string *afsFactorCode;
        /// Optional element 'ns2:addressInfoCode' of XSD type 'xsd:string'
        std::string *addressInfoCode;
        /// Optional element 'ns2:hotlistInfoCode' of XSD type 'xsd:string'
        std::string *hotlistInfoCode;
        /// Optional element 'ns2:internetInfoCode' of XSD type 'xsd:string'
        std::string *internetInfoCode;
        /// Optional element 'ns2:phoneInfoCode' of XSD type 'xsd:string'
        std::string *phoneInfoCode;
        /// Optional element 'ns2:suspiciousInfoCode' of XSD type 'xsd:string'
        std::string *suspiciousInfoCode;
        /// Optional element 'ns2:velocityInfoCode' of XSD type 'xsd:string'
        std::string *velocityInfoCode;
        /// Optional element 'ns2:identityInfoCode' of XSD type 'xsd:string'
        std::string *identityInfoCode;
        /// Optional element 'ns2:ipCountry' of XSD type 'xsd:string'
        std::string *ipCountry;
        /// Optional element 'ns2:ipState' of XSD type 'xsd:string'
        std::string *ipState;
        /// Optional element 'ns2:ipCity' of XSD type 'xsd:string'
        std::string *ipCity;
        /// Optional element 'ns2:ipRoutingMethod' of XSD type 'xsd:string'
        std::string *ipRoutingMethod;
        /// Optional element 'ns2:ipAnonymizerStatus' of XSD type 'xsd:string'
        std::string *ipAnonymizerStatus;
        /// Optional element 'ns2:scoreModelUsed' of XSD type 'xsd:string'
        std::string *scoreModelUsed;
        /// Optional element 'ns2:cardBin' of XSD type 'xsd:string'
        std::string *cardBin;
        /// Optional element 'ns2:binCountry' of XSD type 'xsd:string'
        std::string *binCountry;
        /// Optional element 'ns2:cardAccountType' of XSD type 'xsd:string'
        std::string *cardAccountType;
        /// Optional element 'ns2:cardScheme' of XSD type 'xsd:string'
        std::string *cardScheme;
        /// Optional element 'ns2:cardIssuer' of XSD type 'xsd:string'
        std::string *cardIssuer;
        /// Optional element 'ns2:deviceFingerprint' of XSD type 'ns2:DeviceFingerprint'
        ns2__DeviceFingerprint *deviceFingerprint;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__AFSReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__AFSReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__AFSReply, default initialized and not managed by a soap context
        virtual ns2__AFSReply *soap_alloc(void) const { return SOAP_NEW(ns2__AFSReply); }
      public:
        /// Constructor with initializations
        ns2__AFSReply()
        {
          afsResult = (std::string *)0;
          hostSeverity = (std::string *)0;
          consumerLocalTime = (std::string *)0;
          afsFactorCode = (std::string *)0;
          addressInfoCode = (std::string *)0;
          hotlistInfoCode = (std::string *)0;
          internetInfoCode = (std::string *)0;
          phoneInfoCode = (std::string *)0;
          suspiciousInfoCode = (std::string *)0;
          velocityInfoCode = (std::string *)0;
          identityInfoCode = (std::string *)0;
          ipCountry = (std::string *)0;
          ipState = (std::string *)0;
          ipCity = (std::string *)0;
          ipRoutingMethod = (std::string *)0;
          ipAnonymizerStatus = (std::string *)0;
          scoreModelUsed = (std::string *)0;
          cardBin = (std::string *)0;
          binCountry = (std::string *)0;
          cardAccountType = (std::string *)0;
          cardScheme = (std::string *)0;
          cardIssuer = (std::string *)0;
          deviceFingerprint = (ns2__DeviceFingerprint *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__AFSReply() { }
        /// Friend allocator used by soap_new_ns2__AFSReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__AFSReply * SOAP_FMAC2 soap_instantiate_ns2__AFSReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:588 */
#ifndef SOAP_TYPE_ns2__DAVReply
#define SOAP_TYPE_ns2__DAVReply (255)
/* complex XSD type 'ns2:DAVReply': */
class SOAP_CMAC ns2__DAVReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:addressType' of XSD type 'xsd:string'
        std::string *addressType;
        /// Optional element 'ns2:apartmentInfo' of XSD type 'xsd:string'
        std::string *apartmentInfo;
        /// Optional element 'ns2:barCode' of XSD type 'xsd:string'
        std::string *barCode;
        /// Optional element 'ns2:barCodeCheckDigit' of XSD type 'xsd:string'
        std::string *barCodeCheckDigit;
        /// Optional element 'ns2:careOf' of XSD type 'xsd:string'
        std::string *careOf;
        /// Optional element 'ns2:cityInfo' of XSD type 'xsd:string'
        std::string *cityInfo;
        /// Optional element 'ns2:countryInfo' of XSD type 'xsd:string'
        std::string *countryInfo;
        /// Optional element 'ns2:directionalInfo' of XSD type 'xsd:string'
        std::string *directionalInfo;
        /// Optional element 'ns2:lvrInfo' of XSD type 'xsd:string'
        std::string *lvrInfo;
        /// Optional element 'ns2:matchScore' of XSD type 'xsd:integer'
        std::string *matchScore;
        /// Optional element 'ns2:standardizedAddress1' of XSD type 'xsd:string'
        std::string *standardizedAddress1;
        /// Optional element 'ns2:standardizedAddress2' of XSD type 'xsd:string'
        std::string *standardizedAddress2;
        /// Optional element 'ns2:standardizedAddress3' of XSD type 'xsd:string'
        std::string *standardizedAddress3;
        /// Optional element 'ns2:standardizedAddress4' of XSD type 'xsd:string'
        std::string *standardizedAddress4;
        /// Optional element 'ns2:standardizedAddressNoApt' of XSD type 'xsd:string'
        std::string *standardizedAddressNoApt;
        /// Optional element 'ns2:standardizedCity' of XSD type 'xsd:string'
        std::string *standardizedCity;
        /// Optional element 'ns2:standardizedCounty' of XSD type 'xsd:string'
        std::string *standardizedCounty;
        /// Optional element 'ns2:standardizedCSP' of XSD type 'xsd:string'
        std::string *standardizedCSP;
        /// Optional element 'ns2:standardizedState' of XSD type 'xsd:string'
        std::string *standardizedState;
        /// Optional element 'ns2:standardizedPostalCode' of XSD type 'xsd:string'
        std::string *standardizedPostalCode;
        /// Optional element 'ns2:standardizedCountry' of XSD type 'xsd:string'
        std::string *standardizedCountry;
        /// Optional element 'ns2:standardizedISOCountry' of XSD type 'xsd:string'
        std::string *standardizedISOCountry;
        /// Optional element 'ns2:stateInfo' of XSD type 'xsd:string'
        std::string *stateInfo;
        /// Optional element 'ns2:streetInfo' of XSD type 'xsd:string'
        std::string *streetInfo;
        /// Optional element 'ns2:suffixInfo' of XSD type 'xsd:string'
        std::string *suffixInfo;
        /// Optional element 'ns2:postalCodeInfo' of XSD type 'xsd:string'
        std::string *postalCodeInfo;
        /// Optional element 'ns2:overallInfo' of XSD type 'xsd:string'
        std::string *overallInfo;
        /// Optional element 'ns2:usInfo' of XSD type 'xsd:string'
        std::string *usInfo;
        /// Optional element 'ns2:caInfo' of XSD type 'xsd:string'
        std::string *caInfo;
        /// Optional element 'ns2:intlInfo' of XSD type 'xsd:string'
        std::string *intlInfo;
        /// Optional element 'ns2:usErrorInfo' of XSD type 'xsd:string'
        std::string *usErrorInfo;
        /// Optional element 'ns2:caErrorInfo' of XSD type 'xsd:string'
        std::string *caErrorInfo;
        /// Optional element 'ns2:intlErrorInfo' of XSD type 'xsd:string'
        std::string *intlErrorInfo;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__DAVReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__DAVReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__DAVReply, default initialized and not managed by a soap context
        virtual ns2__DAVReply *soap_alloc(void) const { return SOAP_NEW(ns2__DAVReply); }
      public:
        /// Constructor with initializations
        ns2__DAVReply()
        {
          addressType = (std::string *)0;
          apartmentInfo = (std::string *)0;
          barCode = (std::string *)0;
          barCodeCheckDigit = (std::string *)0;
          careOf = (std::string *)0;
          cityInfo = (std::string *)0;
          countryInfo = (std::string *)0;
          directionalInfo = (std::string *)0;
          lvrInfo = (std::string *)0;
          matchScore = (std::string *)0;
          standardizedAddress1 = (std::string *)0;
          standardizedAddress2 = (std::string *)0;
          standardizedAddress3 = (std::string *)0;
          standardizedAddress4 = (std::string *)0;
          standardizedAddressNoApt = (std::string *)0;
          standardizedCity = (std::string *)0;
          standardizedCounty = (std::string *)0;
          standardizedCSP = (std::string *)0;
          standardizedState = (std::string *)0;
          standardizedPostalCode = (std::string *)0;
          standardizedCountry = (std::string *)0;
          standardizedISOCountry = (std::string *)0;
          stateInfo = (std::string *)0;
          streetInfo = (std::string *)0;
          suffixInfo = (std::string *)0;
          postalCodeInfo = (std::string *)0;
          overallInfo = (std::string *)0;
          usInfo = (std::string *)0;
          caInfo = (std::string *)0;
          intlInfo = (std::string *)0;
          usErrorInfo = (std::string *)0;
          caErrorInfo = (std::string *)0;
          intlErrorInfo = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__DAVReply() { }
        /// Friend allocator used by soap_new_ns2__DAVReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__DAVReply * SOAP_FMAC2 soap_instantiate_ns2__DAVReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:591 */
#ifndef SOAP_TYPE_ns2__DeniedPartiesMatch
#define SOAP_TYPE_ns2__DeniedPartiesMatch (256)
/* complex XSD type 'ns2:DeniedPartiesMatch': */
class SOAP_CMAC ns2__DeniedPartiesMatch {
      public:
        /// Optional element 'ns2:list' of XSD type 'xsd:string'
        std::string *list;
        /// Sequence of 0 to 100 elements 'ns2:name' of XSD type 'xsd:string'
        std::vector<std::string> name;
        /// Sequence of 0 to 100 elements 'ns2:address' of XSD type 'xsd:string'
        std::vector<std::string> address;
        /// Sequence of 0 to 100 elements 'ns2:program' of XSD type 'xsd:string'
        std::vector<std::string> program;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__DeniedPartiesMatch
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__DeniedPartiesMatch; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__DeniedPartiesMatch, default initialized and not managed by a soap context
        virtual ns2__DeniedPartiesMatch *soap_alloc(void) const { return SOAP_NEW(ns2__DeniedPartiesMatch); }
      public:
        /// Constructor with initializations
        ns2__DeniedPartiesMatch()
        {
          list = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__DeniedPartiesMatch() { }
        /// Friend allocator used by soap_new_ns2__DeniedPartiesMatch(struct soap*, int)
        friend SOAP_FMAC1 ns2__DeniedPartiesMatch * SOAP_FMAC2 soap_instantiate_ns2__DeniedPartiesMatch(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:594 */
#ifndef SOAP_TYPE_ns2__ExportReply
#define SOAP_TYPE_ns2__ExportReply (257)
/* complex XSD type 'ns2:ExportReply': */
class SOAP_CMAC ns2__ExportReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:ipCountryConfidence' of XSD type 'xsd:integer'
        std::string *ipCountryConfidence;
        /// Optional element 'ns2:infoCode' of XSD type 'xsd:string'
        std::string *infoCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ExportReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ExportReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ExportReply, default initialized and not managed by a soap context
        virtual ns2__ExportReply *soap_alloc(void) const { return SOAP_NEW(ns2__ExportReply); }
      public:
        /// Constructor with initializations
        ns2__ExportReply()
        {
          ipCountryConfidence = (std::string *)0;
          infoCode = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__ExportReply() { }
        /// Friend allocator used by soap_new_ns2__ExportReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__ExportReply * SOAP_FMAC2 soap_instantiate_ns2__ExportReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:597 */
#ifndef SOAP_TYPE_ns2__FXQuote
#define SOAP_TYPE_ns2__FXQuote (258)
/* complex XSD type 'ns2:FXQuote': */
class SOAP_CMAC ns2__FXQuote {
      public:
        /// Optional element 'ns2:id' of XSD type 'xsd:string'
        std::string *id;
        /// Optional element 'ns2:rate' of XSD type 'xsd:string'
        std::string *rate;
        /// Optional element 'ns2:type' of XSD type 'xsd:string'
        std::string *type;
        /// Optional element 'ns2:expirationDateTime' of XSD type 'ns2:dateTime'
        std::string *expirationDateTime;
        /// Optional element 'ns2:currency' of XSD type 'xsd:string'
        std::string *currency;
        /// Optional element 'ns2:fundingCurrency' of XSD type 'xsd:string'
        std::string *fundingCurrency;
        /// Optional element 'ns2:receivedDateTime' of XSD type 'ns2:dateTime'
        std::string *receivedDateTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__FXQuote
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__FXQuote; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__FXQuote, default initialized and not managed by a soap context
        virtual ns2__FXQuote *soap_alloc(void) const { return SOAP_NEW(ns2__FXQuote); }
      public:
        /// Constructor with initializations
        ns2__FXQuote()
        {
          id = (std::string *)0;
          rate = (std::string *)0;
          type = (std::string *)0;
          expirationDateTime = (std::string *)0;
          currency = (std::string *)0;
          fundingCurrency = (std::string *)0;
          receivedDateTime = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__FXQuote() { }
        /// Friend allocator used by soap_new_ns2__FXQuote(struct soap*, int)
        friend SOAP_FMAC1 ns2__FXQuote * SOAP_FMAC2 soap_instantiate_ns2__FXQuote(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:600 */
#ifndef SOAP_TYPE_ns2__FXRatesReply
#define SOAP_TYPE_ns2__FXRatesReply (259)
/* complex XSD type 'ns2:FXRatesReply': */
class SOAP_CMAC ns2__FXRatesReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Sequence of 0 to 999 elements 'ns2:quote' of XSD type 'ns2:FXQuote'
        std::vector<ns2__FXQuote *> quote;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__FXRatesReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__FXRatesReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__FXRatesReply, default initialized and not managed by a soap context
        virtual ns2__FXRatesReply *soap_alloc(void) const { return SOAP_NEW(ns2__FXRatesReply); }
      public:
        /// Constructor with initializations
        ns2__FXRatesReply()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__FXRatesReply() { }
        /// Friend allocator used by soap_new_ns2__FXRatesReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__FXRatesReply * SOAP_FMAC2 soap_instantiate_ns2__FXRatesReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:603 */
#ifndef SOAP_TYPE_ns2__BankTransferReply
#define SOAP_TYPE_ns2__BankTransferReply (260)
/* complex XSD type 'ns2:BankTransferReply': */
class SOAP_CMAC ns2__BankTransferReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:accountHolder' of XSD type 'xsd:string'
        std::string *accountHolder;
        /// Optional element 'ns2:accountNumber' of XSD type 'xsd:string'
        std::string *accountNumber;
        /// Optional element 'ns2:amount' of XSD type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:bankName' of XSD type 'xsd:string'
        std::string *bankName;
        /// Optional element 'ns2:bankCity' of XSD type 'xsd:string'
        std::string *bankCity;
        /// Optional element 'ns2:bankCountry' of XSD type 'xsd:string'
        std::string *bankCountry;
        /// Optional element 'ns2:paymentReference' of XSD type 'xsd:string'
        std::string *paymentReference;
        /// Optional element 'ns2:processorResponse' of XSD type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:bankSwiftCode' of XSD type 'xsd:string'
        std::string *bankSwiftCode;
        /// Optional element 'ns2:bankSpecialID' of XSD type 'xsd:string'
        std::string *bankSpecialID;
        /// Optional element 'ns2:requestDateTime' of XSD type 'ns2:dateTime'
        std::string *requestDateTime;
        /// Optional element 'ns2:reconciliationID' of XSD type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:iban' of XSD type 'xsd:string'
        std::string *iban;
        /// Optional element 'ns2:bankCode' of XSD type 'xsd:string'
        std::string *bankCode;
        /// Optional element 'ns2:branchCode' of XSD type 'xsd:string'
        std::string *branchCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__BankTransferReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__BankTransferReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__BankTransferReply, default initialized and not managed by a soap context
        virtual ns2__BankTransferReply *soap_alloc(void) const { return SOAP_NEW(ns2__BankTransferReply); }
      public:
        /// Constructor with initializations
        ns2__BankTransferReply()
        {
          accountHolder = (std::string *)0;
          accountNumber = (std::string *)0;
          amount = (std::string *)0;
          bankName = (std::string *)0;
          bankCity = (std::string *)0;
          bankCountry = (std::string *)0;
          paymentReference = (std::string *)0;
          processorResponse = (std::string *)0;
          bankSwiftCode = (std::string *)0;
          bankSpecialID = (std::string *)0;
          requestDateTime = (std::string *)0;
          reconciliationID = (std::string *)0;
          iban = (std::string *)0;
          bankCode = (std::string *)0;
          branchCode = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__BankTransferReply() { }
        /// Friend allocator used by soap_new_ns2__BankTransferReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__BankTransferReply * SOAP_FMAC2 soap_instantiate_ns2__BankTransferReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:606 */
#ifndef SOAP_TYPE_ns2__BankTransferRealTimeReply
#define SOAP_TYPE_ns2__BankTransferRealTimeReply (261)
/* complex XSD type 'ns2:BankTransferRealTimeReply': */
class SOAP_CMAC ns2__BankTransferRealTimeReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:formMethod' of XSD type 'xsd:string'
        std::string *formMethod;
        /// Optional element 'ns2:formAction' of XSD type 'xsd:string'
        std::string *formAction;
        /// Optional element 'ns2:requestDateTime' of XSD type 'ns2:dateTime'
        std::string *requestDateTime;
        /// Optional element 'ns2:reconciliationID' of XSD type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:paymentReference' of XSD type 'xsd:string'
        std::string *paymentReference;
        /// Optional element 'ns2:amount' of XSD type 'ns2:amount'
        std::string *amount;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__BankTransferRealTimeReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__BankTransferRealTimeReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__BankTransferRealTimeReply, default initialized and not managed by a soap context
        virtual ns2__BankTransferRealTimeReply *soap_alloc(void) const { return SOAP_NEW(ns2__BankTransferRealTimeReply); }
      public:
        /// Constructor with initializations
        ns2__BankTransferRealTimeReply()
        {
          formMethod = (std::string *)0;
          formAction = (std::string *)0;
          requestDateTime = (std::string *)0;
          reconciliationID = (std::string *)0;
          paymentReference = (std::string *)0;
          amount = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__BankTransferRealTimeReply() { }
        /// Friend allocator used by soap_new_ns2__BankTransferRealTimeReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__BankTransferRealTimeReply * SOAP_FMAC2 soap_instantiate_ns2__BankTransferRealTimeReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:609 */
#ifndef SOAP_TYPE_ns2__DirectDebitMandateReply
#define SOAP_TYPE_ns2__DirectDebitMandateReply (262)
/* complex XSD type 'ns2:DirectDebitMandateReply': */
class SOAP_CMAC ns2__DirectDebitMandateReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:mandateID' of XSD type 'xsd:string'
        std::string *mandateID;
        /// Optional element 'ns2:mandateMaturationDate' of XSD type 'xsd:string'
        std::string *mandateMaturationDate;
        /// Optional element 'ns2:requestDateTime' of XSD type 'ns2:dateTime'
        std::string *requestDateTime;
        /// Optional element 'ns2:reconciliationID' of XSD type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:processorResponse' of XSD type 'xsd:string'
        std::string *processorResponse;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__DirectDebitMandateReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__DirectDebitMandateReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__DirectDebitMandateReply, default initialized and not managed by a soap context
        virtual ns2__DirectDebitMandateReply *soap_alloc(void) const { return SOAP_NEW(ns2__DirectDebitMandateReply); }
      public:
        /// Constructor with initializations
        ns2__DirectDebitMandateReply()
        {
          mandateID = (std::string *)0;
          mandateMaturationDate = (std::string *)0;
          requestDateTime = (std::string *)0;
          reconciliationID = (std::string *)0;
          processorResponse = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__DirectDebitMandateReply() { }
        /// Friend allocator used by soap_new_ns2__DirectDebitMandateReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__DirectDebitMandateReply * SOAP_FMAC2 soap_instantiate_ns2__DirectDebitMandateReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:612 */
#ifndef SOAP_TYPE_ns2__BankTransferRefundReply
#define SOAP_TYPE_ns2__BankTransferRefundReply (263)
/* complex XSD type 'ns2:BankTransferRefundReply': */
class SOAP_CMAC ns2__BankTransferRefundReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:amount' of XSD type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:requestDateTime' of XSD type 'ns2:dateTime'
        std::string *requestDateTime;
        /// Optional element 'ns2:reconciliationID' of XSD type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:processorResponse' of XSD type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:iban' of XSD type 'xsd:string'
        std::string *iban;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__BankTransferRefundReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__BankTransferRefundReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__BankTransferRefundReply, default initialized and not managed by a soap context
        virtual ns2__BankTransferRefundReply *soap_alloc(void) const { return SOAP_NEW(ns2__BankTransferRefundReply); }
      public:
        /// Constructor with initializations
        ns2__BankTransferRefundReply()
        {
          amount = (std::string *)0;
          requestDateTime = (std::string *)0;
          reconciliationID = (std::string *)0;
          processorResponse = (std::string *)0;
          iban = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__BankTransferRefundReply() { }
        /// Friend allocator used by soap_new_ns2__BankTransferRefundReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__BankTransferRefundReply * SOAP_FMAC2 soap_instantiate_ns2__BankTransferRefundReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:615 */
#ifndef SOAP_TYPE_ns2__DirectDebitReply
#define SOAP_TYPE_ns2__DirectDebitReply (264)
/* complex XSD type 'ns2:DirectDebitReply': */
class SOAP_CMAC ns2__DirectDebitReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:amount' of XSD type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:requestDateTime' of XSD type 'ns2:dateTime'
        std::string *requestDateTime;
        /// Optional element 'ns2:reconciliationID' of XSD type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:processorResponse' of XSD type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:processorTransactionID' of XSD type 'xsd:string'
        std::string *processorTransactionID;
        /// Optional element 'ns2:mandateAuthenticationDate' of XSD type 'xsd:string'
        std::string *mandateAuthenticationDate;
        /// Optional element 'ns2:mandateID' of XSD type 'xsd:string'
        std::string *mandateID;
        /// Optional element 'ns2:iban' of XSD type 'xsd:string'
        std::string *iban;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__DirectDebitReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__DirectDebitReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__DirectDebitReply, default initialized and not managed by a soap context
        virtual ns2__DirectDebitReply *soap_alloc(void) const { return SOAP_NEW(ns2__DirectDebitReply); }
      public:
        /// Constructor with initializations
        ns2__DirectDebitReply()
        {
          amount = (std::string *)0;
          requestDateTime = (std::string *)0;
          reconciliationID = (std::string *)0;
          processorResponse = (std::string *)0;
          processorTransactionID = (std::string *)0;
          mandateAuthenticationDate = (std::string *)0;
          mandateID = (std::string *)0;
          iban = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__DirectDebitReply() { }
        /// Friend allocator used by soap_new_ns2__DirectDebitReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__DirectDebitReply * SOAP_FMAC2 soap_instantiate_ns2__DirectDebitReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:618 */
#ifndef SOAP_TYPE_ns2__DirectDebitValidateReply
#define SOAP_TYPE_ns2__DirectDebitValidateReply (265)
/* complex XSD type 'ns2:DirectDebitValidateReply': */
class SOAP_CMAC ns2__DirectDebitValidateReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:amount' of XSD type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:requestDateTime' of XSD type 'ns2:dateTime'
        std::string *requestDateTime;
        /// Optional element 'ns2:reconciliationID' of XSD type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:processorResponse' of XSD type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:iban' of XSD type 'xsd:string'
        std::string *iban;
        /// Optional element 'ns2:bankSwiftCode' of XSD type 'xsd:string'
        std::string *bankSwiftCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__DirectDebitValidateReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__DirectDebitValidateReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__DirectDebitValidateReply, default initialized and not managed by a soap context
        virtual ns2__DirectDebitValidateReply *soap_alloc(void) const { return SOAP_NEW(ns2__DirectDebitValidateReply); }
      public:
        /// Constructor with initializations
        ns2__DirectDebitValidateReply()
        {
          amount = (std::string *)0;
          requestDateTime = (std::string *)0;
          reconciliationID = (std::string *)0;
          processorResponse = (std::string *)0;
          iban = (std::string *)0;
          bankSwiftCode = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__DirectDebitValidateReply() { }
        /// Friend allocator used by soap_new_ns2__DirectDebitValidateReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__DirectDebitValidateReply * SOAP_FMAC2 soap_instantiate_ns2__DirectDebitValidateReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:621 */
#ifndef SOAP_TYPE_ns2__DirectDebitRefundReply
#define SOAP_TYPE_ns2__DirectDebitRefundReply (266)
/* complex XSD type 'ns2:DirectDebitRefundReply': */
class SOAP_CMAC ns2__DirectDebitRefundReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:amount' of XSD type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:requestDateTime' of XSD type 'ns2:dateTime'
        std::string *requestDateTime;
        /// Optional element 'ns2:reconciliationID' of XSD type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:processorResponse' of XSD type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:processorTransactionID' of XSD type 'xsd:string'
        std::string *processorTransactionID;
        /// Optional element 'ns2:iban' of XSD type 'xsd:string'
        std::string *iban;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__DirectDebitRefundReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__DirectDebitRefundReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__DirectDebitRefundReply, default initialized and not managed by a soap context
        virtual ns2__DirectDebitRefundReply *soap_alloc(void) const { return SOAP_NEW(ns2__DirectDebitRefundReply); }
      public:
        /// Constructor with initializations
        ns2__DirectDebitRefundReply()
        {
          amount = (std::string *)0;
          requestDateTime = (std::string *)0;
          reconciliationID = (std::string *)0;
          processorResponse = (std::string *)0;
          processorTransactionID = (std::string *)0;
          iban = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__DirectDebitRefundReply() { }
        /// Friend allocator used by soap_new_ns2__DirectDebitRefundReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__DirectDebitRefundReply * SOAP_FMAC2 soap_instantiate_ns2__DirectDebitRefundReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:624 */
#ifndef SOAP_TYPE_ns2__PaySubscriptionCreateReply
#define SOAP_TYPE_ns2__PaySubscriptionCreateReply (267)
/* complex XSD type 'ns2:PaySubscriptionCreateReply': */
class SOAP_CMAC ns2__PaySubscriptionCreateReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Required element 'ns2:subscriptionID' of XSD type 'xsd:string'
        std::string subscriptionID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PaySubscriptionCreateReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PaySubscriptionCreateReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PaySubscriptionCreateReply, default initialized and not managed by a soap context
        virtual ns2__PaySubscriptionCreateReply *soap_alloc(void) const { return SOAP_NEW(ns2__PaySubscriptionCreateReply); }
      public:
        /// Constructor with initializations
        ns2__PaySubscriptionCreateReply()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__PaySubscriptionCreateReply() { }
        /// Friend allocator used by soap_new_ns2__PaySubscriptionCreateReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__PaySubscriptionCreateReply * SOAP_FMAC2 soap_instantiate_ns2__PaySubscriptionCreateReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:627 */
#ifndef SOAP_TYPE_ns2__PaySubscriptionUpdateReply
#define SOAP_TYPE_ns2__PaySubscriptionUpdateReply (268)
/* complex XSD type 'ns2:PaySubscriptionUpdateReply': */
class SOAP_CMAC ns2__PaySubscriptionUpdateReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Required element 'ns2:subscriptionID' of XSD type 'xsd:string'
        std::string subscriptionID;
        /// Optional element 'ns2:subscriptionIDNew' of XSD type 'xsd:string'
        std::string *subscriptionIDNew;
        /// Optional element 'ns2:ownerMerchantID' of XSD type 'xsd:string'
        std::string *ownerMerchantID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PaySubscriptionUpdateReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PaySubscriptionUpdateReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PaySubscriptionUpdateReply, default initialized and not managed by a soap context
        virtual ns2__PaySubscriptionUpdateReply *soap_alloc(void) const { return SOAP_NEW(ns2__PaySubscriptionUpdateReply); }
      public:
        /// Constructor with initializations
        ns2__PaySubscriptionUpdateReply()
        {
          subscriptionIDNew = (std::string *)0;
          ownerMerchantID = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PaySubscriptionUpdateReply() { }
        /// Friend allocator used by soap_new_ns2__PaySubscriptionUpdateReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__PaySubscriptionUpdateReply * SOAP_FMAC2 soap_instantiate_ns2__PaySubscriptionUpdateReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:630 */
#ifndef SOAP_TYPE_ns2__PaySubscriptionEventUpdateReply
#define SOAP_TYPE_ns2__PaySubscriptionEventUpdateReply (269)
/* complex XSD type 'ns2:PaySubscriptionEventUpdateReply': */
class SOAP_CMAC ns2__PaySubscriptionEventUpdateReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:ownerMerchantID' of XSD type 'xsd:string'
        std::string *ownerMerchantID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PaySubscriptionEventUpdateReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PaySubscriptionEventUpdateReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PaySubscriptionEventUpdateReply, default initialized and not managed by a soap context
        virtual ns2__PaySubscriptionEventUpdateReply *soap_alloc(void) const { return SOAP_NEW(ns2__PaySubscriptionEventUpdateReply); }
      public:
        /// Constructor with initializations
        ns2__PaySubscriptionEventUpdateReply()
        {
          ownerMerchantID = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PaySubscriptionEventUpdateReply() { }
        /// Friend allocator used by soap_new_ns2__PaySubscriptionEventUpdateReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__PaySubscriptionEventUpdateReply * SOAP_FMAC2 soap_instantiate_ns2__PaySubscriptionEventUpdateReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:633 */
#ifndef SOAP_TYPE_ns2__PaySubscriptionRetrieveReply
#define SOAP_TYPE_ns2__PaySubscriptionRetrieveReply (270)
/* complex XSD type 'ns2:PaySubscriptionRetrieveReply': */
class SOAP_CMAC ns2__PaySubscriptionRetrieveReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:approvalRequired' of XSD type 'xsd:string'
        std::string *approvalRequired;
        /// Optional element 'ns2:automaticRenew' of XSD type 'xsd:string'
        std::string *automaticRenew;
        /// Optional element 'ns2:cardAccountNumber' of XSD type 'xsd:string'
        std::string *cardAccountNumber;
        /// Optional element 'ns2:cardExpirationMonth' of XSD type 'xsd:string'
        std::string *cardExpirationMonth;
        /// Optional element 'ns2:cardExpirationYear' of XSD type 'xsd:string'
        std::string *cardExpirationYear;
        /// Optional element 'ns2:cardIssueNumber' of XSD type 'xsd:string'
        std::string *cardIssueNumber;
        /// Optional element 'ns2:cardStartMonth' of XSD type 'xsd:string'
        std::string *cardStartMonth;
        /// Optional element 'ns2:cardStartYear' of XSD type 'xsd:string'
        std::string *cardStartYear;
        /// Optional element 'ns2:cardType' of XSD type 'xsd:string'
        std::string *cardType;
        /// Optional element 'ns2:checkAccountNumber' of XSD type 'xsd:string'
        std::string *checkAccountNumber;
        /// Optional element 'ns2:checkAccountType' of XSD type 'xsd:string'
        std::string *checkAccountType;
        /// Optional element 'ns2:checkBankTransitNumber' of XSD type 'xsd:string'
        std::string *checkBankTransitNumber;
        /// Optional element 'ns2:checkSecCode' of XSD type 'xsd:string'
        std::string *checkSecCode;
        /// Optional element 'ns2:checkAuthenticateID' of XSD type 'xsd:string'
        std::string *checkAuthenticateID;
        /// Optional element 'ns2:city' of XSD type 'xsd:string'
        std::string *city;
        /// Optional element 'ns2:comments' of XSD type 'xsd:string'
        std::string *comments;
        /// Optional element 'ns2:companyName' of XSD type 'xsd:string'
        std::string *companyName;
        /// Optional element 'ns2:country' of XSD type 'xsd:string'
        std::string *country;
        /// Optional element 'ns2:currency' of XSD type 'xsd:string'
        std::string *currency;
        /// Optional element 'ns2:customerAccountID' of XSD type 'xsd:string'
        std::string *customerAccountID;
        /// Optional element 'ns2:email' of XSD type 'xsd:string'
        std::string *email;
        /// Optional element 'ns2:endDate' of XSD type 'xsd:string'
        std::string *endDate;
        /// Optional element 'ns2:firstName' of XSD type 'xsd:string'
        std::string *firstName;
        /// Optional element 'ns2:frequency' of XSD type 'xsd:string'
        std::string *frequency;
        /// Optional element 'ns2:lastName' of XSD type 'xsd:string'
        std::string *lastName;
        /// Optional element 'ns2:merchantReferenceCode' of XSD type 'xsd:string'
        std::string *merchantReferenceCode;
        /// Optional element 'ns2:paymentMethod' of XSD type 'xsd:string'
        std::string *paymentMethod;
        /// Optional element 'ns2:paymentsRemaining' of XSD type 'xsd:string'
        std::string *paymentsRemaining;
        /// Optional element 'ns2:phoneNumber' of XSD type 'xsd:string'
        std::string *phoneNumber;
        /// Optional element 'ns2:postalCode' of XSD type 'xsd:string'
        std::string *postalCode;
        /// Optional element 'ns2:recurringAmount' of XSD type 'xsd:string'
        std::string *recurringAmount;
        /// Optional element 'ns2:setupAmount' of XSD type 'xsd:string'
        std::string *setupAmount;
        /// Optional element 'ns2:startDate' of XSD type 'xsd:string'
        std::string *startDate;
        /// Optional element 'ns2:state' of XSD type 'xsd:string'
        std::string *state;
        /// Optional element 'ns2:status' of XSD type 'xsd:string'
        std::string *status;
        /// Optional element 'ns2:street1' of XSD type 'xsd:string'
        std::string *street1;
        /// Optional element 'ns2:street2' of XSD type 'xsd:string'
        std::string *street2;
        /// Optional element 'ns2:subscriptionID' of XSD type 'xsd:string'
        std::string *subscriptionID;
        /// Required element 'ns2:subscriptionIDNew' of XSD type 'xsd:string'
        std::string subscriptionIDNew;
        /// Optional element 'ns2:title' of XSD type 'xsd:string'
        std::string *title;
        /// Optional element 'ns2:totalPayments' of XSD type 'xsd:string'
        std::string *totalPayments;
        /// Optional element 'ns2:shipToFirstName' of XSD type 'xsd:string'
        std::string *shipToFirstName;
        /// Optional element 'ns2:shipToLastName' of XSD type 'xsd:string'
        std::string *shipToLastName;
        /// Optional element 'ns2:shipToStreet1' of XSD type 'xsd:string'
        std::string *shipToStreet1;
        /// Optional element 'ns2:shipToStreet2' of XSD type 'xsd:string'
        std::string *shipToStreet2;
        /// Optional element 'ns2:shipToCity' of XSD type 'xsd:string'
        std::string *shipToCity;
        /// Optional element 'ns2:shipToState' of XSD type 'xsd:string'
        std::string *shipToState;
        /// Optional element 'ns2:shipToPostalCode' of XSD type 'xsd:string'
        std::string *shipToPostalCode;
        /// Optional element 'ns2:shipToCompany' of XSD type 'xsd:string'
        std::string *shipToCompany;
        /// Optional element 'ns2:shipToCountry' of XSD type 'xsd:string'
        std::string *shipToCountry;
        /// Optional element 'ns2:billPayment' of XSD type 'xsd:string'
        std::string *billPayment;
        /// Optional element 'ns2:merchantDefinedDataField1' of XSD type 'xsd:string'
        std::string *merchantDefinedDataField1;
        /// Optional element 'ns2:merchantDefinedDataField2' of XSD type 'xsd:string'
        std::string *merchantDefinedDataField2;
        /// Optional element 'ns2:merchantDefinedDataField3' of XSD type 'xsd:string'
        std::string *merchantDefinedDataField3;
        /// Optional element 'ns2:merchantDefinedDataField4' of XSD type 'xsd:string'
        std::string *merchantDefinedDataField4;
        /// Optional element 'ns2:merchantSecureDataField1' of XSD type 'xsd:string'
        std::string *merchantSecureDataField1;
        /// Optional element 'ns2:merchantSecureDataField2' of XSD type 'xsd:string'
        std::string *merchantSecureDataField2;
        /// Optional element 'ns2:merchantSecureDataField3' of XSD type 'xsd:string'
        std::string *merchantSecureDataField3;
        /// Optional element 'ns2:merchantSecureDataField4' of XSD type 'xsd:string'
        std::string *merchantSecureDataField4;
        /// Optional element 'ns2:ownerMerchantID' of XSD type 'xsd:string'
        std::string *ownerMerchantID;
        /// Optional element 'ns2:companyTaxID' of XSD type 'xsd:string'
        std::string *companyTaxID;
        /// Optional element 'ns2:driversLicenseNumber' of XSD type 'xsd:string'
        std::string *driversLicenseNumber;
        /// Optional element 'ns2:driversLicenseState' of XSD type 'xsd:string'
        std::string *driversLicenseState;
        /// Optional element 'ns2:dateOfBirth' of XSD type 'xsd:string'
        std::string *dateOfBirth;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PaySubscriptionRetrieveReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PaySubscriptionRetrieveReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PaySubscriptionRetrieveReply, default initialized and not managed by a soap context
        virtual ns2__PaySubscriptionRetrieveReply *soap_alloc(void) const { return SOAP_NEW(ns2__PaySubscriptionRetrieveReply); }
      public:
        /// Constructor with initializations
        ns2__PaySubscriptionRetrieveReply()
        {
          approvalRequired = (std::string *)0;
          automaticRenew = (std::string *)0;
          cardAccountNumber = (std::string *)0;
          cardExpirationMonth = (std::string *)0;
          cardExpirationYear = (std::string *)0;
          cardIssueNumber = (std::string *)0;
          cardStartMonth = (std::string *)0;
          cardStartYear = (std::string *)0;
          cardType = (std::string *)0;
          checkAccountNumber = (std::string *)0;
          checkAccountType = (std::string *)0;
          checkBankTransitNumber = (std::string *)0;
          checkSecCode = (std::string *)0;
          checkAuthenticateID = (std::string *)0;
          city = (std::string *)0;
          comments = (std::string *)0;
          companyName = (std::string *)0;
          country = (std::string *)0;
          currency = (std::string *)0;
          customerAccountID = (std::string *)0;
          email = (std::string *)0;
          endDate = (std::string *)0;
          firstName = (std::string *)0;
          frequency = (std::string *)0;
          lastName = (std::string *)0;
          merchantReferenceCode = (std::string *)0;
          paymentMethod = (std::string *)0;
          paymentsRemaining = (std::string *)0;
          phoneNumber = (std::string *)0;
          postalCode = (std::string *)0;
          recurringAmount = (std::string *)0;
          setupAmount = (std::string *)0;
          startDate = (std::string *)0;
          state = (std::string *)0;
          status = (std::string *)0;
          street1 = (std::string *)0;
          street2 = (std::string *)0;
          subscriptionID = (std::string *)0;
          title = (std::string *)0;
          totalPayments = (std::string *)0;
          shipToFirstName = (std::string *)0;
          shipToLastName = (std::string *)0;
          shipToStreet1 = (std::string *)0;
          shipToStreet2 = (std::string *)0;
          shipToCity = (std::string *)0;
          shipToState = (std::string *)0;
          shipToPostalCode = (std::string *)0;
          shipToCompany = (std::string *)0;
          shipToCountry = (std::string *)0;
          billPayment = (std::string *)0;
          merchantDefinedDataField1 = (std::string *)0;
          merchantDefinedDataField2 = (std::string *)0;
          merchantDefinedDataField3 = (std::string *)0;
          merchantDefinedDataField4 = (std::string *)0;
          merchantSecureDataField1 = (std::string *)0;
          merchantSecureDataField2 = (std::string *)0;
          merchantSecureDataField3 = (std::string *)0;
          merchantSecureDataField4 = (std::string *)0;
          ownerMerchantID = (std::string *)0;
          companyTaxID = (std::string *)0;
          driversLicenseNumber = (std::string *)0;
          driversLicenseState = (std::string *)0;
          dateOfBirth = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PaySubscriptionRetrieveReply() { }
        /// Friend allocator used by soap_new_ns2__PaySubscriptionRetrieveReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__PaySubscriptionRetrieveReply * SOAP_FMAC2 soap_instantiate_ns2__PaySubscriptionRetrieveReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:636 */
#ifndef SOAP_TYPE_ns2__PaySubscriptionDeleteReply
#define SOAP_TYPE_ns2__PaySubscriptionDeleteReply (271)
/* complex XSD type 'ns2:PaySubscriptionDeleteReply': */
class SOAP_CMAC ns2__PaySubscriptionDeleteReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Required element 'ns2:subscriptionID' of XSD type 'xsd:string'
        std::string subscriptionID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PaySubscriptionDeleteReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PaySubscriptionDeleteReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PaySubscriptionDeleteReply, default initialized and not managed by a soap context
        virtual ns2__PaySubscriptionDeleteReply *soap_alloc(void) const { return SOAP_NEW(ns2__PaySubscriptionDeleteReply); }
      public:
        /// Constructor with initializations
        ns2__PaySubscriptionDeleteReply()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__PaySubscriptionDeleteReply() { }
        /// Friend allocator used by soap_new_ns2__PaySubscriptionDeleteReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__PaySubscriptionDeleteReply * SOAP_FMAC2 soap_instantiate_ns2__PaySubscriptionDeleteReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:639 */
#ifndef SOAP_TYPE_ns2__PayPalPaymentReply
#define SOAP_TYPE_ns2__PayPalPaymentReply (272)
/* complex XSD type 'ns2:PayPalPaymentReply': */
class SOAP_CMAC ns2__PayPalPaymentReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:secureData' of XSD type 'xsd:string'
        std::string *secureData;
        /// Optional element 'ns2:amount' of XSD type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:requestDateTime' of XSD type 'ns2:dateTime'
        std::string *requestDateTime;
        /// Optional element 'ns2:reconciliationID' of XSD type 'xsd:string'
        std::string *reconciliationID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalPaymentReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PayPalPaymentReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalPaymentReply, default initialized and not managed by a soap context
        virtual ns2__PayPalPaymentReply *soap_alloc(void) const { return SOAP_NEW(ns2__PayPalPaymentReply); }
      public:
        /// Constructor with initializations
        ns2__PayPalPaymentReply()
        {
          secureData = (std::string *)0;
          amount = (std::string *)0;
          requestDateTime = (std::string *)0;
          reconciliationID = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PayPalPaymentReply() { }
        /// Friend allocator used by soap_new_ns2__PayPalPaymentReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalPaymentReply * SOAP_FMAC2 soap_instantiate_ns2__PayPalPaymentReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:642 */
#ifndef SOAP_TYPE_ns2__PayPalCreditReply
#define SOAP_TYPE_ns2__PayPalCreditReply (273)
/* complex XSD type 'ns2:PayPalCreditReply': */
class SOAP_CMAC ns2__PayPalCreditReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:amount' of XSD type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:requestDateTime' of XSD type 'ns2:dateTime'
        std::string *requestDateTime;
        /// Optional element 'ns2:reconciliationID' of XSD type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:processorResponse' of XSD type 'xsd:string'
        std::string *processorResponse;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalCreditReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PayPalCreditReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalCreditReply, default initialized and not managed by a soap context
        virtual ns2__PayPalCreditReply *soap_alloc(void) const { return SOAP_NEW(ns2__PayPalCreditReply); }
      public:
        /// Constructor with initializations
        ns2__PayPalCreditReply()
        {
          amount = (std::string *)0;
          requestDateTime = (std::string *)0;
          reconciliationID = (std::string *)0;
          processorResponse = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PayPalCreditReply() { }
        /// Friend allocator used by soap_new_ns2__PayPalCreditReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalCreditReply * SOAP_FMAC2 soap_instantiate_ns2__PayPalCreditReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:645 */
#ifndef SOAP_TYPE_ns2__VoidReply
#define SOAP_TYPE_ns2__VoidReply (274)
/* complex XSD type 'ns2:VoidReply': */
class SOAP_CMAC ns2__VoidReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:requestDateTime' of XSD type 'ns2:dateTime'
        std::string *requestDateTime;
        /// Optional element 'ns2:amount' of XSD type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:currency' of XSD type 'xsd:string'
        std::string *currency;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__VoidReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__VoidReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__VoidReply, default initialized and not managed by a soap context
        virtual ns2__VoidReply *soap_alloc(void) const { return SOAP_NEW(ns2__VoidReply); }
      public:
        /// Constructor with initializations
        ns2__VoidReply()
        {
          requestDateTime = (std::string *)0;
          amount = (std::string *)0;
          currency = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__VoidReply() { }
        /// Friend allocator used by soap_new_ns2__VoidReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__VoidReply * SOAP_FMAC2 soap_instantiate_ns2__VoidReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:648 */
#ifndef SOAP_TYPE_ns2__PinlessDebitReply
#define SOAP_TYPE_ns2__PinlessDebitReply (275)
/* complex XSD type 'ns2:PinlessDebitReply': */
class SOAP_CMAC ns2__PinlessDebitReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:amount' of XSD type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:authorizationCode' of XSD type 'xsd:string'
        std::string *authorizationCode;
        /// Optional element 'ns2:requestDateTime' of XSD type 'ns2:dateTime'
        std::string *requestDateTime;
        /// Optional element 'ns2:processorResponse' of XSD type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:receiptNumber' of XSD type 'xsd:string'
        std::string *receiptNumber;
        /// Optional element 'ns2:reconciliationID' of XSD type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:ownerMerchantID' of XSD type 'xsd:string'
        std::string *ownerMerchantID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PinlessDebitReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PinlessDebitReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PinlessDebitReply, default initialized and not managed by a soap context
        virtual ns2__PinlessDebitReply *soap_alloc(void) const { return SOAP_NEW(ns2__PinlessDebitReply); }
      public:
        /// Constructor with initializations
        ns2__PinlessDebitReply()
        {
          amount = (std::string *)0;
          authorizationCode = (std::string *)0;
          requestDateTime = (std::string *)0;
          processorResponse = (std::string *)0;
          receiptNumber = (std::string *)0;
          reconciliationID = (std::string *)0;
          ownerMerchantID = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PinlessDebitReply() { }
        /// Friend allocator used by soap_new_ns2__PinlessDebitReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__PinlessDebitReply * SOAP_FMAC2 soap_instantiate_ns2__PinlessDebitReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:651 */
#ifndef SOAP_TYPE_ns2__PinlessDebitValidateReply
#define SOAP_TYPE_ns2__PinlessDebitValidateReply (276)
/* complex XSD type 'ns2:PinlessDebitValidateReply': */
class SOAP_CMAC ns2__PinlessDebitValidateReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:status' of XSD type 'xsd:string'
        std::string *status;
        /// Optional element 'ns2:requestDateTime' of XSD type 'ns2:dateTime'
        std::string *requestDateTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PinlessDebitValidateReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PinlessDebitValidateReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PinlessDebitValidateReply, default initialized and not managed by a soap context
        virtual ns2__PinlessDebitValidateReply *soap_alloc(void) const { return SOAP_NEW(ns2__PinlessDebitValidateReply); }
      public:
        /// Constructor with initializations
        ns2__PinlessDebitValidateReply()
        {
          status = (std::string *)0;
          requestDateTime = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PinlessDebitValidateReply() { }
        /// Friend allocator used by soap_new_ns2__PinlessDebitValidateReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__PinlessDebitValidateReply * SOAP_FMAC2 soap_instantiate_ns2__PinlessDebitValidateReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:654 */
#ifndef SOAP_TYPE_ns2__PinlessDebitReversalReply
#define SOAP_TYPE_ns2__PinlessDebitReversalReply (277)
/* complex XSD type 'ns2:PinlessDebitReversalReply': */
class SOAP_CMAC ns2__PinlessDebitReversalReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:amount' of XSD type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:requestDateTime' of XSD type 'ns2:dateTime'
        std::string *requestDateTime;
        /// Optional element 'ns2:processorResponse' of XSD type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:reconciliationID' of XSD type 'xsd:string'
        std::string *reconciliationID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PinlessDebitReversalReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PinlessDebitReversalReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PinlessDebitReversalReply, default initialized and not managed by a soap context
        virtual ns2__PinlessDebitReversalReply *soap_alloc(void) const { return SOAP_NEW(ns2__PinlessDebitReversalReply); }
      public:
        /// Constructor with initializations
        ns2__PinlessDebitReversalReply()
        {
          amount = (std::string *)0;
          requestDateTime = (std::string *)0;
          processorResponse = (std::string *)0;
          reconciliationID = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PinlessDebitReversalReply() { }
        /// Friend allocator used by soap_new_ns2__PinlessDebitReversalReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__PinlessDebitReversalReply * SOAP_FMAC2 soap_instantiate_ns2__PinlessDebitReversalReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:657 */
#ifndef SOAP_TYPE_ns2__PayPalButtonCreateReply
#define SOAP_TYPE_ns2__PayPalButtonCreateReply (278)
/* complex XSD type 'ns2:PayPalButtonCreateReply': */
class SOAP_CMAC ns2__PayPalButtonCreateReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:encryptedFormData' of XSD type 'xsd:string'
        std::string *encryptedFormData;
        /// Optional element 'ns2:unencryptedFormData' of XSD type 'xsd:string'
        std::string *unencryptedFormData;
        /// Optional element 'ns2:requestDateTime' of XSD type 'ns2:dateTime'
        std::string *requestDateTime;
        /// Optional element 'ns2:reconciliationID' of XSD type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:buttonType' of XSD type 'xsd:string'
        std::string *buttonType;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalButtonCreateReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PayPalButtonCreateReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalButtonCreateReply, default initialized and not managed by a soap context
        virtual ns2__PayPalButtonCreateReply *soap_alloc(void) const { return SOAP_NEW(ns2__PayPalButtonCreateReply); }
      public:
        /// Constructor with initializations
        ns2__PayPalButtonCreateReply()
        {
          encryptedFormData = (std::string *)0;
          unencryptedFormData = (std::string *)0;
          requestDateTime = (std::string *)0;
          reconciliationID = (std::string *)0;
          buttonType = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PayPalButtonCreateReply() { }
        /// Friend allocator used by soap_new_ns2__PayPalButtonCreateReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalButtonCreateReply * SOAP_FMAC2 soap_instantiate_ns2__PayPalButtonCreateReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:660 */
#ifndef SOAP_TYPE_ns2__PayPalPreapprovedPaymentReply
#define SOAP_TYPE_ns2__PayPalPreapprovedPaymentReply (279)
/* complex XSD type 'ns2:PayPalPreapprovedPaymentReply': */
class SOAP_CMAC ns2__PayPalPreapprovedPaymentReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:requestDateTime' of XSD type 'ns2:dateTime'
        std::string *requestDateTime;
        /// Optional element 'ns2:reconciliationID' of XSD type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:payerStatus' of XSD type 'xsd:string'
        std::string *payerStatus;
        /// Optional element 'ns2:payerName' of XSD type 'xsd:string'
        std::string *payerName;
        /// Optional element 'ns2:transactionType' of XSD type 'xsd:string'
        std::string *transactionType;
        /// Optional element 'ns2:feeAmount' of XSD type 'xsd:string'
        std::string *feeAmount;
        /// Optional element 'ns2:payerCountry' of XSD type 'xsd:string'
        std::string *payerCountry;
        /// Optional element 'ns2:pendingReason' of XSD type 'xsd:string'
        std::string *pendingReason;
        /// Optional element 'ns2:paymentStatus' of XSD type 'xsd:string'
        std::string *paymentStatus;
        /// Optional element 'ns2:mpStatus' of XSD type 'xsd:string'
        std::string *mpStatus;
        /// Optional element 'ns2:payer' of XSD type 'xsd:string'
        std::string *payer;
        /// Optional element 'ns2:payerID' of XSD type 'xsd:string'
        std::string *payerID;
        /// Optional element 'ns2:payerBusiness' of XSD type 'xsd:string'
        std::string *payerBusiness;
        /// Optional element 'ns2:transactionID' of XSD type 'xsd:string'
        std::string *transactionID;
        /// Optional element 'ns2:desc' of XSD type 'xsd:string'
        std::string *desc;
        /// Optional element 'ns2:mpMax' of XSD type 'xsd:string'
        std::string *mpMax;
        /// Optional element 'ns2:paymentType' of XSD type 'xsd:string'
        std::string *paymentType;
        /// Optional element 'ns2:paymentDate' of XSD type 'xsd:string'
        std::string *paymentDate;
        /// Optional element 'ns2:paymentGrossAmount' of XSD type 'xsd:string'
        std::string *paymentGrossAmount;
        /// Optional element 'ns2:settleAmount' of XSD type 'xsd:string'
        std::string *settleAmount;
        /// Optional element 'ns2:taxAmount' of XSD type 'xsd:string'
        std::string *taxAmount;
        /// Optional element 'ns2:exchangeRate' of XSD type 'xsd:string'
        std::string *exchangeRate;
        /// Optional element 'ns2:paymentSourceID' of XSD type 'xsd:string'
        std::string *paymentSourceID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalPreapprovedPaymentReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PayPalPreapprovedPaymentReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalPreapprovedPaymentReply, default initialized and not managed by a soap context
        virtual ns2__PayPalPreapprovedPaymentReply *soap_alloc(void) const { return SOAP_NEW(ns2__PayPalPreapprovedPaymentReply); }
      public:
        /// Constructor with initializations
        ns2__PayPalPreapprovedPaymentReply()
        {
          requestDateTime = (std::string *)0;
          reconciliationID = (std::string *)0;
          payerStatus = (std::string *)0;
          payerName = (std::string *)0;
          transactionType = (std::string *)0;
          feeAmount = (std::string *)0;
          payerCountry = (std::string *)0;
          pendingReason = (std::string *)0;
          paymentStatus = (std::string *)0;
          mpStatus = (std::string *)0;
          payer = (std::string *)0;
          payerID = (std::string *)0;
          payerBusiness = (std::string *)0;
          transactionID = (std::string *)0;
          desc = (std::string *)0;
          mpMax = (std::string *)0;
          paymentType = (std::string *)0;
          paymentDate = (std::string *)0;
          paymentGrossAmount = (std::string *)0;
          settleAmount = (std::string *)0;
          taxAmount = (std::string *)0;
          exchangeRate = (std::string *)0;
          paymentSourceID = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PayPalPreapprovedPaymentReply() { }
        /// Friend allocator used by soap_new_ns2__PayPalPreapprovedPaymentReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalPreapprovedPaymentReply * SOAP_FMAC2 soap_instantiate_ns2__PayPalPreapprovedPaymentReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:663 */
#ifndef SOAP_TYPE_ns2__PayPalPreapprovedUpdateReply
#define SOAP_TYPE_ns2__PayPalPreapprovedUpdateReply (280)
/* complex XSD type 'ns2:PayPalPreapprovedUpdateReply': */
class SOAP_CMAC ns2__PayPalPreapprovedUpdateReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:requestDateTime' of XSD type 'ns2:dateTime'
        std::string *requestDateTime;
        /// Optional element 'ns2:reconciliationID' of XSD type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:payerStatus' of XSD type 'xsd:string'
        std::string *payerStatus;
        /// Optional element 'ns2:payerName' of XSD type 'xsd:string'
        std::string *payerName;
        /// Optional element 'ns2:payerCountry' of XSD type 'xsd:string'
        std::string *payerCountry;
        /// Optional element 'ns2:mpStatus' of XSD type 'xsd:string'
        std::string *mpStatus;
        /// Optional element 'ns2:payer' of XSD type 'xsd:string'
        std::string *payer;
        /// Optional element 'ns2:payerID' of XSD type 'xsd:string'
        std::string *payerID;
        /// Optional element 'ns2:payerBusiness' of XSD type 'xsd:string'
        std::string *payerBusiness;
        /// Optional element 'ns2:desc' of XSD type 'xsd:string'
        std::string *desc;
        /// Optional element 'ns2:mpMax' of XSD type 'xsd:string'
        std::string *mpMax;
        /// Optional element 'ns2:paymentSourceID' of XSD type 'xsd:string'
        std::string *paymentSourceID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalPreapprovedUpdateReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PayPalPreapprovedUpdateReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalPreapprovedUpdateReply, default initialized and not managed by a soap context
        virtual ns2__PayPalPreapprovedUpdateReply *soap_alloc(void) const { return SOAP_NEW(ns2__PayPalPreapprovedUpdateReply); }
      public:
        /// Constructor with initializations
        ns2__PayPalPreapprovedUpdateReply()
        {
          requestDateTime = (std::string *)0;
          reconciliationID = (std::string *)0;
          payerStatus = (std::string *)0;
          payerName = (std::string *)0;
          payerCountry = (std::string *)0;
          mpStatus = (std::string *)0;
          payer = (std::string *)0;
          payerID = (std::string *)0;
          payerBusiness = (std::string *)0;
          desc = (std::string *)0;
          mpMax = (std::string *)0;
          paymentSourceID = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PayPalPreapprovedUpdateReply() { }
        /// Friend allocator used by soap_new_ns2__PayPalPreapprovedUpdateReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalPreapprovedUpdateReply * SOAP_FMAC2 soap_instantiate_ns2__PayPalPreapprovedUpdateReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:666 */
#ifndef SOAP_TYPE_ns2__PayPalEcSetReply
#define SOAP_TYPE_ns2__PayPalEcSetReply (281)
/* complex XSD type 'ns2:PayPalEcSetReply': */
class SOAP_CMAC ns2__PayPalEcSetReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:paypalToken' of XSD type 'xsd:string'
        std::string *paypalToken;
        /// Optional element 'ns2:amount' of XSD type 'xsd:string'
        std::string *amount;
        /// Optional element 'ns2:currency' of XSD type 'xsd:string'
        std::string *currency;
        /// Optional element 'ns2:correlationID' of XSD type 'xsd:string'
        std::string *correlationID;
        /// Optional element 'ns2:errorCode' of XSD type 'xsd:string'
        std::string *errorCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalEcSetReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PayPalEcSetReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalEcSetReply, default initialized and not managed by a soap context
        virtual ns2__PayPalEcSetReply *soap_alloc(void) const { return SOAP_NEW(ns2__PayPalEcSetReply); }
      public:
        /// Constructor with initializations
        ns2__PayPalEcSetReply()
        {
          paypalToken = (std::string *)0;
          amount = (std::string *)0;
          currency = (std::string *)0;
          correlationID = (std::string *)0;
          errorCode = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PayPalEcSetReply() { }
        /// Friend allocator used by soap_new_ns2__PayPalEcSetReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalEcSetReply * SOAP_FMAC2 soap_instantiate_ns2__PayPalEcSetReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:669 */
#ifndef SOAP_TYPE_ns2__PayPalEcGetDetailsReply
#define SOAP_TYPE_ns2__PayPalEcGetDetailsReply (282)
/* complex XSD type 'ns2:PayPalEcGetDetailsReply': */
class SOAP_CMAC ns2__PayPalEcGetDetailsReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:paypalToken' of XSD type 'xsd:string'
        std::string *paypalToken;
        /// Optional element 'ns2:payer' of XSD type 'xsd:string'
        std::string *payer;
        /// Optional element 'ns2:payerId' of XSD type 'xsd:string'
        std::string *payerId;
        /// Optional element 'ns2:payerStatus' of XSD type 'xsd:string'
        std::string *payerStatus;
        /// Optional element 'ns2:payerSalutation' of XSD type 'xsd:string'
        std::string *payerSalutation;
        /// Optional element 'ns2:payerFirstname' of XSD type 'xsd:string'
        std::string *payerFirstname;
        /// Optional element 'ns2:payerMiddlename' of XSD type 'xsd:string'
        std::string *payerMiddlename;
        /// Optional element 'ns2:payerLastname' of XSD type 'xsd:string'
        std::string *payerLastname;
        /// Optional element 'ns2:payerSuffix' of XSD type 'xsd:string'
        std::string *payerSuffix;
        /// Optional element 'ns2:payerCountry' of XSD type 'xsd:string'
        std::string *payerCountry;
        /// Optional element 'ns2:payerBusiness' of XSD type 'xsd:string'
        std::string *payerBusiness;
        /// Optional element 'ns2:shipToName' of XSD type 'xsd:string'
        std::string *shipToName;
        /// Optional element 'ns2:shipToAddress1' of XSD type 'xsd:string'
        std::string *shipToAddress1;
        /// Optional element 'ns2:shipToAddress2' of XSD type 'xsd:string'
        std::string *shipToAddress2;
        /// Optional element 'ns2:shipToCity' of XSD type 'xsd:string'
        std::string *shipToCity;
        /// Optional element 'ns2:shipToState' of XSD type 'xsd:string'
        std::string *shipToState;
        /// Optional element 'ns2:shipToCountry' of XSD type 'xsd:string'
        std::string *shipToCountry;
        /// Optional element 'ns2:shipToZip' of XSD type 'xsd:string'
        std::string *shipToZip;
        /// Optional element 'ns2:addressStatus' of XSD type 'xsd:string'
        std::string *addressStatus;
        /// Optional element 'ns2:payerPhone' of XSD type 'xsd:string'
        std::string *payerPhone;
        /// Optional element 'ns2:avsCode' of XSD type 'xsd:string'
        std::string *avsCode;
        /// Optional element 'ns2:street1' of XSD type 'xsd:string'
        std::string *street1;
        /// Optional element 'ns2:street2' of XSD type 'xsd:string'
        std::string *street2;
        /// Optional element 'ns2:city' of XSD type 'xsd:string'
        std::string *city;
        /// Optional element 'ns2:state' of XSD type 'xsd:string'
        std::string *state;
        /// Optional element 'ns2:postalCode' of XSD type 'xsd:string'
        std::string *postalCode;
        /// Optional element 'ns2:countryCode' of XSD type 'xsd:string'
        std::string *countryCode;
        /// Optional element 'ns2:countryName' of XSD type 'xsd:string'
        std::string *countryName;
        /// Optional element 'ns2:addressID' of XSD type 'xsd:string'
        std::string *addressID;
        /// Optional element 'ns2:errorCode' of XSD type 'xsd:string'
        std::string *errorCode;
        /// Optional element 'ns2:correlationID' of XSD type 'xsd:string'
        std::string *correlationID;
        /// Optional element 'ns2:paypalBillingAgreementAcceptedStatus' of XSD type 'xsd:string'
        std::string *paypalBillingAgreementAcceptedStatus;
        /// Optional element 'ns2:paypalTaxAmount' of XSD type 'xsd:string'
        std::string *paypalTaxAmount;
        /// Sequence of 0 to 1000 elements 'ns2:item' of XSD type 'ns2:Item'
        std::vector<ns2__Item *> item;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalEcGetDetailsReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PayPalEcGetDetailsReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalEcGetDetailsReply, default initialized and not managed by a soap context
        virtual ns2__PayPalEcGetDetailsReply *soap_alloc(void) const { return SOAP_NEW(ns2__PayPalEcGetDetailsReply); }
      public:
        /// Constructor with initializations
        ns2__PayPalEcGetDetailsReply()
        {
          paypalToken = (std::string *)0;
          payer = (std::string *)0;
          payerId = (std::string *)0;
          payerStatus = (std::string *)0;
          payerSalutation = (std::string *)0;
          payerFirstname = (std::string *)0;
          payerMiddlename = (std::string *)0;
          payerLastname = (std::string *)0;
          payerSuffix = (std::string *)0;
          payerCountry = (std::string *)0;
          payerBusiness = (std::string *)0;
          shipToName = (std::string *)0;
          shipToAddress1 = (std::string *)0;
          shipToAddress2 = (std::string *)0;
          shipToCity = (std::string *)0;
          shipToState = (std::string *)0;
          shipToCountry = (std::string *)0;
          shipToZip = (std::string *)0;
          addressStatus = (std::string *)0;
          payerPhone = (std::string *)0;
          avsCode = (std::string *)0;
          street1 = (std::string *)0;
          street2 = (std::string *)0;
          city = (std::string *)0;
          state = (std::string *)0;
          postalCode = (std::string *)0;
          countryCode = (std::string *)0;
          countryName = (std::string *)0;
          addressID = (std::string *)0;
          errorCode = (std::string *)0;
          correlationID = (std::string *)0;
          paypalBillingAgreementAcceptedStatus = (std::string *)0;
          paypalTaxAmount = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PayPalEcGetDetailsReply() { }
        /// Friend allocator used by soap_new_ns2__PayPalEcGetDetailsReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalEcGetDetailsReply * SOAP_FMAC2 soap_instantiate_ns2__PayPalEcGetDetailsReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:672 */
#ifndef SOAP_TYPE_ns2__PayPalEcDoPaymentReply
#define SOAP_TYPE_ns2__PayPalEcDoPaymentReply (283)
/* complex XSD type 'ns2:PayPalEcDoPaymentReply': */
class SOAP_CMAC ns2__PayPalEcDoPaymentReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:paypalToken' of XSD type 'xsd:string'
        std::string *paypalToken;
        /// Optional element 'ns2:transactionId' of XSD type 'xsd:string'
        std::string *transactionId;
        /// Optional element 'ns2:paypalTransactiontype' of XSD type 'xsd:string'
        std::string *paypalTransactiontype;
        /// Optional element 'ns2:paymentType' of XSD type 'xsd:string'
        std::string *paymentType;
        /// Optional element 'ns2:paypalOrderTime' of XSD type 'xsd:string'
        std::string *paypalOrderTime;
        /// Optional element 'ns2:paypalAmount' of XSD type 'xsd:string'
        std::string *paypalAmount;
        /// Optional element 'ns2:paypalFeeAmount' of XSD type 'xsd:string'
        std::string *paypalFeeAmount;
        /// Optional element 'ns2:paypalTaxAmount' of XSD type 'xsd:string'
        std::string *paypalTaxAmount;
        /// Optional element 'ns2:paypalExchangeRate' of XSD type 'xsd:string'
        std::string *paypalExchangeRate;
        /// Optional element 'ns2:paypalPaymentStatus' of XSD type 'xsd:string'
        std::string *paypalPaymentStatus;
        /// Optional element 'ns2:paypalPendingReason' of XSD type 'xsd:string'
        std::string *paypalPendingReason;
        /// Optional element 'ns2:orderId' of XSD type 'xsd:string'
        std::string *orderId;
        /// Optional element 'ns2:paypalReasonCode' of XSD type 'xsd:string'
        std::string *paypalReasonCode;
        /// Optional element 'ns2:amount' of XSD type 'xsd:string'
        std::string *amount;
        /// Optional element 'ns2:currency' of XSD type 'xsd:string'
        std::string *currency;
        /// Optional element 'ns2:correlationID' of XSD type 'xsd:string'
        std::string *correlationID;
        /// Optional element 'ns2:errorCode' of XSD type 'xsd:string'
        std::string *errorCode;
        /// Optional element 'ns2:paypalBillingAgreementId' of XSD type 'xsd:string'
        std::string *paypalBillingAgreementId;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalEcDoPaymentReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PayPalEcDoPaymentReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalEcDoPaymentReply, default initialized and not managed by a soap context
        virtual ns2__PayPalEcDoPaymentReply *soap_alloc(void) const { return SOAP_NEW(ns2__PayPalEcDoPaymentReply); }
      public:
        /// Constructor with initializations
        ns2__PayPalEcDoPaymentReply()
        {
          paypalToken = (std::string *)0;
          transactionId = (std::string *)0;
          paypalTransactiontype = (std::string *)0;
          paymentType = (std::string *)0;
          paypalOrderTime = (std::string *)0;
          paypalAmount = (std::string *)0;
          paypalFeeAmount = (std::string *)0;
          paypalTaxAmount = (std::string *)0;
          paypalExchangeRate = (std::string *)0;
          paypalPaymentStatus = (std::string *)0;
          paypalPendingReason = (std::string *)0;
          orderId = (std::string *)0;
          paypalReasonCode = (std::string *)0;
          amount = (std::string *)0;
          currency = (std::string *)0;
          correlationID = (std::string *)0;
          errorCode = (std::string *)0;
          paypalBillingAgreementId = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PayPalEcDoPaymentReply() { }
        /// Friend allocator used by soap_new_ns2__PayPalEcDoPaymentReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalEcDoPaymentReply * SOAP_FMAC2 soap_instantiate_ns2__PayPalEcDoPaymentReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:675 */
#ifndef SOAP_TYPE_ns2__PayPalDoCaptureReply
#define SOAP_TYPE_ns2__PayPalDoCaptureReply (284)
/* complex XSD type 'ns2:PayPalDoCaptureReply': */
class SOAP_CMAC ns2__PayPalDoCaptureReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:authorizationId' of XSD type 'xsd:string'
        std::string *authorizationId;
        /// Optional element 'ns2:transactionId' of XSD type 'xsd:string'
        std::string *transactionId;
        /// Optional element 'ns2:parentTransactionId' of XSD type 'xsd:string'
        std::string *parentTransactionId;
        /// Optional element 'ns2:paypalReceiptId' of XSD type 'xsd:string'
        std::string *paypalReceiptId;
        /// Optional element 'ns2:paypalTransactiontype' of XSD type 'xsd:string'
        std::string *paypalTransactiontype;
        /// Optional element 'ns2:paypalPaymentType' of XSD type 'xsd:string'
        std::string *paypalPaymentType;
        /// Optional element 'ns2:paypalOrderTime' of XSD type 'xsd:string'
        std::string *paypalOrderTime;
        /// Optional element 'ns2:paypalPaymentGrossAmount' of XSD type 'xsd:string'
        std::string *paypalPaymentGrossAmount;
        /// Optional element 'ns2:paypalFeeAmount' of XSD type 'xsd:string'
        std::string *paypalFeeAmount;
        /// Optional element 'ns2:paypalTaxAmount' of XSD type 'xsd:string'
        std::string *paypalTaxAmount;
        /// Optional element 'ns2:paypalExchangeRate' of XSD type 'xsd:string'
        std::string *paypalExchangeRate;
        /// Optional element 'ns2:paypalPaymentStatus' of XSD type 'xsd:string'
        std::string *paypalPaymentStatus;
        /// Optional element 'ns2:amount' of XSD type 'xsd:string'
        std::string *amount;
        /// Optional element 'ns2:currency' of XSD type 'xsd:string'
        std::string *currency;
        /// Optional element 'ns2:correlationID' of XSD type 'xsd:string'
        std::string *correlationID;
        /// Optional element 'ns2:errorCode' of XSD type 'xsd:string'
        std::string *errorCode;
        /// Optional element 'ns2:paypalPendingReason' of XSD type 'xsd:string'
        std::string *paypalPendingReason;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalDoCaptureReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PayPalDoCaptureReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalDoCaptureReply, default initialized and not managed by a soap context
        virtual ns2__PayPalDoCaptureReply *soap_alloc(void) const { return SOAP_NEW(ns2__PayPalDoCaptureReply); }
      public:
        /// Constructor with initializations
        ns2__PayPalDoCaptureReply()
        {
          authorizationId = (std::string *)0;
          transactionId = (std::string *)0;
          parentTransactionId = (std::string *)0;
          paypalReceiptId = (std::string *)0;
          paypalTransactiontype = (std::string *)0;
          paypalPaymentType = (std::string *)0;
          paypalOrderTime = (std::string *)0;
          paypalPaymentGrossAmount = (std::string *)0;
          paypalFeeAmount = (std::string *)0;
          paypalTaxAmount = (std::string *)0;
          paypalExchangeRate = (std::string *)0;
          paypalPaymentStatus = (std::string *)0;
          amount = (std::string *)0;
          currency = (std::string *)0;
          correlationID = (std::string *)0;
          errorCode = (std::string *)0;
          paypalPendingReason = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PayPalDoCaptureReply() { }
        /// Friend allocator used by soap_new_ns2__PayPalDoCaptureReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalDoCaptureReply * SOAP_FMAC2 soap_instantiate_ns2__PayPalDoCaptureReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:678 */
#ifndef SOAP_TYPE_ns2__PayPalAuthReversalReply
#define SOAP_TYPE_ns2__PayPalAuthReversalReply (285)
/* complex XSD type 'ns2:PayPalAuthReversalReply': */
class SOAP_CMAC ns2__PayPalAuthReversalReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:authorizationId' of XSD type 'xsd:string'
        std::string *authorizationId;
        /// Optional element 'ns2:correlationID' of XSD type 'xsd:string'
        std::string *correlationID;
        /// Optional element 'ns2:errorCode' of XSD type 'xsd:string'
        std::string *errorCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalAuthReversalReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PayPalAuthReversalReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalAuthReversalReply, default initialized and not managed by a soap context
        virtual ns2__PayPalAuthReversalReply *soap_alloc(void) const { return SOAP_NEW(ns2__PayPalAuthReversalReply); }
      public:
        /// Constructor with initializations
        ns2__PayPalAuthReversalReply()
        {
          authorizationId = (std::string *)0;
          correlationID = (std::string *)0;
          errorCode = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PayPalAuthReversalReply() { }
        /// Friend allocator used by soap_new_ns2__PayPalAuthReversalReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalAuthReversalReply * SOAP_FMAC2 soap_instantiate_ns2__PayPalAuthReversalReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:681 */
#ifndef SOAP_TYPE_ns2__PayPalRefundReply
#define SOAP_TYPE_ns2__PayPalRefundReply (286)
/* complex XSD type 'ns2:PayPalRefundReply': */
class SOAP_CMAC ns2__PayPalRefundReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:transactionId' of XSD type 'xsd:string'
        std::string *transactionId;
        /// Optional element 'ns2:paypalNetRefundAmount' of XSD type 'xsd:string'
        std::string *paypalNetRefundAmount;
        /// Optional element 'ns2:paypalFeeRefundAmount' of XSD type 'xsd:string'
        std::string *paypalFeeRefundAmount;
        /// Optional element 'ns2:paypalGrossRefundAmount' of XSD type 'xsd:string'
        std::string *paypalGrossRefundAmount;
        /// Optional element 'ns2:correlationID' of XSD type 'xsd:string'
        std::string *correlationID;
        /// Optional element 'ns2:errorCode' of XSD type 'xsd:string'
        std::string *errorCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalRefundReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PayPalRefundReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalRefundReply, default initialized and not managed by a soap context
        virtual ns2__PayPalRefundReply *soap_alloc(void) const { return SOAP_NEW(ns2__PayPalRefundReply); }
      public:
        /// Constructor with initializations
        ns2__PayPalRefundReply()
        {
          transactionId = (std::string *)0;
          paypalNetRefundAmount = (std::string *)0;
          paypalFeeRefundAmount = (std::string *)0;
          paypalGrossRefundAmount = (std::string *)0;
          correlationID = (std::string *)0;
          errorCode = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PayPalRefundReply() { }
        /// Friend allocator used by soap_new_ns2__PayPalRefundReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalRefundReply * SOAP_FMAC2 soap_instantiate_ns2__PayPalRefundReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:684 */
#ifndef SOAP_TYPE_ns2__PayPalEcOrderSetupReply
#define SOAP_TYPE_ns2__PayPalEcOrderSetupReply (287)
/* complex XSD type 'ns2:PayPalEcOrderSetupReply': */
class SOAP_CMAC ns2__PayPalEcOrderSetupReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:paypalToken' of XSD type 'xsd:string'
        std::string *paypalToken;
        /// Optional element 'ns2:transactionId' of XSD type 'xsd:string'
        std::string *transactionId;
        /// Optional element 'ns2:paypalTransactiontype' of XSD type 'xsd:string'
        std::string *paypalTransactiontype;
        /// Optional element 'ns2:paymentType' of XSD type 'xsd:string'
        std::string *paymentType;
        /// Optional element 'ns2:paypalOrderTime' of XSD type 'xsd:string'
        std::string *paypalOrderTime;
        /// Optional element 'ns2:paypalAmount' of XSD type 'xsd:string'
        std::string *paypalAmount;
        /// Optional element 'ns2:paypalFeeAmount' of XSD type 'xsd:string'
        std::string *paypalFeeAmount;
        /// Optional element 'ns2:paypalTaxAmount' of XSD type 'xsd:string'
        std::string *paypalTaxAmount;
        /// Optional element 'ns2:paypalExchangeRate' of XSD type 'xsd:string'
        std::string *paypalExchangeRate;
        /// Optional element 'ns2:paypalPaymentStatus' of XSD type 'xsd:string'
        std::string *paypalPaymentStatus;
        /// Optional element 'ns2:paypalPendingReason' of XSD type 'xsd:string'
        std::string *paypalPendingReason;
        /// Optional element 'ns2:paypalReasonCode' of XSD type 'xsd:string'
        std::string *paypalReasonCode;
        /// Optional element 'ns2:amount' of XSD type 'xsd:string'
        std::string *amount;
        /// Optional element 'ns2:currency' of XSD type 'xsd:string'
        std::string *currency;
        /// Optional element 'ns2:correlationID' of XSD type 'xsd:string'
        std::string *correlationID;
        /// Optional element 'ns2:errorCode' of XSD type 'xsd:string'
        std::string *errorCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalEcOrderSetupReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PayPalEcOrderSetupReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalEcOrderSetupReply, default initialized and not managed by a soap context
        virtual ns2__PayPalEcOrderSetupReply *soap_alloc(void) const { return SOAP_NEW(ns2__PayPalEcOrderSetupReply); }
      public:
        /// Constructor with initializations
        ns2__PayPalEcOrderSetupReply()
        {
          paypalToken = (std::string *)0;
          transactionId = (std::string *)0;
          paypalTransactiontype = (std::string *)0;
          paymentType = (std::string *)0;
          paypalOrderTime = (std::string *)0;
          paypalAmount = (std::string *)0;
          paypalFeeAmount = (std::string *)0;
          paypalTaxAmount = (std::string *)0;
          paypalExchangeRate = (std::string *)0;
          paypalPaymentStatus = (std::string *)0;
          paypalPendingReason = (std::string *)0;
          paypalReasonCode = (std::string *)0;
          amount = (std::string *)0;
          currency = (std::string *)0;
          correlationID = (std::string *)0;
          errorCode = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PayPalEcOrderSetupReply() { }
        /// Friend allocator used by soap_new_ns2__PayPalEcOrderSetupReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalEcOrderSetupReply * SOAP_FMAC2 soap_instantiate_ns2__PayPalEcOrderSetupReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:687 */
#ifndef SOAP_TYPE_ns2__PayPalAuthorizationReply
#define SOAP_TYPE_ns2__PayPalAuthorizationReply (288)
/* complex XSD type 'ns2:PayPalAuthorizationReply': */
class SOAP_CMAC ns2__PayPalAuthorizationReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:transactionId' of XSD type 'xsd:string'
        std::string *transactionId;
        /// Optional element 'ns2:paypalAmount' of XSD type 'xsd:string'
        std::string *paypalAmount;
        /// Optional element 'ns2:amount' of XSD type 'xsd:string'
        std::string *amount;
        /// Optional element 'ns2:currency' of XSD type 'xsd:string'
        std::string *currency;
        /// Optional element 'ns2:correlationID' of XSD type 'xsd:string'
        std::string *correlationID;
        /// Optional element 'ns2:errorCode' of XSD type 'xsd:string'
        std::string *errorCode;
        /// Optional element 'ns2:protectionEligibility' of XSD type 'xsd:string'
        std::string *protectionEligibility;
        /// Optional element 'ns2:protectionEligibilityType' of XSD type 'xsd:string'
        std::string *protectionEligibilityType;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalAuthorizationReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PayPalAuthorizationReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalAuthorizationReply, default initialized and not managed by a soap context
        virtual ns2__PayPalAuthorizationReply *soap_alloc(void) const { return SOAP_NEW(ns2__PayPalAuthorizationReply); }
      public:
        /// Constructor with initializations
        ns2__PayPalAuthorizationReply()
        {
          transactionId = (std::string *)0;
          paypalAmount = (std::string *)0;
          amount = (std::string *)0;
          currency = (std::string *)0;
          correlationID = (std::string *)0;
          errorCode = (std::string *)0;
          protectionEligibility = (std::string *)0;
          protectionEligibilityType = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PayPalAuthorizationReply() { }
        /// Friend allocator used by soap_new_ns2__PayPalAuthorizationReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalAuthorizationReply * SOAP_FMAC2 soap_instantiate_ns2__PayPalAuthorizationReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:690 */
#ifndef SOAP_TYPE_ns2__PayPalUpdateAgreementReply
#define SOAP_TYPE_ns2__PayPalUpdateAgreementReply (289)
/* complex XSD type 'ns2:PayPalUpdateAgreementReply': */
class SOAP_CMAC ns2__PayPalUpdateAgreementReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:paypalBillingAgreementId' of XSD type 'xsd:string'
        std::string *paypalBillingAgreementId;
        /// Optional element 'ns2:paypalBillingAgreementDesc' of XSD type 'xsd:string'
        std::string *paypalBillingAgreementDesc;
        /// Optional element 'ns2:paypalBillingAgreementCustom' of XSD type 'xsd:string'
        std::string *paypalBillingAgreementCustom;
        /// Optional element 'ns2:paypalBillingAgreementStatus' of XSD type 'xsd:string'
        std::string *paypalBillingAgreementStatus;
        /// Optional element 'ns2:payer' of XSD type 'xsd:string'
        std::string *payer;
        /// Optional element 'ns2:payerId' of XSD type 'xsd:string'
        std::string *payerId;
        /// Optional element 'ns2:payerStatus' of XSD type 'xsd:string'
        std::string *payerStatus;
        /// Optional element 'ns2:payerCountry' of XSD type 'xsd:string'
        std::string *payerCountry;
        /// Optional element 'ns2:payerBusiness' of XSD type 'xsd:string'
        std::string *payerBusiness;
        /// Optional element 'ns2:payerSalutation' of XSD type 'xsd:string'
        std::string *payerSalutation;
        /// Optional element 'ns2:payerFirstname' of XSD type 'xsd:string'
        std::string *payerFirstname;
        /// Optional element 'ns2:payerMiddlename' of XSD type 'xsd:string'
        std::string *payerMiddlename;
        /// Optional element 'ns2:payerLastname' of XSD type 'xsd:string'
        std::string *payerLastname;
        /// Optional element 'ns2:payerSuffix' of XSD type 'xsd:string'
        std::string *payerSuffix;
        /// Optional element 'ns2:addressStatus' of XSD type 'xsd:string'
        std::string *addressStatus;
        /// Optional element 'ns2:errorCode' of XSD type 'xsd:string'
        std::string *errorCode;
        /// Optional element 'ns2:correlationID' of XSD type 'xsd:string'
        std::string *correlationID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalUpdateAgreementReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PayPalUpdateAgreementReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalUpdateAgreementReply, default initialized and not managed by a soap context
        virtual ns2__PayPalUpdateAgreementReply *soap_alloc(void) const { return SOAP_NEW(ns2__PayPalUpdateAgreementReply); }
      public:
        /// Constructor with initializations
        ns2__PayPalUpdateAgreementReply()
        {
          paypalBillingAgreementId = (std::string *)0;
          paypalBillingAgreementDesc = (std::string *)0;
          paypalBillingAgreementCustom = (std::string *)0;
          paypalBillingAgreementStatus = (std::string *)0;
          payer = (std::string *)0;
          payerId = (std::string *)0;
          payerStatus = (std::string *)0;
          payerCountry = (std::string *)0;
          payerBusiness = (std::string *)0;
          payerSalutation = (std::string *)0;
          payerFirstname = (std::string *)0;
          payerMiddlename = (std::string *)0;
          payerLastname = (std::string *)0;
          payerSuffix = (std::string *)0;
          addressStatus = (std::string *)0;
          errorCode = (std::string *)0;
          correlationID = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PayPalUpdateAgreementReply() { }
        /// Friend allocator used by soap_new_ns2__PayPalUpdateAgreementReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalUpdateAgreementReply * SOAP_FMAC2 soap_instantiate_ns2__PayPalUpdateAgreementReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:693 */
#ifndef SOAP_TYPE_ns2__PayPalCreateAgreementReply
#define SOAP_TYPE_ns2__PayPalCreateAgreementReply (290)
/* complex XSD type 'ns2:PayPalCreateAgreementReply': */
class SOAP_CMAC ns2__PayPalCreateAgreementReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:paypalBillingAgreementId' of XSD type 'xsd:string'
        std::string *paypalBillingAgreementId;
        /// Optional element 'ns2:errorCode' of XSD type 'xsd:string'
        std::string *errorCode;
        /// Optional element 'ns2:correlationID' of XSD type 'xsd:string'
        std::string *correlationID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalCreateAgreementReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PayPalCreateAgreementReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalCreateAgreementReply, default initialized and not managed by a soap context
        virtual ns2__PayPalCreateAgreementReply *soap_alloc(void) const { return SOAP_NEW(ns2__PayPalCreateAgreementReply); }
      public:
        /// Constructor with initializations
        ns2__PayPalCreateAgreementReply()
        {
          paypalBillingAgreementId = (std::string *)0;
          errorCode = (std::string *)0;
          correlationID = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PayPalCreateAgreementReply() { }
        /// Friend allocator used by soap_new_ns2__PayPalCreateAgreementReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalCreateAgreementReply * SOAP_FMAC2 soap_instantiate_ns2__PayPalCreateAgreementReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:696 */
#ifndef SOAP_TYPE_ns2__PayPalDoRefTransactionReply
#define SOAP_TYPE_ns2__PayPalDoRefTransactionReply (291)
/* complex XSD type 'ns2:PayPalDoRefTransactionReply': */
class SOAP_CMAC ns2__PayPalDoRefTransactionReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:paypalBillingAgreementId' of XSD type 'xsd:string'
        std::string *paypalBillingAgreementId;
        /// Optional element 'ns2:transactionId' of XSD type 'xsd:string'
        std::string *transactionId;
        /// Optional element 'ns2:paypalTransactionType' of XSD type 'xsd:string'
        std::string *paypalTransactionType;
        /// Optional element 'ns2:paypalPaymentType' of XSD type 'xsd:string'
        std::string *paypalPaymentType;
        /// Optional element 'ns2:paypalOrderTime' of XSD type 'xsd:string'
        std::string *paypalOrderTime;
        /// Optional element 'ns2:paypalAmount' of XSD type 'xsd:string'
        std::string *paypalAmount;
        /// Optional element 'ns2:currency' of XSD type 'xsd:string'
        std::string *currency;
        /// Optional element 'ns2:paypalTaxAmount' of XSD type 'xsd:string'
        std::string *paypalTaxAmount;
        /// Optional element 'ns2:paypalExchangeRate' of XSD type 'xsd:string'
        std::string *paypalExchangeRate;
        /// Optional element 'ns2:paypalPaymentStatus' of XSD type 'xsd:string'
        std::string *paypalPaymentStatus;
        /// Optional element 'ns2:paypalPendingReason' of XSD type 'xsd:string'
        std::string *paypalPendingReason;
        /// Optional element 'ns2:paypalReasonCode' of XSD type 'xsd:string'
        std::string *paypalReasonCode;
        /// Optional element 'ns2:errorCode' of XSD type 'xsd:string'
        std::string *errorCode;
        /// Optional element 'ns2:correlationID' of XSD type 'xsd:string'
        std::string *correlationID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalDoRefTransactionReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PayPalDoRefTransactionReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalDoRefTransactionReply, default initialized and not managed by a soap context
        virtual ns2__PayPalDoRefTransactionReply *soap_alloc(void) const { return SOAP_NEW(ns2__PayPalDoRefTransactionReply); }
      public:
        /// Constructor with initializations
        ns2__PayPalDoRefTransactionReply()
        {
          paypalBillingAgreementId = (std::string *)0;
          transactionId = (std::string *)0;
          paypalTransactionType = (std::string *)0;
          paypalPaymentType = (std::string *)0;
          paypalOrderTime = (std::string *)0;
          paypalAmount = (std::string *)0;
          currency = (std::string *)0;
          paypalTaxAmount = (std::string *)0;
          paypalExchangeRate = (std::string *)0;
          paypalPaymentStatus = (std::string *)0;
          paypalPendingReason = (std::string *)0;
          paypalReasonCode = (std::string *)0;
          errorCode = (std::string *)0;
          correlationID = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PayPalDoRefTransactionReply() { }
        /// Friend allocator used by soap_new_ns2__PayPalDoRefTransactionReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalDoRefTransactionReply * SOAP_FMAC2 soap_instantiate_ns2__PayPalDoRefTransactionReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:699 */
#ifndef SOAP_TYPE_ns2__RiskUpdateReply
#define SOAP_TYPE_ns2__RiskUpdateReply (292)
/* complex XSD type 'ns2:RiskUpdateReply': */
class SOAP_CMAC ns2__RiskUpdateReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__RiskUpdateReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__RiskUpdateReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__RiskUpdateReply, default initialized and not managed by a soap context
        virtual ns2__RiskUpdateReply *soap_alloc(void) const { return SOAP_NEW(ns2__RiskUpdateReply); }
      public:
        /// Constructor with initializations
        ns2__RiskUpdateReply()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__RiskUpdateReply() { }
        /// Friend allocator used by soap_new_ns2__RiskUpdateReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__RiskUpdateReply * SOAP_FMAC2 soap_instantiate_ns2__RiskUpdateReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:702 */
#ifndef SOAP_TYPE_ns2__FraudUpdateReply
#define SOAP_TYPE_ns2__FraudUpdateReply (293)
/* complex XSD type 'ns2:FraudUpdateReply': */
class SOAP_CMAC ns2__FraudUpdateReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__FraudUpdateReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__FraudUpdateReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__FraudUpdateReply, default initialized and not managed by a soap context
        virtual ns2__FraudUpdateReply *soap_alloc(void) const { return SOAP_NEW(ns2__FraudUpdateReply); }
      public:
        /// Constructor with initializations
        ns2__FraudUpdateReply()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__FraudUpdateReply() { }
        /// Friend allocator used by soap_new_ns2__FraudUpdateReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__FraudUpdateReply * SOAP_FMAC2 soap_instantiate_ns2__FraudUpdateReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:705 */
#ifndef SOAP_TYPE_ns2__CaseManagementActionReply
#define SOAP_TYPE_ns2__CaseManagementActionReply (294)
/* complex XSD type 'ns2:CaseManagementActionReply': */
class SOAP_CMAC ns2__CaseManagementActionReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__CaseManagementActionReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__CaseManagementActionReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__CaseManagementActionReply, default initialized and not managed by a soap context
        virtual ns2__CaseManagementActionReply *soap_alloc(void) const { return SOAP_NEW(ns2__CaseManagementActionReply); }
      public:
        /// Constructor with initializations
        ns2__CaseManagementActionReply()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__CaseManagementActionReply() { }
        /// Friend allocator used by soap_new_ns2__CaseManagementActionReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__CaseManagementActionReply * SOAP_FMAC2 soap_instantiate_ns2__CaseManagementActionReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:708 */
#ifndef SOAP_TYPE_ns2__RuleResultItem
#define SOAP_TYPE_ns2__RuleResultItem (295)
/* complex XSD type 'ns2:RuleResultItem': */
class SOAP_CMAC ns2__RuleResultItem {
      public:
        /// Optional element 'ns2:name' of XSD type 'xsd:string'
        std::string *name;
        /// Optional element 'ns2:decision' of XSD type 'xsd:string'
        std::string *decision;
        /// Optional element 'ns2:evaluation' of XSD type 'xsd:string'
        std::string *evaluation;
        /// Optional element 'ns2:ruleID' of XSD type 'xsd:integer'
        std::string *ruleID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__RuleResultItem
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__RuleResultItem; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__RuleResultItem, default initialized and not managed by a soap context
        virtual ns2__RuleResultItem *soap_alloc(void) const { return SOAP_NEW(ns2__RuleResultItem); }
      public:
        /// Constructor with initializations
        ns2__RuleResultItem()
        {
          name = (std::string *)0;
          decision = (std::string *)0;
          evaluation = (std::string *)0;
          ruleID = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__RuleResultItem() { }
        /// Friend allocator used by soap_new_ns2__RuleResultItem(struct soap*, int)
        friend SOAP_FMAC1 ns2__RuleResultItem * SOAP_FMAC2 soap_instantiate_ns2__RuleResultItem(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:711 */
#ifndef SOAP_TYPE_ns2__RuleResultItems
#define SOAP_TYPE_ns2__RuleResultItems (296)
/* complex XSD type 'ns2:RuleResultItems': */
class SOAP_CMAC ns2__RuleResultItems {
      public:
        /// Sequence of 0 to 1000 elements 'ns2:ruleResultItem' of XSD type 'ns2:RuleResultItem'
        std::vector<ns2__RuleResultItem *> ruleResultItem;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__RuleResultItems
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__RuleResultItems; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__RuleResultItems, default initialized and not managed by a soap context
        virtual ns2__RuleResultItems *soap_alloc(void) const { return SOAP_NEW(ns2__RuleResultItems); }
      public:
        /// Constructor with initializations
        ns2__RuleResultItems()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__RuleResultItems() { }
        /// Friend allocator used by soap_new_ns2__RuleResultItems(struct soap*, int)
        friend SOAP_FMAC1 ns2__RuleResultItems * SOAP_FMAC2 soap_instantiate_ns2__RuleResultItems(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:714 */
#ifndef SOAP_TYPE_ns2__DecisionReply
#define SOAP_TYPE_ns2__DecisionReply (297)
/* complex XSD type 'ns2:DecisionReply': */
class SOAP_CMAC ns2__DecisionReply {
      public:
        /// Optional element 'ns2:casePriority' of XSD type 'xsd:integer'
        std::string *casePriority;
        /// Optional element 'ns2:activeProfileReply' of XSD type 'ns2:ProfileReply'
        ns2__ProfileReply *activeProfileReply;
        /// Optional element 'ns2:velocityInfoCode' of XSD type 'xsd:string'
        std::string *velocityInfoCode;
        /// Optional element 'ns2:additionalFields' of XSD type 'ns2:AdditionalFields'
        ns2__AdditionalFields *additionalFields;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__DecisionReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__DecisionReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__DecisionReply, default initialized and not managed by a soap context
        virtual ns2__DecisionReply *soap_alloc(void) const { return SOAP_NEW(ns2__DecisionReply); }
      public:
        /// Constructor with initializations
        ns2__DecisionReply()
        {
          casePriority = (std::string *)0;
          activeProfileReply = (ns2__ProfileReply *)0;
          velocityInfoCode = (std::string *)0;
          additionalFields = (ns2__AdditionalFields *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__DecisionReply() { }
        /// Friend allocator used by soap_new_ns2__DecisionReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__DecisionReply * SOAP_FMAC2 soap_instantiate_ns2__DecisionReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:717 */
#ifndef SOAP_TYPE_ns2__AdditionalFields
#define SOAP_TYPE_ns2__AdditionalFields (298)
/* complex XSD type 'ns2:AdditionalFields': */
class SOAP_CMAC ns2__AdditionalFields {
      public:
        /// Sequence of 0 to 3000 elements 'ns2:field' of XSD type 'ns2:Field'
        std::vector<ns2__Field *> field;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__AdditionalFields
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__AdditionalFields; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__AdditionalFields, default initialized and not managed by a soap context
        virtual ns2__AdditionalFields *soap_alloc(void) const { return SOAP_NEW(ns2__AdditionalFields); }
      public:
        /// Constructor with initializations
        ns2__AdditionalFields()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__AdditionalFields() { }
        /// Friend allocator used by soap_new_ns2__AdditionalFields(struct soap*, int)
        friend SOAP_FMAC1 ns2__AdditionalFields * SOAP_FMAC2 soap_instantiate_ns2__AdditionalFields(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:720 */
#ifndef SOAP_TYPE_ns2__Field
#define SOAP_TYPE_ns2__Field (299)
/* complex XSD type 'ns2:Field': */
class SOAP_CMAC ns2__Field {
      public:
        /// Required element 'ns2:provider' of XSD type 'xsd:string'
        std::string provider;
        /// Required element 'ns2:name' of XSD type 'xsd:string'
        std::string name;
        /// Required element 'ns2:value' of XSD type 'xsd:string'
        std::string value;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Field
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__Field; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Field, default initialized and not managed by a soap context
        virtual ns2__Field *soap_alloc(void) const { return SOAP_NEW(ns2__Field); }
      public:
        /// Constructor with initializations
        ns2__Field()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__Field() { }
        /// Friend allocator used by soap_new_ns2__Field(struct soap*, int)
        friend SOAP_FMAC1 ns2__Field * SOAP_FMAC2 soap_instantiate_ns2__Field(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:723 */
#ifndef SOAP_TYPE_ns2__DMEReply
#define SOAP_TYPE_ns2__DMEReply (300)
/* complex XSD type 'ns2:DMEReply': */
class SOAP_CMAC ns2__DMEReply {
      public:
        /// Optional element 'ns2:eventType' of XSD type 'xsd:string'
        std::string *eventType;
        /// Optional element 'ns2:eventInfo' of XSD type 'xsd:string'
        std::string *eventInfo;
        /// Optional element 'ns2:eventHotlistInfo' of XSD type 'xsd:string'
        std::string *eventHotlistInfo;
        /// Optional element 'ns2:eventPolicy' of XSD type 'xsd:string'
        std::string *eventPolicy;
        /// Optional element 'ns2:additionalFields' of XSD type 'ns2:AdditionalFields'
        ns2__AdditionalFields *additionalFields;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__DMEReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__DMEReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__DMEReply, default initialized and not managed by a soap context
        virtual ns2__DMEReply *soap_alloc(void) const { return SOAP_NEW(ns2__DMEReply); }
      public:
        /// Constructor with initializations
        ns2__DMEReply()
        {
          eventType = (std::string *)0;
          eventInfo = (std::string *)0;
          eventHotlistInfo = (std::string *)0;
          eventPolicy = (std::string *)0;
          additionalFields = (ns2__AdditionalFields *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__DMEReply() { }
        /// Friend allocator used by soap_new_ns2__DMEReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__DMEReply * SOAP_FMAC2 soap_instantiate_ns2__DMEReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:726 */
#ifndef SOAP_TYPE_ns2__ProfileReply
#define SOAP_TYPE_ns2__ProfileReply (301)
/* complex XSD type 'ns2:ProfileReply': */
class SOAP_CMAC ns2__ProfileReply {
      public:
        /// Optional element 'ns2:selectedBy' of XSD type 'xsd:string'
        std::string *selectedBy;
        /// Optional element 'ns2:name' of XSD type 'xsd:string'
        std::string *name;
        /// Optional element 'ns2:destinationQueue' of XSD type 'xsd:string'
        std::string *destinationQueue;
        /// Optional element 'ns2:profileScore' of XSD type 'xsd:string'
        std::string *profileScore;
        /// Optional element 'ns2:rulesTriggered' of XSD type 'ns2:RuleResultItems'
        ns2__RuleResultItems *rulesTriggered;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ProfileReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ProfileReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ProfileReply, default initialized and not managed by a soap context
        virtual ns2__ProfileReply *soap_alloc(void) const { return SOAP_NEW(ns2__ProfileReply); }
      public:
        /// Constructor with initializations
        ns2__ProfileReply()
        {
          selectedBy = (std::string *)0;
          name = (std::string *)0;
          destinationQueue = (std::string *)0;
          profileScore = (std::string *)0;
          rulesTriggered = (ns2__RuleResultItems *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__ProfileReply() { }
        /// Friend allocator used by soap_new_ns2__ProfileReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__ProfileReply * SOAP_FMAC2 soap_instantiate_ns2__ProfileReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:729 */
#ifndef SOAP_TYPE_ns2__CCDCCReply
#define SOAP_TYPE_ns2__CCDCCReply (302)
/* complex XSD type 'ns2:CCDCCReply': */
class SOAP_CMAC ns2__CCDCCReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:dccSupported' of XSD type 'ns2:boolean'
        std::string *dccSupported;
        /// Optional element 'ns2:validHours' of XSD type 'xsd:string'
        std::string *validHours;
        /// Optional element 'ns2:marginRatePercentage' of XSD type 'xsd:string'
        std::string *marginRatePercentage;
        /// Optional element 'ns2:reconciliationID' of XSD type 'xsd:string'
        std::string *reconciliationID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__CCDCCReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__CCDCCReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__CCDCCReply, default initialized and not managed by a soap context
        virtual ns2__CCDCCReply *soap_alloc(void) const { return SOAP_NEW(ns2__CCDCCReply); }
      public:
        /// Constructor with initializations
        ns2__CCDCCReply()
        {
          dccSupported = (std::string *)0;
          validHours = (std::string *)0;
          marginRatePercentage = (std::string *)0;
          reconciliationID = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__CCDCCReply() { }
        /// Friend allocator used by soap_new_ns2__CCDCCReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__CCDCCReply * SOAP_FMAC2 soap_instantiate_ns2__CCDCCReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:732 */
#ifndef SOAP_TYPE_ns2__CCDCCUpdateReply
#define SOAP_TYPE_ns2__CCDCCUpdateReply (303)
/* complex XSD type 'ns2:CCDCCUpdateReply': */
class SOAP_CMAC ns2__CCDCCUpdateReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__CCDCCUpdateReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__CCDCCUpdateReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__CCDCCUpdateReply, default initialized and not managed by a soap context
        virtual ns2__CCDCCUpdateReply *soap_alloc(void) const { return SOAP_NEW(ns2__CCDCCUpdateReply); }
      public:
        /// Constructor with initializations
        ns2__CCDCCUpdateReply()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__CCDCCUpdateReply() { }
        /// Friend allocator used by soap_new_ns2__CCDCCUpdateReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__CCDCCUpdateReply * SOAP_FMAC2 soap_instantiate_ns2__CCDCCUpdateReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:735 */
#ifndef SOAP_TYPE_ns2__ChinaPaymentReply
#define SOAP_TYPE_ns2__ChinaPaymentReply (304)
/* complex XSD type 'ns2:ChinaPaymentReply': */
class SOAP_CMAC ns2__ChinaPaymentReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:requestDateTime' of XSD type 'ns2:dateTime'
        std::string *requestDateTime;
        /// Optional element 'ns2:amount' of XSD type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:currency' of XSD type 'xsd:string'
        std::string *currency;
        /// Optional element 'ns2:reconciliationID' of XSD type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:formData' of XSD type 'xsd:string'
        std::string *formData;
        /// Optional element 'ns2:verifyFailure' of XSD type 'xsd:string'
        std::string *verifyFailure;
        /// Optional element 'ns2:verifyInProcess' of XSD type 'xsd:string'
        std::string *verifyInProcess;
        /// Optional element 'ns2:verifySuccess' of XSD type 'xsd:string'
        std::string *verifySuccess;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ChinaPaymentReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ChinaPaymentReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ChinaPaymentReply, default initialized and not managed by a soap context
        virtual ns2__ChinaPaymentReply *soap_alloc(void) const { return SOAP_NEW(ns2__ChinaPaymentReply); }
      public:
        /// Constructor with initializations
        ns2__ChinaPaymentReply()
        {
          requestDateTime = (std::string *)0;
          amount = (std::string *)0;
          currency = (std::string *)0;
          reconciliationID = (std::string *)0;
          formData = (std::string *)0;
          verifyFailure = (std::string *)0;
          verifyInProcess = (std::string *)0;
          verifySuccess = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__ChinaPaymentReply() { }
        /// Friend allocator used by soap_new_ns2__ChinaPaymentReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__ChinaPaymentReply * SOAP_FMAC2 soap_instantiate_ns2__ChinaPaymentReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:738 */
#ifndef SOAP_TYPE_ns2__ChinaRefundReply
#define SOAP_TYPE_ns2__ChinaRefundReply (305)
/* complex XSD type 'ns2:ChinaRefundReply': */
class SOAP_CMAC ns2__ChinaRefundReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:requestDateTime' of XSD type 'ns2:dateTime'
        std::string *requestDateTime;
        /// Optional element 'ns2:amount' of XSD type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:currency' of XSD type 'xsd:string'
        std::string *currency;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ChinaRefundReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ChinaRefundReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ChinaRefundReply, default initialized and not managed by a soap context
        virtual ns2__ChinaRefundReply *soap_alloc(void) const { return SOAP_NEW(ns2__ChinaRefundReply); }
      public:
        /// Constructor with initializations
        ns2__ChinaRefundReply()
        {
          requestDateTime = (std::string *)0;
          amount = (std::string *)0;
          currency = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__ChinaRefundReply() { }
        /// Friend allocator used by soap_new_ns2__ChinaRefundReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__ChinaRefundReply * SOAP_FMAC2 soap_instantiate_ns2__ChinaRefundReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:741 */
#ifndef SOAP_TYPE_ns2__BoletoPaymentReply
#define SOAP_TYPE_ns2__BoletoPaymentReply (306)
/* complex XSD type 'ns2:BoletoPaymentReply': */
class SOAP_CMAC ns2__BoletoPaymentReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:requestDateTime' of XSD type 'ns2:dateTime'
        std::string *requestDateTime;
        /// Optional element 'ns2:amount' of XSD type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:reconciliationID' of XSD type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:boletoNumber' of XSD type 'xsd:string'
        std::string *boletoNumber;
        /// Optional element 'ns2:expirationDate' of XSD type 'xsd:string'
        std::string *expirationDate;
        /// Optional element 'ns2:url' of XSD type 'xsd:string'
        std::string *url;
        /// Optional element 'ns2:avsCode' of XSD type 'xsd:string'
        std::string *avsCode;
        /// Optional element 'ns2:avsCodeRaw' of XSD type 'xsd:string'
        std::string *avsCodeRaw;
        /// Optional element 'ns2:barCodeNumber' of XSD type 'xsd:string'
        std::string *barCodeNumber;
        /// Optional element 'ns2:assignor' of XSD type 'xsd:string'
        std::string *assignor;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__BoletoPaymentReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__BoletoPaymentReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__BoletoPaymentReply, default initialized and not managed by a soap context
        virtual ns2__BoletoPaymentReply *soap_alloc(void) const { return SOAP_NEW(ns2__BoletoPaymentReply); }
      public:
        /// Constructor with initializations
        ns2__BoletoPaymentReply()
        {
          requestDateTime = (std::string *)0;
          amount = (std::string *)0;
          reconciliationID = (std::string *)0;
          boletoNumber = (std::string *)0;
          expirationDate = (std::string *)0;
          url = (std::string *)0;
          avsCode = (std::string *)0;
          avsCodeRaw = (std::string *)0;
          barCodeNumber = (std::string *)0;
          assignor = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__BoletoPaymentReply() { }
        /// Friend allocator used by soap_new_ns2__BoletoPaymentReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__BoletoPaymentReply * SOAP_FMAC2 soap_instantiate_ns2__BoletoPaymentReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:744 */
#ifndef SOAP_TYPE_ns2__APInitiateReply
#define SOAP_TYPE_ns2__APInitiateReply (307)
/* complex XSD type 'ns2:APInitiateReply': */
class SOAP_CMAC ns2__APInitiateReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:merchantURL' of XSD type 'xsd:string'
        std::string *merchantURL;
        /// Optional element 'ns2:reconciliationID' of XSD type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:amount' of XSD type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:dateTime' of XSD type 'ns2:dateTime'
        std::string *dateTime;
        /// Optional element 'ns2:signature' of XSD type 'xsd:string'
        std::string *signature;
        /// Optional element 'ns2:publicKey' of XSD type 'xsd:string'
        std::string *publicKey;
        /// Optional element 'ns2:paymentStatus' of XSD type 'xsd:string'
        std::string *paymentStatus;
        /// Optional element 'ns2:responseCode' of XSD type 'xsd:string'
        std::string *responseCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__APInitiateReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__APInitiateReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__APInitiateReply, default initialized and not managed by a soap context
        virtual ns2__APInitiateReply *soap_alloc(void) const { return SOAP_NEW(ns2__APInitiateReply); }
      public:
        /// Constructor with initializations
        ns2__APInitiateReply()
        {
          merchantURL = (std::string *)0;
          reconciliationID = (std::string *)0;
          amount = (std::string *)0;
          dateTime = (std::string *)0;
          signature = (std::string *)0;
          publicKey = (std::string *)0;
          paymentStatus = (std::string *)0;
          responseCode = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__APInitiateReply() { }
        /// Friend allocator used by soap_new_ns2__APInitiateReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__APInitiateReply * SOAP_FMAC2 soap_instantiate_ns2__APInitiateReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:747 */
#ifndef SOAP_TYPE_ns2__APCheckStatusReply
#define SOAP_TYPE_ns2__APCheckStatusReply (308)
/* complex XSD type 'ns2:APCheckStatusReply': */
class SOAP_CMAC ns2__APCheckStatusReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Required element 'ns2:reconciliationID' of XSD type 'xsd:string'
        std::string reconciliationID;
        /// Optional element 'ns2:paymentStatus' of XSD type 'xsd:string'
        std::string *paymentStatus;
        /// Optional element 'ns2:processorTradeNo' of XSD type 'xsd:string'
        std::string *processorTradeNo;
        /// Optional element 'ns2:processorTransactionID' of XSD type 'xsd:string'
        std::string *processorTransactionID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__APCheckStatusReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__APCheckStatusReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__APCheckStatusReply, default initialized and not managed by a soap context
        virtual ns2__APCheckStatusReply *soap_alloc(void) const { return SOAP_NEW(ns2__APCheckStatusReply); }
      public:
        /// Constructor with initializations
        ns2__APCheckStatusReply()
        {
          paymentStatus = (std::string *)0;
          processorTradeNo = (std::string *)0;
          processorTransactionID = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__APCheckStatusReply() { }
        /// Friend allocator used by soap_new_ns2__APCheckStatusReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__APCheckStatusReply * SOAP_FMAC2 soap_instantiate_ns2__APCheckStatusReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:750 */
#ifndef SOAP_TYPE_ns2__APReply
#define SOAP_TYPE_ns2__APReply (309)
/* complex XSD type 'ns2:APReply': */
class SOAP_CMAC ns2__APReply {
      public:
        /// Optional element 'ns2:orderID' of XSD type 'xsd:string'
        std::string *orderID;
        /// Optional element 'ns2:cardGroup' of XSD type 'xsd:string'
        std::string *cardGroup;
        /// Optional element 'ns2:cardType' of XSD type 'xsd:string'
        std::string *cardType;
        /// Optional element 'ns2:cardNumberSuffix' of XSD type 'xsd:string'
        std::string *cardNumberSuffix;
        /// Optional element 'ns2:cardExpirationMonth' of XSD type 'xsd:string'
        std::string *cardExpirationMonth;
        /// Optional element 'ns2:cardExpirationYear' of XSD type 'xsd:string'
        std::string *cardExpirationYear;
        /// Optional element 'ns2:avsCodeRaw' of XSD type 'xsd:string'
        std::string *avsCodeRaw;
        /// Optional element 'ns2:purchaseID' of XSD type 'xsd:string'
        std::string *purchaseID;
        /// Optional element 'ns2:productID' of XSD type 'xsd:string'
        std::string *productID;
        /// Optional element 'ns2:productDescription' of XSD type 'xsd:string'
        std::string *productDescription;
        /// Optional element 'ns2:shippingAmount' of XSD type 'xsd:string'
        std::string *shippingAmount;
        /// Optional element 'ns2:handlingAmount' of XSD type 'xsd:string'
        std::string *handlingAmount;
        /// Optional element 'ns2:shippingHandlingAmount' of XSD type 'xsd:string'
        std::string *shippingHandlingAmount;
        /// Optional element 'ns2:additionalAmount' of XSD type 'xsd:string'
        std::string *additionalAmount;
        /// Optional element 'ns2:taxAmount' of XSD type 'xsd:string'
        std::string *taxAmount;
        /// Optional element 'ns2:subtotalAmount' of XSD type 'xsd:string'
        std::string *subtotalAmount;
        /// Optional element 'ns2:totalPurchaseAmount' of XSD type 'xsd:string'
        std::string *totalPurchaseAmount;
        /// Optional element 'ns2:giftWrapAmount' of XSD type 'xsd:string'
        std::string *giftWrapAmount;
        /// Optional element 'ns2:discountAmount' of XSD type 'xsd:string'
        std::string *discountAmount;
        /// Optional element 'ns2:cardNumberPrefix' of XSD type 'xsd:string'
        std::string *cardNumberPrefix;
        /// Optional element 'ns2:riskIndicator' of XSD type 'xsd:string'
        std::string *riskIndicator;
        /// Optional element 'ns2:merchantUUID' of XSD type 'xsd:string'
        std::string *merchantUUID;
        /// Optional element 'ns2:merchantSiteID' of XSD type 'xsd:string'
        std::string *merchantSiteID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__APReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__APReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__APReply, default initialized and not managed by a soap context
        virtual ns2__APReply *soap_alloc(void) const { return SOAP_NEW(ns2__APReply); }
      public:
        /// Constructor with initializations
        ns2__APReply()
        {
          orderID = (std::string *)0;
          cardGroup = (std::string *)0;
          cardType = (std::string *)0;
          cardNumberSuffix = (std::string *)0;
          cardExpirationMonth = (std::string *)0;
          cardExpirationYear = (std::string *)0;
          avsCodeRaw = (std::string *)0;
          purchaseID = (std::string *)0;
          productID = (std::string *)0;
          productDescription = (std::string *)0;
          shippingAmount = (std::string *)0;
          handlingAmount = (std::string *)0;
          shippingHandlingAmount = (std::string *)0;
          additionalAmount = (std::string *)0;
          taxAmount = (std::string *)0;
          subtotalAmount = (std::string *)0;
          totalPurchaseAmount = (std::string *)0;
          giftWrapAmount = (std::string *)0;
          discountAmount = (std::string *)0;
          cardNumberPrefix = (std::string *)0;
          riskIndicator = (std::string *)0;
          merchantUUID = (std::string *)0;
          merchantSiteID = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__APReply() { }
        /// Friend allocator used by soap_new_ns2__APReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__APReply * SOAP_FMAC2 soap_instantiate_ns2__APReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:753 */
#ifndef SOAP_TYPE_ns2__APAuthReply
#define SOAP_TYPE_ns2__APAuthReply (310)
/* complex XSD type 'ns2:APAuthReply': */
class SOAP_CMAC ns2__APAuthReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:transactionID' of XSD type 'xsd:string'
        std::string *transactionID;
        /// Optional element 'ns2:status' of XSD type 'xsd:string'
        std::string *status;
        /// Optional element 'ns2:processorResponse' of XSD type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:amount' of XSD type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:dateTime' of XSD type 'ns2:dateTime'
        std::string *dateTime;
        /// Optional element 'ns2:providerResponse' of XSD type 'xsd:string'
        std::string *providerResponse;
        /// Optional element 'ns2:paymentStatus' of XSD type 'xsd:string'
        std::string *paymentStatus;
        /// Optional element 'ns2:responseCode' of XSD type 'xsd:string'
        std::string *responseCode;
        /// Optional element 'ns2:authorizationCode' of XSD type 'xsd:string'
        std::string *authorizationCode;
        /// Optional element 'ns2:merchantURL' of XSD type 'xsd:string'
        std::string *merchantURL;
        /// Optional element 'ns2:reconciliationID' of XSD type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:processorTransactionID' of XSD type 'xsd:string'
        std::string *processorTransactionID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__APAuthReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__APAuthReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__APAuthReply, default initialized and not managed by a soap context
        virtual ns2__APAuthReply *soap_alloc(void) const { return SOAP_NEW(ns2__APAuthReply); }
      public:
        /// Constructor with initializations
        ns2__APAuthReply()
        {
          transactionID = (std::string *)0;
          status = (std::string *)0;
          processorResponse = (std::string *)0;
          amount = (std::string *)0;
          dateTime = (std::string *)0;
          providerResponse = (std::string *)0;
          paymentStatus = (std::string *)0;
          responseCode = (std::string *)0;
          authorizationCode = (std::string *)0;
          merchantURL = (std::string *)0;
          reconciliationID = (std::string *)0;
          processorTransactionID = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__APAuthReply() { }
        /// Friend allocator used by soap_new_ns2__APAuthReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__APAuthReply * SOAP_FMAC2 soap_instantiate_ns2__APAuthReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:756 */
#ifndef SOAP_TYPE_ns2__APAuthReversalReply
#define SOAP_TYPE_ns2__APAuthReversalReply (311)
/* complex XSD type 'ns2:APAuthReversalReply': */
class SOAP_CMAC ns2__APAuthReversalReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:transactionID' of XSD type 'xsd:string'
        std::string *transactionID;
        /// Optional element 'ns2:status' of XSD type 'xsd:string'
        std::string *status;
        /// Optional element 'ns2:processorResponse' of XSD type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:amount' of XSD type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:dateTime' of XSD type 'ns2:dateTime'
        std::string *dateTime;
        /// Optional element 'ns2:providerResponse' of XSD type 'xsd:string'
        std::string *providerResponse;
        /// Optional element 'ns2:paymentStatus' of XSD type 'xsd:string'
        std::string *paymentStatus;
        /// Optional element 'ns2:responseCode' of XSD type 'xsd:string'
        std::string *responseCode;
        /// Optional element 'ns2:reconciliationID' of XSD type 'xsd:string'
        std::string *reconciliationID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__APAuthReversalReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__APAuthReversalReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__APAuthReversalReply, default initialized and not managed by a soap context
        virtual ns2__APAuthReversalReply *soap_alloc(void) const { return SOAP_NEW(ns2__APAuthReversalReply); }
      public:
        /// Constructor with initializations
        ns2__APAuthReversalReply()
        {
          transactionID = (std::string *)0;
          status = (std::string *)0;
          processorResponse = (std::string *)0;
          amount = (std::string *)0;
          dateTime = (std::string *)0;
          providerResponse = (std::string *)0;
          paymentStatus = (std::string *)0;
          responseCode = (std::string *)0;
          reconciliationID = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__APAuthReversalReply() { }
        /// Friend allocator used by soap_new_ns2__APAuthReversalReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__APAuthReversalReply * SOAP_FMAC2 soap_instantiate_ns2__APAuthReversalReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:759 */
#ifndef SOAP_TYPE_ns2__APCaptureReply
#define SOAP_TYPE_ns2__APCaptureReply (312)
/* complex XSD type 'ns2:APCaptureReply': */
class SOAP_CMAC ns2__APCaptureReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:transactionID' of XSD type 'xsd:string'
        std::string *transactionID;
        /// Optional element 'ns2:status' of XSD type 'xsd:string'
        std::string *status;
        /// Optional element 'ns2:processorResponse' of XSD type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:amount' of XSD type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:dateTime' of XSD type 'ns2:dateTime'
        std::string *dateTime;
        /// Optional element 'ns2:reconciliationID' of XSD type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:providerResponse' of XSD type 'xsd:string'
        std::string *providerResponse;
        /// Optional element 'ns2:paymentStatus' of XSD type 'xsd:string'
        std::string *paymentStatus;
        /// Optional element 'ns2:responseCode' of XSD type 'xsd:string'
        std::string *responseCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__APCaptureReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__APCaptureReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__APCaptureReply, default initialized and not managed by a soap context
        virtual ns2__APCaptureReply *soap_alloc(void) const { return SOAP_NEW(ns2__APCaptureReply); }
      public:
        /// Constructor with initializations
        ns2__APCaptureReply()
        {
          transactionID = (std::string *)0;
          status = (std::string *)0;
          processorResponse = (std::string *)0;
          amount = (std::string *)0;
          dateTime = (std::string *)0;
          reconciliationID = (std::string *)0;
          providerResponse = (std::string *)0;
          paymentStatus = (std::string *)0;
          responseCode = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__APCaptureReply() { }
        /// Friend allocator used by soap_new_ns2__APCaptureReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__APCaptureReply * SOAP_FMAC2 soap_instantiate_ns2__APCaptureReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:762 */
#ifndef SOAP_TYPE_ns2__APOptionsReply
#define SOAP_TYPE_ns2__APOptionsReply (313)
/* complex XSD type 'ns2:APOptionsReply': */
class SOAP_CMAC ns2__APOptionsReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:responseCode' of XSD type 'xsd:string'
        std::string *responseCode;
        /// Optional element 'ns2:offset' of XSD type 'xsd:string'
        std::string *offset;
        /// Optional element 'ns2:count' of XSD type 'xsd:string'
        std::string *count;
        /// Optional element 'ns2:totalCount' of XSD type 'xsd:string'
        std::string *totalCount;
        /// Optional element 'ns2:option' of XSD type 'ns2:APOptionsOption'
        ns2__APOptionsOption *option;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__APOptionsReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__APOptionsReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__APOptionsReply, default initialized and not managed by a soap context
        virtual ns2__APOptionsReply *soap_alloc(void) const { return SOAP_NEW(ns2__APOptionsReply); }
      public:
        /// Constructor with initializations
        ns2__APOptionsReply()
        {
          responseCode = (std::string *)0;
          offset = (std::string *)0;
          count = (std::string *)0;
          totalCount = (std::string *)0;
          option = (ns2__APOptionsOption *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__APOptionsReply() { }
        /// Friend allocator used by soap_new_ns2__APOptionsReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__APOptionsReply * SOAP_FMAC2 soap_instantiate_ns2__APOptionsReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:765 */
#ifndef SOAP_TYPE_ns2__APOptionsOption
#define SOAP_TYPE_ns2__APOptionsOption (314)
/* complex XSD type 'ns2:APOptionsOption': */
class SOAP_CMAC ns2__APOptionsOption {
      public:
        /// Optional element 'ns2:id' of XSD type 'xsd:string'
        std::string *id;
        /// Optional element 'ns2:name' of XSD type 'xsd:string'
        std::string *name;
        /// optional attribute 'data' of XSD type 'xsd:integer'
        std::string *data;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__APOptionsOption
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__APOptionsOption; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__APOptionsOption, default initialized and not managed by a soap context
        virtual ns2__APOptionsOption *soap_alloc(void) const { return SOAP_NEW(ns2__APOptionsOption); }
      public:
        /// Constructor with initializations
        ns2__APOptionsOption()
        {
          id = (std::string *)0;
          name = (std::string *)0;
          data = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__APOptionsOption() { }
        /// Friend allocator used by soap_new_ns2__APOptionsOption(struct soap*, int)
        friend SOAP_FMAC1 ns2__APOptionsOption * SOAP_FMAC2 soap_instantiate_ns2__APOptionsOption(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:768 */
#ifndef SOAP_TYPE_ns2__APRefundReply
#define SOAP_TYPE_ns2__APRefundReply (315)
/* complex XSD type 'ns2:APRefundReply': */
class SOAP_CMAC ns2__APRefundReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:transactionID' of XSD type 'xsd:string'
        std::string *transactionID;
        /// Optional element 'ns2:status' of XSD type 'xsd:string'
        std::string *status;
        /// Optional element 'ns2:processorResponse' of XSD type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:amount' of XSD type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:dateTime' of XSD type 'ns2:dateTime'
        std::string *dateTime;
        /// Optional element 'ns2:reconciliationID' of XSD type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:returnRef' of XSD type 'xsd:string'
        std::string *returnRef;
        /// Optional element 'ns2:providerResponse' of XSD type 'xsd:string'
        std::string *providerResponse;
        /// Optional element 'ns2:processorTransactionID' of XSD type 'xsd:string'
        std::string *processorTransactionID;
        /// Optional element 'ns2:paymentStatus' of XSD type 'xsd:string'
        std::string *paymentStatus;
        /// Optional element 'ns2:responseCode' of XSD type 'xsd:string'
        std::string *responseCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__APRefundReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__APRefundReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__APRefundReply, default initialized and not managed by a soap context
        virtual ns2__APRefundReply *soap_alloc(void) const { return SOAP_NEW(ns2__APRefundReply); }
      public:
        /// Constructor with initializations
        ns2__APRefundReply()
        {
          transactionID = (std::string *)0;
          status = (std::string *)0;
          processorResponse = (std::string *)0;
          amount = (std::string *)0;
          dateTime = (std::string *)0;
          reconciliationID = (std::string *)0;
          returnRef = (std::string *)0;
          providerResponse = (std::string *)0;
          processorTransactionID = (std::string *)0;
          paymentStatus = (std::string *)0;
          responseCode = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__APRefundReply() { }
        /// Friend allocator used by soap_new_ns2__APRefundReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__APRefundReply * SOAP_FMAC2 soap_instantiate_ns2__APRefundReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:771 */
#ifndef SOAP_TYPE_ns2__APSaleReply
#define SOAP_TYPE_ns2__APSaleReply (316)
/* complex XSD type 'ns2:APSaleReply': */
class SOAP_CMAC ns2__APSaleReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:paymentStatus' of XSD type 'xsd:string'
        std::string *paymentStatus;
        /// Optional element 'ns2:responseCode' of XSD type 'xsd:string'
        std::string *responseCode;
        /// Optional element 'ns2:merchantURL' of XSD type 'xsd:string'
        std::string *merchantURL;
        /// Optional element 'ns2:processorTransactionID' of XSD type 'xsd:string'
        std::string *processorTransactionID;
        /// Optional element 'ns2:reconciliationID' of XSD type 'xsd:string'
        std::string *reconciliationID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__APSaleReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__APSaleReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__APSaleReply, default initialized and not managed by a soap context
        virtual ns2__APSaleReply *soap_alloc(void) const { return SOAP_NEW(ns2__APSaleReply); }
      public:
        /// Constructor with initializations
        ns2__APSaleReply()
        {
          paymentStatus = (std::string *)0;
          responseCode = (std::string *)0;
          merchantURL = (std::string *)0;
          processorTransactionID = (std::string *)0;
          reconciliationID = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__APSaleReply() { }
        /// Friend allocator used by soap_new_ns2__APSaleReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__APSaleReply * SOAP_FMAC2 soap_instantiate_ns2__APSaleReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:774 */
#ifndef SOAP_TYPE_ns2__APCheckOutDetailsReply
#define SOAP_TYPE_ns2__APCheckOutDetailsReply (317)
/* complex XSD type 'ns2:APCheckOutDetailsReply': */
class SOAP_CMAC ns2__APCheckOutDetailsReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:status' of XSD type 'xsd:string'
        std::string *status;
        /// Optional element 'ns2:processorResponse' of XSD type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:dateTime' of XSD type 'ns2:dateTime'
        std::string *dateTime;
        /// Optional element 'ns2:providerResponse' of XSD type 'xsd:string'
        std::string *providerResponse;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__APCheckOutDetailsReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__APCheckOutDetailsReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__APCheckOutDetailsReply, default initialized and not managed by a soap context
        virtual ns2__APCheckOutDetailsReply *soap_alloc(void) const { return SOAP_NEW(ns2__APCheckOutDetailsReply); }
      public:
        /// Constructor with initializations
        ns2__APCheckOutDetailsReply()
        {
          status = (std::string *)0;
          processorResponse = (std::string *)0;
          dateTime = (std::string *)0;
          providerResponse = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__APCheckOutDetailsReply() { }
        /// Friend allocator used by soap_new_ns2__APCheckOutDetailsReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__APCheckOutDetailsReply * SOAP_FMAC2 soap_instantiate_ns2__APCheckOutDetailsReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:777 */
#ifndef SOAP_TYPE_ns2__APTransactionDetailsReply
#define SOAP_TYPE_ns2__APTransactionDetailsReply (318)
/* complex XSD type 'ns2:APTransactionDetailsReply': */
class SOAP_CMAC ns2__APTransactionDetailsReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:transactionID' of XSD type 'xsd:string'
        std::string *transactionID;
        /// Optional element 'ns2:status' of XSD type 'xsd:string'
        std::string *status;
        /// Optional element 'ns2:processorResponse' of XSD type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:dateTime' of XSD type 'ns2:dateTime'
        std::string *dateTime;
        /// Optional element 'ns2:reconciliationID' of XSD type 'xsd:string'
        std::string *reconciliationID;
        /// Optional element 'ns2:providerResponse' of XSD type 'xsd:string'
        std::string *providerResponse;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__APTransactionDetailsReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__APTransactionDetailsReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__APTransactionDetailsReply, default initialized and not managed by a soap context
        virtual ns2__APTransactionDetailsReply *soap_alloc(void) const { return SOAP_NEW(ns2__APTransactionDetailsReply); }
      public:
        /// Constructor with initializations
        ns2__APTransactionDetailsReply()
        {
          transactionID = (std::string *)0;
          status = (std::string *)0;
          processorResponse = (std::string *)0;
          dateTime = (std::string *)0;
          reconciliationID = (std::string *)0;
          providerResponse = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__APTransactionDetailsReply() { }
        /// Friend allocator used by soap_new_ns2__APTransactionDetailsReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__APTransactionDetailsReply * SOAP_FMAC2 soap_instantiate_ns2__APTransactionDetailsReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:780 */
#ifndef SOAP_TYPE_ns2__APConfirmPurchaseReply
#define SOAP_TYPE_ns2__APConfirmPurchaseReply (319)
/* complex XSD type 'ns2:APConfirmPurchaseReply': */
class SOAP_CMAC ns2__APConfirmPurchaseReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:status' of XSD type 'xsd:string'
        std::string *status;
        /// Optional element 'ns2:processorResponse' of XSD type 'xsd:string'
        std::string *processorResponse;
        /// Optional element 'ns2:amount' of XSD type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:dateTime' of XSD type 'ns2:dateTime'
        std::string *dateTime;
        /// Optional element 'ns2:providerResponse' of XSD type 'xsd:string'
        std::string *providerResponse;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__APConfirmPurchaseReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__APConfirmPurchaseReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__APConfirmPurchaseReply, default initialized and not managed by a soap context
        virtual ns2__APConfirmPurchaseReply *soap_alloc(void) const { return SOAP_NEW(ns2__APConfirmPurchaseReply); }
      public:
        /// Constructor with initializations
        ns2__APConfirmPurchaseReply()
        {
          status = (std::string *)0;
          processorResponse = (std::string *)0;
          amount = (std::string *)0;
          dateTime = (std::string *)0;
          providerResponse = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__APConfirmPurchaseReply() { }
        /// Friend allocator used by soap_new_ns2__APConfirmPurchaseReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__APConfirmPurchaseReply * SOAP_FMAC2 soap_instantiate_ns2__APConfirmPurchaseReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:783 */
#ifndef SOAP_TYPE_ns2__ReplyMessage
#define SOAP_TYPE_ns2__ReplyMessage (320)
/* complex XSD type 'ns2:ReplyMessage': */
class SOAP_CMAC ns2__ReplyMessage {
      public:
        /// Optional element 'ns2:merchantReferenceCode' of XSD type 'xsd:string'
        std::string *merchantReferenceCode;
        /// Required element 'ns2:requestID' of XSD type 'xsd:string'
        std::string requestID;
        /// Required element 'ns2:decision' of XSD type 'xsd:string'
        std::string decision;
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Sequence of 0 to 1000 elements 'ns2:missingField' of XSD type 'xsd:string'
        std::vector<std::string> missingField;
        /// Sequence of 0 to 1000 elements 'ns2:invalidField' of XSD type 'xsd:string'
        std::vector<std::string> invalidField;
        /// Required element 'ns2:requestToken' of XSD type 'xsd:string'
        std::string requestToken;
        /// Optional element 'ns2:purchaseTotals' of XSD type 'ns2:PurchaseTotals'
        ns2__PurchaseTotals *purchaseTotals;
        /// Sequence of 0 to 100 elements 'ns2:deniedPartiesMatch' of XSD type 'ns2:DeniedPartiesMatch'
        std::vector<ns2__DeniedPartiesMatch *> deniedPartiesMatch;
        /// Optional element 'ns2:ccAuthReply' of XSD type 'ns2:CCAuthReply'
        ns2__CCAuthReply *ccAuthReply;
        /// Optional element 'ns2:octReply' of XSD type 'ns2:OCTReply'
        ns2__OCTReply *octReply;
        /// Optional element 'ns2:verificationReply' of XSD type 'ns2:VerificationReply'
        ns2__VerificationReply *verificationReply;
        /// Optional element 'ns2:ccSaleReply' of XSD type 'ns2:CCSaleReply'
        ns2__CCSaleReply *ccSaleReply;
        /// Optional element 'ns2:ccSaleCreditReply' of XSD type 'ns2:CCSaleCreditReply'
        ns2__CCSaleCreditReply *ccSaleCreditReply;
        /// Optional element 'ns2:ccSaleReversalReply' of XSD type 'ns2:CCSaleReversalReply'
        ns2__CCSaleReversalReply *ccSaleReversalReply;
        /// Optional element 'ns2:ccIncrementalAuthReply' of XSD type 'ns2:CCIncrementalAuthReply'
        ns2__CCIncrementalAuthReply *ccIncrementalAuthReply;
        /// Optional element 'ns2:serviceFeeCalculateReply' of XSD type 'ns2:ServiceFeeCalculateReply'
        ns2__ServiceFeeCalculateReply *serviceFeeCalculateReply;
        /// Optional element 'ns2:ccCaptureReply' of XSD type 'ns2:CCCaptureReply'
        ns2__CCCaptureReply *ccCaptureReply;
        /// Optional element 'ns2:ccCreditReply' of XSD type 'ns2:CCCreditReply'
        ns2__CCCreditReply *ccCreditReply;
        /// Optional element 'ns2:ccAuthReversalReply' of XSD type 'ns2:CCAuthReversalReply'
        ns2__CCAuthReversalReply *ccAuthReversalReply;
        /// Optional element 'ns2:ccAutoAuthReversalReply' of XSD type 'ns2:CCAutoAuthReversalReply'
        ns2__CCAutoAuthReversalReply *ccAutoAuthReversalReply;
        /// Optional element 'ns2:ccDCCReply' of XSD type 'ns2:CCDCCReply'
        ns2__CCDCCReply *ccDCCReply;
        /// Optional element 'ns2:ccDCCUpdateReply' of XSD type 'ns2:CCDCCUpdateReply'
        ns2__CCDCCUpdateReply *ccDCCUpdateReply;
        /// Optional element 'ns2:ecDebitReply' of XSD type 'ns2:ECDebitReply'
        ns2__ECDebitReply *ecDebitReply;
        /// Optional element 'ns2:ecCreditReply' of XSD type 'ns2:ECCreditReply'
        ns2__ECCreditReply *ecCreditReply;
        /// Optional element 'ns2:ecAuthenticateReply' of XSD type 'ns2:ECAuthenticateReply'
        ns2__ECAuthenticateReply *ecAuthenticateReply;
        /// Optional element 'ns2:payerAuthEnrollReply' of XSD type 'ns2:PayerAuthEnrollReply'
        ns2__PayerAuthEnrollReply *payerAuthEnrollReply;
        /// Optional element 'ns2:payerAuthValidateReply' of XSD type 'ns2:PayerAuthValidateReply'
        ns2__PayerAuthValidateReply *payerAuthValidateReply;
        /// Optional element 'ns2:taxReply' of XSD type 'ns2:TaxReply'
        ns2__TaxReply *taxReply;
        /// Optional element 'ns2:encryptedPayment' of XSD type 'ns2:EncryptedPayment'
        ns2__EncryptedPayment *encryptedPayment;
        /// Optional element 'ns2:encryptPaymentDataReply' of XSD type 'ns2:EncryptPaymentDataReply'
        ns2__EncryptPaymentDataReply *encryptPaymentDataReply;
        /// Optional element 'ns2:dmeReply' of XSD type 'ns2:DMEReply'
        ns2__DMEReply *dmeReply;
        /// Optional element 'ns2:afsReply' of XSD type 'ns2:AFSReply'
        ns2__AFSReply *afsReply;
        /// Optional element 'ns2:davReply' of XSD type 'ns2:DAVReply'
        ns2__DAVReply *davReply;
        /// Optional element 'ns2:exportReply' of XSD type 'ns2:ExportReply'
        ns2__ExportReply *exportReply;
        /// Optional element 'ns2:fxRatesReply' of XSD type 'ns2:FXRatesReply'
        ns2__FXRatesReply *fxRatesReply;
        /// Optional element 'ns2:bankTransferReply' of XSD type 'ns2:BankTransferReply'
        ns2__BankTransferReply *bankTransferReply;
        /// Optional element 'ns2:bankTransferRefundReply' of XSD type 'ns2:BankTransferRefundReply'
        ns2__BankTransferRefundReply *bankTransferRefundReply;
        /// Optional element 'ns2:bankTransferRealTimeReply' of XSD type 'ns2:BankTransferRealTimeReply'
        ns2__BankTransferRealTimeReply *bankTransferRealTimeReply;
        /// Optional element 'ns2:directDebitMandateReply' of XSD type 'ns2:DirectDebitMandateReply'
        ns2__DirectDebitMandateReply *directDebitMandateReply;
        /// Optional element 'ns2:directDebitReply' of XSD type 'ns2:DirectDebitReply'
        ns2__DirectDebitReply *directDebitReply;
        /// Optional element 'ns2:directDebitValidateReply' of XSD type 'ns2:DirectDebitValidateReply'
        ns2__DirectDebitValidateReply *directDebitValidateReply;
        /// Optional element 'ns2:directDebitRefundReply' of XSD type 'ns2:DirectDebitRefundReply'
        ns2__DirectDebitRefundReply *directDebitRefundReply;
        /// Optional element 'ns2:paySubscriptionCreateReply' of XSD type 'ns2:PaySubscriptionCreateReply'
        ns2__PaySubscriptionCreateReply *paySubscriptionCreateReply;
        /// Optional element 'ns2:paySubscriptionUpdateReply' of XSD type 'ns2:PaySubscriptionUpdateReply'
        ns2__PaySubscriptionUpdateReply *paySubscriptionUpdateReply;
        /// Optional element 'ns2:paySubscriptionEventUpdateReply' of XSD type 'ns2:PaySubscriptionEventUpdateReply'
        ns2__PaySubscriptionEventUpdateReply *paySubscriptionEventUpdateReply;
        /// Optional element 'ns2:paySubscriptionRetrieveReply' of XSD type 'ns2:PaySubscriptionRetrieveReply'
        ns2__PaySubscriptionRetrieveReply *paySubscriptionRetrieveReply;
        /// Optional element 'ns2:paySubscriptionDeleteReply' of XSD type 'ns2:PaySubscriptionDeleteReply'
        ns2__PaySubscriptionDeleteReply *paySubscriptionDeleteReply;
        /// Optional element 'ns2:payPalPaymentReply' of XSD type 'ns2:PayPalPaymentReply'
        ns2__PayPalPaymentReply *payPalPaymentReply;
        /// Optional element 'ns2:payPalCreditReply' of XSD type 'ns2:PayPalCreditReply'
        ns2__PayPalCreditReply *payPalCreditReply;
        /// Optional element 'ns2:voidReply' of XSD type 'ns2:VoidReply'
        ns2__VoidReply *voidReply;
        /// Optional element 'ns2:pinlessDebitReply' of XSD type 'ns2:PinlessDebitReply'
        ns2__PinlessDebitReply *pinlessDebitReply;
        /// Optional element 'ns2:pinlessDebitValidateReply' of XSD type 'ns2:PinlessDebitValidateReply'
        ns2__PinlessDebitValidateReply *pinlessDebitValidateReply;
        /// Optional element 'ns2:pinlessDebitReversalReply' of XSD type 'ns2:PinlessDebitReversalReply'
        ns2__PinlessDebitReversalReply *pinlessDebitReversalReply;
        /// Optional element 'ns2:payPalButtonCreateReply' of XSD type 'ns2:PayPalButtonCreateReply'
        ns2__PayPalButtonCreateReply *payPalButtonCreateReply;
        /// Optional element 'ns2:payPalPreapprovedPaymentReply' of XSD type 'ns2:PayPalPreapprovedPaymentReply'
        ns2__PayPalPreapprovedPaymentReply *payPalPreapprovedPaymentReply;
        /// Optional element 'ns2:payPalPreapprovedUpdateReply' of XSD type 'ns2:PayPalPreapprovedUpdateReply'
        ns2__PayPalPreapprovedUpdateReply *payPalPreapprovedUpdateReply;
        /// Optional element 'ns2:riskUpdateReply' of XSD type 'ns2:RiskUpdateReply'
        ns2__RiskUpdateReply *riskUpdateReply;
        /// Optional element 'ns2:fraudUpdateReply' of XSD type 'ns2:FraudUpdateReply'
        ns2__FraudUpdateReply *fraudUpdateReply;
        /// Optional element 'ns2:caseManagementActionReply' of XSD type 'ns2:CaseManagementActionReply'
        ns2__CaseManagementActionReply *caseManagementActionReply;
        /// Optional element 'ns2:decisionReply' of XSD type 'ns2:DecisionReply'
        ns2__DecisionReply *decisionReply;
        /// Optional element 'ns2:payPalRefundReply' of XSD type 'ns2:PayPalRefundReply'
        ns2__PayPalRefundReply *payPalRefundReply;
        /// Optional element 'ns2:payPalAuthReversalReply' of XSD type 'ns2:PayPalAuthReversalReply'
        ns2__PayPalAuthReversalReply *payPalAuthReversalReply;
        /// Optional element 'ns2:payPalDoCaptureReply' of XSD type 'ns2:PayPalDoCaptureReply'
        ns2__PayPalDoCaptureReply *payPalDoCaptureReply;
        /// Optional element 'ns2:payPalEcDoPaymentReply' of XSD type 'ns2:PayPalEcDoPaymentReply'
        ns2__PayPalEcDoPaymentReply *payPalEcDoPaymentReply;
        /// Optional element 'ns2:payPalEcGetDetailsReply' of XSD type 'ns2:PayPalEcGetDetailsReply'
        ns2__PayPalEcGetDetailsReply *payPalEcGetDetailsReply;
        /// Optional element 'ns2:payPalEcSetReply' of XSD type 'ns2:PayPalEcSetReply'
        ns2__PayPalEcSetReply *payPalEcSetReply;
        /// Optional element 'ns2:payPalAuthorizationReply' of XSD type 'ns2:PayPalAuthorizationReply'
        ns2__PayPalAuthorizationReply *payPalAuthorizationReply;
        /// Optional element 'ns2:payPalEcOrderSetupReply' of XSD type 'ns2:PayPalEcOrderSetupReply'
        ns2__PayPalEcOrderSetupReply *payPalEcOrderSetupReply;
        /// Optional element 'ns2:payPalUpdateAgreementReply' of XSD type 'ns2:PayPalUpdateAgreementReply'
        ns2__PayPalUpdateAgreementReply *payPalUpdateAgreementReply;
        /// Optional element 'ns2:payPalCreateAgreementReply' of XSD type 'ns2:PayPalCreateAgreementReply'
        ns2__PayPalCreateAgreementReply *payPalCreateAgreementReply;
        /// Optional element 'ns2:payPalDoRefTransactionReply' of XSD type 'ns2:PayPalDoRefTransactionReply'
        ns2__PayPalDoRefTransactionReply *payPalDoRefTransactionReply;
        /// Optional element 'ns2:chinaPaymentReply' of XSD type 'ns2:ChinaPaymentReply'
        ns2__ChinaPaymentReply *chinaPaymentReply;
        /// Optional element 'ns2:chinaRefundReply' of XSD type 'ns2:ChinaRefundReply'
        ns2__ChinaRefundReply *chinaRefundReply;
        /// Optional element 'ns2:boletoPaymentReply' of XSD type 'ns2:BoletoPaymentReply'
        ns2__BoletoPaymentReply *boletoPaymentReply;
        /// Optional element 'ns2:pinDebitPurchaseReply' of XSD type 'ns2:PinDebitPurchaseReply'
        ns2__PinDebitPurchaseReply *pinDebitPurchaseReply;
        /// Optional element 'ns2:pinDebitCreditReply' of XSD type 'ns2:PinDebitCreditReply'
        ns2__PinDebitCreditReply *pinDebitCreditReply;
        /// Optional element 'ns2:pinDebitReversalReply' of XSD type 'ns2:PinDebitReversalReply'
        ns2__PinDebitReversalReply *pinDebitReversalReply;
        /// Optional element 'ns2:apInitiateReply' of XSD type 'ns2:APInitiateReply'
        ns2__APInitiateReply *apInitiateReply;
        /// Optional element 'ns2:apCheckStatusReply' of XSD type 'ns2:APCheckStatusReply'
        ns2__APCheckStatusReply *apCheckStatusReply;
        /// Optional element 'ns2:receiptNumber' of XSD type 'xsd:string'
        std::string *receiptNumber;
        /// Optional element 'ns2:additionalData' of XSD type 'xsd:string'
        std::string *additionalData;
        /// Optional element 'ns2:solutionProviderTransactionID' of XSD type 'xsd:string'
        std::string *solutionProviderTransactionID;
        /// Optional element 'ns2:apReply' of XSD type 'ns2:APReply'
        ns2__APReply *apReply;
        /// Optional element 'ns2:shipTo' of XSD type 'ns2:ShipTo'
        ns2__ShipTo *shipTo;
        /// Optional element 'ns2:billTo' of XSD type 'ns2:BillTo'
        ns2__BillTo *billTo;
        /// Optional element 'ns2:apAuthReply' of XSD type 'ns2:APAuthReply'
        ns2__APAuthReply *apAuthReply;
        /// Optional element 'ns2:apAuthReversalReply' of XSD type 'ns2:APAuthReversalReply'
        ns2__APAuthReversalReply *apAuthReversalReply;
        /// Optional element 'ns2:apCaptureReply' of XSD type 'ns2:APCaptureReply'
        ns2__APCaptureReply *apCaptureReply;
        /// Optional element 'ns2:apOptionsReply' of XSD type 'ns2:APOptionsReply'
        ns2__APOptionsReply *apOptionsReply;
        /// Optional element 'ns2:apRefundReply' of XSD type 'ns2:APRefundReply'
        ns2__APRefundReply *apRefundReply;
        /// Optional element 'ns2:apSaleReply' of XSD type 'ns2:APSaleReply'
        ns2__APSaleReply *apSaleReply;
        /// Optional element 'ns2:apCheckoutDetailsReply' of XSD type 'ns2:APCheckOutDetailsReply'
        ns2__APCheckOutDetailsReply *apCheckoutDetailsReply;
        /// Optional element 'ns2:apTransactionDetailsReply' of XSD type 'ns2:APTransactionDetailsReply'
        ns2__APTransactionDetailsReply *apTransactionDetailsReply;
        /// Optional element 'ns2:apConfirmPurchaseReply' of XSD type 'ns2:APConfirmPurchaseReply'
        ns2__APConfirmPurchaseReply *apConfirmPurchaseReply;
        /// Optional element 'ns2:promotion' of XSD type 'ns2:Promotion'
        ns2__Promotion *promotion;
        /// Sequence of 0 to 100 elements 'ns2:promotionGroup' of XSD type 'ns2:PromotionGroupReply'
        std::vector<ns2__PromotionGroupReply *> promotionGroup;
        /// Optional element 'ns2:payPalGetTxnDetailsReply' of XSD type 'ns2:PayPalGetTxnDetailsReply'
        ns2__PayPalGetTxnDetailsReply *payPalGetTxnDetailsReply;
        /// Optional element 'ns2:payPalTransactionSearchReply' of XSD type 'ns2:PayPalTransactionSearchReply'
        ns2__PayPalTransactionSearchReply *payPalTransactionSearchReply;
        /// Optional element 'ns2:emvReply' of XSD type 'ns2:EmvReply'
        ns2__EmvReply *emvReply;
        /// Optional element 'ns2:originalTransaction' of XSD type 'ns2:OriginalTransaction'
        ns2__OriginalTransaction *originalTransaction;
        /// Optional element 'ns2:hostedDataCreateReply' of XSD type 'ns2:HostedDataCreateReply'
        ns2__HostedDataCreateReply *hostedDataCreateReply;
        /// Optional element 'ns2:hostedDataRetrieveReply' of XSD type 'ns2:HostedDataRetrieveReply'
        ns2__HostedDataRetrieveReply *hostedDataRetrieveReply;
        /// Optional element 'ns2:salesSlipNumber' of XSD type 'xsd:string'
        std::string *salesSlipNumber;
        /// Optional element 'ns2:additionalProcessorResponse' of XSD type 'xsd:string'
        std::string *additionalProcessorResponse;
        /// Optional element 'ns2:jpo' of XSD type 'ns2:JPO'
        ns2__JPO *jpo;
        /// Optional element 'ns2:card' of XSD type 'ns2:Card'
        ns2__Card *card;
        /// Optional element 'ns2:paymentNetworkToken' of XSD type 'ns2:PaymentNetworkToken'
        ns2__PaymentNetworkToken *paymentNetworkToken;
        /// Optional element 'ns2:vcReply' of XSD type 'ns2:VCReply'
        ns2__VCReply *vcReply;
        /// Optional element 'ns2:decryptVisaCheckoutDataReply' of XSD type 'ns2:DecryptVisaCheckoutDataReply'
        ns2__DecryptVisaCheckoutDataReply *decryptVisaCheckoutDataReply;
        /// Optional element 'ns2:binLookupReply' of XSD type 'ns2:BinLookupReply'
        ns2__BinLookupReply *binLookupReply;
        /// Optional element 'ns2:issuerMessage' of XSD type 'xsd:string'
        std::string *issuerMessage;
        /// Optional element 'ns2:token' of XSD type 'ns2:Token'
        ns2__Token *token;
        /// Optional element 'ns2:issuer' of XSD type 'ns2:issuer'
        ns2__issuer *issuer;
        /// Optional element 'ns2:recipient' of XSD type 'ns2:Recipient'
        ns2__Recipient *recipient;
        /// Optional element 'ns2:reserved' of XSD type 'ns2:ReplyReserved'
        ns2__ReplyReserved *reserved;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ReplyMessage
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ReplyMessage; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ReplyMessage, default initialized and not managed by a soap context
        virtual ns2__ReplyMessage *soap_alloc(void) const { return SOAP_NEW(ns2__ReplyMessage); }
      public:
        /// Constructor with initializations
        ns2__ReplyMessage()
        {
          merchantReferenceCode = (std::string *)0;
          purchaseTotals = (ns2__PurchaseTotals *)0;
          ccAuthReply = (ns2__CCAuthReply *)0;
          octReply = (ns2__OCTReply *)0;
          verificationReply = (ns2__VerificationReply *)0;
          ccSaleReply = (ns2__CCSaleReply *)0;
          ccSaleCreditReply = (ns2__CCSaleCreditReply *)0;
          ccSaleReversalReply = (ns2__CCSaleReversalReply *)0;
          ccIncrementalAuthReply = (ns2__CCIncrementalAuthReply *)0;
          serviceFeeCalculateReply = (ns2__ServiceFeeCalculateReply *)0;
          ccCaptureReply = (ns2__CCCaptureReply *)0;
          ccCreditReply = (ns2__CCCreditReply *)0;
          ccAuthReversalReply = (ns2__CCAuthReversalReply *)0;
          ccAutoAuthReversalReply = (ns2__CCAutoAuthReversalReply *)0;
          ccDCCReply = (ns2__CCDCCReply *)0;
          ccDCCUpdateReply = (ns2__CCDCCUpdateReply *)0;
          ecDebitReply = (ns2__ECDebitReply *)0;
          ecCreditReply = (ns2__ECCreditReply *)0;
          ecAuthenticateReply = (ns2__ECAuthenticateReply *)0;
          payerAuthEnrollReply = (ns2__PayerAuthEnrollReply *)0;
          payerAuthValidateReply = (ns2__PayerAuthValidateReply *)0;
          taxReply = (ns2__TaxReply *)0;
          encryptedPayment = (ns2__EncryptedPayment *)0;
          encryptPaymentDataReply = (ns2__EncryptPaymentDataReply *)0;
          dmeReply = (ns2__DMEReply *)0;
          afsReply = (ns2__AFSReply *)0;
          davReply = (ns2__DAVReply *)0;
          exportReply = (ns2__ExportReply *)0;
          fxRatesReply = (ns2__FXRatesReply *)0;
          bankTransferReply = (ns2__BankTransferReply *)0;
          bankTransferRefundReply = (ns2__BankTransferRefundReply *)0;
          bankTransferRealTimeReply = (ns2__BankTransferRealTimeReply *)0;
          directDebitMandateReply = (ns2__DirectDebitMandateReply *)0;
          directDebitReply = (ns2__DirectDebitReply *)0;
          directDebitValidateReply = (ns2__DirectDebitValidateReply *)0;
          directDebitRefundReply = (ns2__DirectDebitRefundReply *)0;
          paySubscriptionCreateReply = (ns2__PaySubscriptionCreateReply *)0;
          paySubscriptionUpdateReply = (ns2__PaySubscriptionUpdateReply *)0;
          paySubscriptionEventUpdateReply = (ns2__PaySubscriptionEventUpdateReply *)0;
          paySubscriptionRetrieveReply = (ns2__PaySubscriptionRetrieveReply *)0;
          paySubscriptionDeleteReply = (ns2__PaySubscriptionDeleteReply *)0;
          payPalPaymentReply = (ns2__PayPalPaymentReply *)0;
          payPalCreditReply = (ns2__PayPalCreditReply *)0;
          voidReply = (ns2__VoidReply *)0;
          pinlessDebitReply = (ns2__PinlessDebitReply *)0;
          pinlessDebitValidateReply = (ns2__PinlessDebitValidateReply *)0;
          pinlessDebitReversalReply = (ns2__PinlessDebitReversalReply *)0;
          payPalButtonCreateReply = (ns2__PayPalButtonCreateReply *)0;
          payPalPreapprovedPaymentReply = (ns2__PayPalPreapprovedPaymentReply *)0;
          payPalPreapprovedUpdateReply = (ns2__PayPalPreapprovedUpdateReply *)0;
          riskUpdateReply = (ns2__RiskUpdateReply *)0;
          fraudUpdateReply = (ns2__FraudUpdateReply *)0;
          caseManagementActionReply = (ns2__CaseManagementActionReply *)0;
          decisionReply = (ns2__DecisionReply *)0;
          payPalRefundReply = (ns2__PayPalRefundReply *)0;
          payPalAuthReversalReply = (ns2__PayPalAuthReversalReply *)0;
          payPalDoCaptureReply = (ns2__PayPalDoCaptureReply *)0;
          payPalEcDoPaymentReply = (ns2__PayPalEcDoPaymentReply *)0;
          payPalEcGetDetailsReply = (ns2__PayPalEcGetDetailsReply *)0;
          payPalEcSetReply = (ns2__PayPalEcSetReply *)0;
          payPalAuthorizationReply = (ns2__PayPalAuthorizationReply *)0;
          payPalEcOrderSetupReply = (ns2__PayPalEcOrderSetupReply *)0;
          payPalUpdateAgreementReply = (ns2__PayPalUpdateAgreementReply *)0;
          payPalCreateAgreementReply = (ns2__PayPalCreateAgreementReply *)0;
          payPalDoRefTransactionReply = (ns2__PayPalDoRefTransactionReply *)0;
          chinaPaymentReply = (ns2__ChinaPaymentReply *)0;
          chinaRefundReply = (ns2__ChinaRefundReply *)0;
          boletoPaymentReply = (ns2__BoletoPaymentReply *)0;
          pinDebitPurchaseReply = (ns2__PinDebitPurchaseReply *)0;
          pinDebitCreditReply = (ns2__PinDebitCreditReply *)0;
          pinDebitReversalReply = (ns2__PinDebitReversalReply *)0;
          apInitiateReply = (ns2__APInitiateReply *)0;
          apCheckStatusReply = (ns2__APCheckStatusReply *)0;
          receiptNumber = (std::string *)0;
          additionalData = (std::string *)0;
          solutionProviderTransactionID = (std::string *)0;
          apReply = (ns2__APReply *)0;
          shipTo = (ns2__ShipTo *)0;
          billTo = (ns2__BillTo *)0;
          apAuthReply = (ns2__APAuthReply *)0;
          apAuthReversalReply = (ns2__APAuthReversalReply *)0;
          apCaptureReply = (ns2__APCaptureReply *)0;
          apOptionsReply = (ns2__APOptionsReply *)0;
          apRefundReply = (ns2__APRefundReply *)0;
          apSaleReply = (ns2__APSaleReply *)0;
          apCheckoutDetailsReply = (ns2__APCheckOutDetailsReply *)0;
          apTransactionDetailsReply = (ns2__APTransactionDetailsReply *)0;
          apConfirmPurchaseReply = (ns2__APConfirmPurchaseReply *)0;
          promotion = (ns2__Promotion *)0;
          payPalGetTxnDetailsReply = (ns2__PayPalGetTxnDetailsReply *)0;
          payPalTransactionSearchReply = (ns2__PayPalTransactionSearchReply *)0;
          emvReply = (ns2__EmvReply *)0;
          originalTransaction = (ns2__OriginalTransaction *)0;
          hostedDataCreateReply = (ns2__HostedDataCreateReply *)0;
          hostedDataRetrieveReply = (ns2__HostedDataRetrieveReply *)0;
          salesSlipNumber = (std::string *)0;
          additionalProcessorResponse = (std::string *)0;
          jpo = (ns2__JPO *)0;
          card = (ns2__Card *)0;
          paymentNetworkToken = (ns2__PaymentNetworkToken *)0;
          vcReply = (ns2__VCReply *)0;
          decryptVisaCheckoutDataReply = (ns2__DecryptVisaCheckoutDataReply *)0;
          binLookupReply = (ns2__BinLookupReply *)0;
          issuerMessage = (std::string *)0;
          token = (ns2__Token *)0;
          issuer = (ns2__issuer *)0;
          recipient = (ns2__Recipient *)0;
          reserved = (ns2__ReplyReserved *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__ReplyMessage() { }
        /// Friend allocator used by soap_new_ns2__ReplyMessage(struct soap*, int)
        friend SOAP_FMAC1 ns2__ReplyMessage * SOAP_FMAC2 soap_instantiate_ns2__ReplyMessage(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:786 */
#ifndef SOAP_TYPE_ns2__FaultDetails
#define SOAP_TYPE_ns2__FaultDetails (321)
/* complex XSD type 'ns2:FaultDetails': */
class SOAP_CMAC ns2__FaultDetails {
      public:
        /// Required element 'ns2:requestID' of XSD type 'xsd:string'
        std::string requestID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__FaultDetails
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__FaultDetails; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__FaultDetails, default initialized and not managed by a soap context
        virtual ns2__FaultDetails *soap_alloc(void) const { return SOAP_NEW(ns2__FaultDetails); }
      public:
        /// Constructor with initializations
        ns2__FaultDetails()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__FaultDetails() { }
        /// Friend allocator used by soap_new_ns2__FaultDetails(struct soap*, int)
        friend SOAP_FMAC1 ns2__FaultDetails * SOAP_FMAC2 soap_instantiate_ns2__FaultDetails(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:789 */
#ifndef SOAP_TYPE_ns2__AirlineData
#define SOAP_TYPE_ns2__AirlineData (322)
/* complex XSD type 'ns2:AirlineData': */
class SOAP_CMAC ns2__AirlineData {
      public:
        /// Optional element 'ns2:agentCode' of XSD type 'xsd:string'
        std::string *agentCode;
        /// Optional element 'ns2:agentName' of XSD type 'xsd:string'
        std::string *agentName;
        /// Optional element 'ns2:ticketIssuerCity' of XSD type 'xsd:string'
        std::string *ticketIssuerCity;
        /// Optional element 'ns2:ticketIssuerState' of XSD type 'xsd:string'
        std::string *ticketIssuerState;
        /// Optional element 'ns2:ticketIssuerPostalCode' of XSD type 'xsd:string'
        std::string *ticketIssuerPostalCode;
        /// Optional element 'ns2:ticketIssuerCountry' of XSD type 'xsd:string'
        std::string *ticketIssuerCountry;
        /// Optional element 'ns2:ticketIssuerAddress' of XSD type 'xsd:string'
        std::string *ticketIssuerAddress;
        /// Optional element 'ns2:ticketIssuerCode' of XSD type 'xsd:string'
        std::string *ticketIssuerCode;
        /// Optional element 'ns2:ticketIssuerName' of XSD type 'xsd:string'
        std::string *ticketIssuerName;
        /// Optional element 'ns2:ticketNumber' of XSD type 'xsd:string'
        std::string *ticketNumber;
        /// Optional element 'ns2:checkDigit' of XSD type 'xsd:integer'
        std::string *checkDigit;
        /// Optional element 'ns2:restrictedTicketIndicator' of XSD type 'xsd:integer'
        std::string *restrictedTicketIndicator;
        /// Optional element 'ns2:transactionType' of XSD type 'xsd:string'
        std::string *transactionType;
        /// Optional element 'ns2:extendedPaymentCode' of XSD type 'xsd:string'
        std::string *extendedPaymentCode;
        /// Optional element 'ns2:carrierName' of XSD type 'xsd:string'
        std::string *carrierName;
        /// Optional element 'ns2:passengerName' of XSD type 'xsd:string'
        std::string *passengerName;
        /// Optional element 'ns2:customerCode' of XSD type 'xsd:string'
        std::string *customerCode;
        /// Optional element 'ns2:documentType' of XSD type 'xsd:string'
        std::string *documentType;
        /// Optional element 'ns2:documentNumber' of XSD type 'xsd:string'
        std::string *documentNumber;
        /// Optional element 'ns2:documentNumberOfParts' of XSD type 'xsd:string'
        std::string *documentNumberOfParts;
        /// Optional element 'ns2:invoiceNumber' of XSD type 'xsd:string'
        std::string *invoiceNumber;
        /// Optional element 'ns2:invoiceDate' of XSD type 'xsd:string'
        std::string *invoiceDate;
        /// Optional element 'ns2:chargeDetails' of XSD type 'xsd:string'
        std::string *chargeDetails;
        /// Optional element 'ns2:bookingReference' of XSD type 'xsd:string'
        std::string *bookingReference;
        /// Optional element 'ns2:totalFee' of XSD type 'ns2:amount'
        std::string *totalFee;
        /// Optional element 'ns2:clearingSequence' of XSD type 'xsd:string'
        std::string *clearingSequence;
        /// Optional element 'ns2:clearingCount' of XSD type 'xsd:integer'
        std::string *clearingCount;
        /// Optional element 'ns2:totalClearingAmount' of XSD type 'ns2:amount'
        std::string *totalClearingAmount;
        /// Sequence of 0 to 1000 elements 'ns2:leg' of XSD type 'ns2:Leg'
        std::vector<ns2__Leg *> leg;
        /// Optional element 'ns2:numberOfPassengers' of XSD type 'xsd:string'
        std::string *numberOfPassengers;
        /// Optional element 'ns2:reservationSystem' of XSD type 'xsd:string'
        std::string *reservationSystem;
        /// Optional element 'ns2:processIdentifier' of XSD type 'xsd:string'
        std::string *processIdentifier;
        /// Optional element 'ns2:iataNumericCode' of XSD type 'xsd:string'
        std::string *iataNumericCode;
        /// Optional element 'ns2:ticketIssueDate' of XSD type 'xsd:string'
        std::string *ticketIssueDate;
        /// Optional element 'ns2:electronicTicket' of XSD type 'xsd:string'
        std::string *electronicTicket;
        /// Optional element 'ns2:originalTicketNumber' of XSD type 'xsd:string'
        std::string *originalTicketNumber;
        /// Optional element 'ns2:purchaseType' of XSD type 'xsd:string'
        std::string *purchaseType;
        /// Optional element 'ns2:creditReasonIndicator' of XSD type 'xsd:string'
        std::string *creditReasonIndicator;
        /// Optional element 'ns2:ticketUpdateIndicator' of XSD type 'xsd:string'
        std::string *ticketUpdateIndicator;
        /// Optional element 'ns2:planNumber' of XSD type 'xsd:string'
        std::string *planNumber;
        /// Optional element 'ns2:arrivalDate' of XSD type 'xsd:string'
        std::string *arrivalDate;
        /// Optional element 'ns2:ticketRestrictionText' of XSD type 'xsd:string'
        std::string *ticketRestrictionText;
        /// Optional element 'ns2:exchangeTicketAmount' of XSD type 'ns2:amount'
        std::string *exchangeTicketAmount;
        /// Optional element 'ns2:exchangeTicketFee' of XSD type 'ns2:amount'
        std::string *exchangeTicketFee;
        /// Optional element 'ns2:journeyType' of XSD type 'xsd:string'
        std::string *journeyType;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__AirlineData
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__AirlineData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__AirlineData, default initialized and not managed by a soap context
        virtual ns2__AirlineData *soap_alloc(void) const { return SOAP_NEW(ns2__AirlineData); }
      public:
        /// Constructor with initializations
        ns2__AirlineData()
        {
          agentCode = (std::string *)0;
          agentName = (std::string *)0;
          ticketIssuerCity = (std::string *)0;
          ticketIssuerState = (std::string *)0;
          ticketIssuerPostalCode = (std::string *)0;
          ticketIssuerCountry = (std::string *)0;
          ticketIssuerAddress = (std::string *)0;
          ticketIssuerCode = (std::string *)0;
          ticketIssuerName = (std::string *)0;
          ticketNumber = (std::string *)0;
          checkDigit = (std::string *)0;
          restrictedTicketIndicator = (std::string *)0;
          transactionType = (std::string *)0;
          extendedPaymentCode = (std::string *)0;
          carrierName = (std::string *)0;
          passengerName = (std::string *)0;
          customerCode = (std::string *)0;
          documentType = (std::string *)0;
          documentNumber = (std::string *)0;
          documentNumberOfParts = (std::string *)0;
          invoiceNumber = (std::string *)0;
          invoiceDate = (std::string *)0;
          chargeDetails = (std::string *)0;
          bookingReference = (std::string *)0;
          totalFee = (std::string *)0;
          clearingSequence = (std::string *)0;
          clearingCount = (std::string *)0;
          totalClearingAmount = (std::string *)0;
          numberOfPassengers = (std::string *)0;
          reservationSystem = (std::string *)0;
          processIdentifier = (std::string *)0;
          iataNumericCode = (std::string *)0;
          ticketIssueDate = (std::string *)0;
          electronicTicket = (std::string *)0;
          originalTicketNumber = (std::string *)0;
          purchaseType = (std::string *)0;
          creditReasonIndicator = (std::string *)0;
          ticketUpdateIndicator = (std::string *)0;
          planNumber = (std::string *)0;
          arrivalDate = (std::string *)0;
          ticketRestrictionText = (std::string *)0;
          exchangeTicketAmount = (std::string *)0;
          exchangeTicketFee = (std::string *)0;
          journeyType = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__AirlineData() { }
        /// Friend allocator used by soap_new_ns2__AirlineData(struct soap*, int)
        friend SOAP_FMAC1 ns2__AirlineData * SOAP_FMAC2 soap_instantiate_ns2__AirlineData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:792 */
#ifndef SOAP_TYPE_ns2__Leg
#define SOAP_TYPE_ns2__Leg (323)
/* complex XSD type 'ns2:Leg': */
class SOAP_CMAC ns2__Leg {
      public:
        /// Optional element 'ns2:carrierCode' of XSD type 'xsd:string'
        std::string *carrierCode;
        /// Optional element 'ns2:flightNumber' of XSD type 'xsd:string'
        std::string *flightNumber;
        /// Optional element 'ns2:originatingAirportCode' of XSD type 'xsd:string'
        std::string *originatingAirportCode;
        /// Optional element 'ns2:class' of XSD type 'xsd:string'
        std::string *class_;
        /// Optional element 'ns2:stopoverCode' of XSD type 'xsd:string'
        std::string *stopoverCode;
        /// Optional element 'ns2:departureDate' of XSD type 'xsd:string'
        std::string *departureDate;
        /// Optional element 'ns2:destination' of XSD type 'xsd:string'
        std::string *destination;
        /// Optional element 'ns2:fareBasis' of XSD type 'xsd:string'
        std::string *fareBasis;
        /// Optional element 'ns2:departTax' of XSD type 'xsd:string'
        std::string *departTax;
        /// Optional element 'ns2:conjunctionTicket' of XSD type 'xsd:string'
        std::string *conjunctionTicket;
        /// Optional element 'ns2:exchangeTicket' of XSD type 'xsd:string'
        std::string *exchangeTicket;
        /// Optional element 'ns2:couponNumber' of XSD type 'xsd:string'
        std::string *couponNumber;
        /// Optional element 'ns2:departureTime' of XSD type 'xsd:string'
        std::string *departureTime;
        /// Optional element 'ns2:departureTimeSegment' of XSD type 'xsd:string'
        std::string *departureTimeSegment;
        /// Optional element 'ns2:arrivalTime' of XSD type 'xsd:string'
        std::string *arrivalTime;
        /// Optional element 'ns2:arrivalTimeSegment' of XSD type 'xsd:string'
        std::string *arrivalTimeSegment;
        /// Optional element 'ns2:endorsementsRestrictions' of XSD type 'xsd:string'
        std::string *endorsementsRestrictions;
        /// Optional element 'ns2:fare' of XSD type 'xsd:string'
        std::string *fare;
        /// Optional element 'ns2:fee' of XSD type 'xsd:string'
        std::string *fee;
        /// Optional element 'ns2:tax' of XSD type 'xsd:string'
        std::string *tax;
        /// required attribute 'id' of XSD type 'xsd:integer'
        std::string id;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Leg
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__Leg; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Leg, default initialized and not managed by a soap context
        virtual ns2__Leg *soap_alloc(void) const { return SOAP_NEW(ns2__Leg); }
      public:
        /// Constructor with initializations
        ns2__Leg()
        {
          carrierCode = (std::string *)0;
          flightNumber = (std::string *)0;
          originatingAirportCode = (std::string *)0;
          class_ = (std::string *)0;
          stopoverCode = (std::string *)0;
          departureDate = (std::string *)0;
          destination = (std::string *)0;
          fareBasis = (std::string *)0;
          departTax = (std::string *)0;
          conjunctionTicket = (std::string *)0;
          exchangeTicket = (std::string *)0;
          couponNumber = (std::string *)0;
          departureTime = (std::string *)0;
          departureTimeSegment = (std::string *)0;
          arrivalTime = (std::string *)0;
          arrivalTimeSegment = (std::string *)0;
          endorsementsRestrictions = (std::string *)0;
          fare = (std::string *)0;
          fee = (std::string *)0;
          tax = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__Leg() { }
        /// Friend allocator used by soap_new_ns2__Leg(struct soap*, int)
        friend SOAP_FMAC1 ns2__Leg * SOAP_FMAC2 soap_instantiate_ns2__Leg(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:795 */
#ifndef SOAP_TYPE_ns2__AncillaryData
#define SOAP_TYPE_ns2__AncillaryData (324)
/* complex XSD type 'ns2:AncillaryData': */
class SOAP_CMAC ns2__AncillaryData {
      public:
        /// Optional element 'ns2:ticketNumber' of XSD type 'xsd:string'
        std::string *ticketNumber;
        /// Optional element 'ns2:passengerName' of XSD type 'xsd:string'
        std::string *passengerName;
        /// Optional element 'ns2:connectedTicketNumber' of XSD type 'xsd:string'
        std::string *connectedTicketNumber;
        /// Optional element 'ns2:creditReasonIndicator' of XSD type 'xsd:string'
        std::string *creditReasonIndicator;
        /// Sequence of 0 to 1000 elements 'ns2:service' of XSD type 'ns2:Service'
        std::vector<ns2__Service *> service;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__AncillaryData
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__AncillaryData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__AncillaryData, default initialized and not managed by a soap context
        virtual ns2__AncillaryData *soap_alloc(void) const { return SOAP_NEW(ns2__AncillaryData); }
      public:
        /// Constructor with initializations
        ns2__AncillaryData()
        {
          ticketNumber = (std::string *)0;
          passengerName = (std::string *)0;
          connectedTicketNumber = (std::string *)0;
          creditReasonIndicator = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__AncillaryData() { }
        /// Friend allocator used by soap_new_ns2__AncillaryData(struct soap*, int)
        friend SOAP_FMAC1 ns2__AncillaryData * SOAP_FMAC2 soap_instantiate_ns2__AncillaryData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:798 */
#ifndef SOAP_TYPE_ns2__Service
#define SOAP_TYPE_ns2__Service (325)
/* complex XSD type 'ns2:Service': */
class SOAP_CMAC ns2__Service {
      public:
        /// Optional element 'ns2:categoryCode' of XSD type 'xsd:string'
        std::string *categoryCode;
        /// Optional element 'ns2:subcategoryCode' of XSD type 'xsd:string'
        std::string *subcategoryCode;
        /// required attribute 'id' of XSD type 'xsd:integer'
        std::string id;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Service
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__Service; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Service, default initialized and not managed by a soap context
        virtual ns2__Service *soap_alloc(void) const { return SOAP_NEW(ns2__Service); }
      public:
        /// Constructor with initializations
        ns2__Service()
        {
          categoryCode = (std::string *)0;
          subcategoryCode = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__Service() { }
        /// Friend allocator used by soap_new_ns2__Service(struct soap*, int)
        friend SOAP_FMAC1 ns2__Service * SOAP_FMAC2 soap_instantiate_ns2__Service(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:801 */
#ifndef SOAP_TYPE_ns2__LodgingData
#define SOAP_TYPE_ns2__LodgingData (326)
/* complex XSD type 'ns2:LodgingData': */
class SOAP_CMAC ns2__LodgingData {
      public:
        /// Optional element 'ns2:checkInDate' of XSD type 'xsd:string'
        std::string *checkInDate;
        /// Optional element 'ns2:checkOutDate' of XSD type 'xsd:string'
        std::string *checkOutDate;
        /// Optional element 'ns2:dailyRoomRate1' of XSD type 'ns2:amount'
        std::string *dailyRoomRate1;
        /// Optional element 'ns2:dailyRoomRate2' of XSD type 'ns2:amount'
        std::string *dailyRoomRate2;
        /// Optional element 'ns2:dailyRoomRate3' of XSD type 'ns2:amount'
        std::string *dailyRoomRate3;
        /// Optional element 'ns2:roomNights1' of XSD type 'xsd:integer'
        std::string *roomNights1;
        /// Optional element 'ns2:roomNights2' of XSD type 'xsd:integer'
        std::string *roomNights2;
        /// Optional element 'ns2:roomNights3' of XSD type 'xsd:integer'
        std::string *roomNights3;
        /// Optional element 'ns2:guestSmokingPreference' of XSD type 'xsd:string'
        std::string *guestSmokingPreference;
        /// Optional element 'ns2:numberOfRoomsBooked' of XSD type 'xsd:integer'
        std::string *numberOfRoomsBooked;
        /// Optional element 'ns2:numberOfGuests' of XSD type 'xsd:integer'
        std::string *numberOfGuests;
        /// Optional element 'ns2:roomBedType' of XSD type 'xsd:string'
        std::string *roomBedType;
        /// Optional element 'ns2:roomTaxElements' of XSD type 'xsd:string'
        std::string *roomTaxElements;
        /// Optional element 'ns2:roomRateType' of XSD type 'xsd:string'
        std::string *roomRateType;
        /// Optional element 'ns2:guestName' of XSD type 'xsd:string'
        std::string *guestName;
        /// Optional element 'ns2:customerServicePhoneNumber' of XSD type 'xsd:string'
        std::string *customerServicePhoneNumber;
        /// Optional element 'ns2:corporateClientCode' of XSD type 'xsd:string'
        std::string *corporateClientCode;
        /// Optional element 'ns2:promotionalCode' of XSD type 'xsd:string'
        std::string *promotionalCode;
        /// Optional element 'ns2:additionalCoupon' of XSD type 'xsd:string'
        std::string *additionalCoupon;
        /// Optional element 'ns2:roomLocation' of XSD type 'xsd:string'
        std::string *roomLocation;
        /// Optional element 'ns2:specialProgramCode' of XSD type 'xsd:string'
        std::string *specialProgramCode;
        /// Optional element 'ns2:tax' of XSD type 'ns2:amount'
        std::string *tax;
        /// Optional element 'ns2:prepaidCost' of XSD type 'ns2:amount'
        std::string *prepaidCost;
        /// Optional element 'ns2:foodAndBeverageCost' of XSD type 'ns2:amount'
        std::string *foodAndBeverageCost;
        /// Optional element 'ns2:roomTax' of XSD type 'ns2:amount'
        std::string *roomTax;
        /// Optional element 'ns2:adjustmentAmount' of XSD type 'ns2:amount'
        std::string *adjustmentAmount;
        /// Optional element 'ns2:phoneCost' of XSD type 'ns2:amount'
        std::string *phoneCost;
        /// Optional element 'ns2:restaurantCost' of XSD type 'ns2:amount'
        std::string *restaurantCost;
        /// Optional element 'ns2:roomServiceCost' of XSD type 'ns2:amount'
        std::string *roomServiceCost;
        /// Optional element 'ns2:miniBarCost' of XSD type 'ns2:amount'
        std::string *miniBarCost;
        /// Optional element 'ns2:laundryCost' of XSD type 'ns2:amount'
        std::string *laundryCost;
        /// Optional element 'ns2:miscellaneousCost' of XSD type 'ns2:amount'
        std::string *miscellaneousCost;
        /// Optional element 'ns2:giftShopCost' of XSD type 'ns2:amount'
        std::string *giftShopCost;
        /// Optional element 'ns2:movieCost' of XSD type 'ns2:amount'
        std::string *movieCost;
        /// Optional element 'ns2:healthClubCost' of XSD type 'ns2:amount'
        std::string *healthClubCost;
        /// Optional element 'ns2:valetParkingCost' of XSD type 'ns2:amount'
        std::string *valetParkingCost;
        /// Optional element 'ns2:cashDisbursementCost' of XSD type 'ns2:amount'
        std::string *cashDisbursementCost;
        /// Optional element 'ns2:nonRoomCost' of XSD type 'ns2:amount'
        std::string *nonRoomCost;
        /// Optional element 'ns2:businessCenterCost' of XSD type 'ns2:amount'
        std::string *businessCenterCost;
        /// Optional element 'ns2:loungeBarCost' of XSD type 'ns2:amount'
        std::string *loungeBarCost;
        /// Optional element 'ns2:transportationCost' of XSD type 'ns2:amount'
        std::string *transportationCost;
        /// Optional element 'ns2:gratuityCost' of XSD type 'ns2:amount'
        std::string *gratuityCost;
        /// Optional element 'ns2:conferenceRoomCost' of XSD type 'ns2:amount'
        std::string *conferenceRoomCost;
        /// Optional element 'ns2:audioVisualCost' of XSD type 'ns2:amount'
        std::string *audioVisualCost;
        /// Optional element 'ns2:banquetCost' of XSD type 'ns2:amount'
        std::string *banquetCost;
        /// Optional element 'ns2:internetAccessCost' of XSD type 'ns2:amount'
        std::string *internetAccessCost;
        /// Optional element 'ns2:earlyCheckOutCost' of XSD type 'ns2:amount'
        std::string *earlyCheckOutCost;
        /// Optional element 'ns2:nonRoomTax' of XSD type 'ns2:amount'
        std::string *nonRoomTax;
        /// Optional element 'ns2:travelAgencyCode' of XSD type 'xsd:string'
        std::string *travelAgencyCode;
        /// Optional element 'ns2:travelAgencyName' of XSD type 'xsd:string'
        std::string *travelAgencyName;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__LodgingData
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__LodgingData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__LodgingData, default initialized and not managed by a soap context
        virtual ns2__LodgingData *soap_alloc(void) const { return SOAP_NEW(ns2__LodgingData); }
      public:
        /// Constructor with initializations
        ns2__LodgingData()
        {
          checkInDate = (std::string *)0;
          checkOutDate = (std::string *)0;
          dailyRoomRate1 = (std::string *)0;
          dailyRoomRate2 = (std::string *)0;
          dailyRoomRate3 = (std::string *)0;
          roomNights1 = (std::string *)0;
          roomNights2 = (std::string *)0;
          roomNights3 = (std::string *)0;
          guestSmokingPreference = (std::string *)0;
          numberOfRoomsBooked = (std::string *)0;
          numberOfGuests = (std::string *)0;
          roomBedType = (std::string *)0;
          roomTaxElements = (std::string *)0;
          roomRateType = (std::string *)0;
          guestName = (std::string *)0;
          customerServicePhoneNumber = (std::string *)0;
          corporateClientCode = (std::string *)0;
          promotionalCode = (std::string *)0;
          additionalCoupon = (std::string *)0;
          roomLocation = (std::string *)0;
          specialProgramCode = (std::string *)0;
          tax = (std::string *)0;
          prepaidCost = (std::string *)0;
          foodAndBeverageCost = (std::string *)0;
          roomTax = (std::string *)0;
          adjustmentAmount = (std::string *)0;
          phoneCost = (std::string *)0;
          restaurantCost = (std::string *)0;
          roomServiceCost = (std::string *)0;
          miniBarCost = (std::string *)0;
          laundryCost = (std::string *)0;
          miscellaneousCost = (std::string *)0;
          giftShopCost = (std::string *)0;
          movieCost = (std::string *)0;
          healthClubCost = (std::string *)0;
          valetParkingCost = (std::string *)0;
          cashDisbursementCost = (std::string *)0;
          nonRoomCost = (std::string *)0;
          businessCenterCost = (std::string *)0;
          loungeBarCost = (std::string *)0;
          transportationCost = (std::string *)0;
          gratuityCost = (std::string *)0;
          conferenceRoomCost = (std::string *)0;
          audioVisualCost = (std::string *)0;
          banquetCost = (std::string *)0;
          internetAccessCost = (std::string *)0;
          earlyCheckOutCost = (std::string *)0;
          nonRoomTax = (std::string *)0;
          travelAgencyCode = (std::string *)0;
          travelAgencyName = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__LodgingData() { }
        /// Friend allocator used by soap_new_ns2__LodgingData(struct soap*, int)
        friend SOAP_FMAC1 ns2__LodgingData * SOAP_FMAC2 soap_instantiate_ns2__LodgingData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:804 */
#ifndef SOAP_TYPE_ns2__Pos
#define SOAP_TYPE_ns2__Pos (327)
/* complex XSD type 'ns2:Pos': */
class SOAP_CMAC ns2__Pos {
      public:
        /// Optional element 'ns2:entryMode' of XSD type 'xsd:string'
        std::string *entryMode;
        /// Optional element 'ns2:cardPresent' of XSD type 'xsd:string'
        std::string *cardPresent;
        /// Optional element 'ns2:terminalCapability' of XSD type 'xsd:string'
        std::string *terminalCapability;
        /// Optional element 'ns2:trackData' of XSD type 'xsd:string'
        std::string *trackData;
        /// Optional element 'ns2:terminalID' of XSD type 'xsd:string'
        std::string *terminalID;
        /// Optional element 'ns2:terminalType' of XSD type 'xsd:string'
        std::string *terminalType;
        /// Optional element 'ns2:terminalLocation' of XSD type 'xsd:string'
        std::string *terminalLocation;
        /// Optional element 'ns2:transactionSecurity' of XSD type 'xsd:string'
        std::string *transactionSecurity;
        /// Optional element 'ns2:catLevel' of XSD type 'xsd:string'
        std::string *catLevel;
        /// Optional element 'ns2:conditionCode' of XSD type 'xsd:string'
        std::string *conditionCode;
        /// Optional element 'ns2:environment' of XSD type 'xsd:string'
        std::string *environment;
        /// Optional element 'ns2:paymentData' of XSD type 'xsd:string'
        std::string *paymentData;
        /// Optional element 'ns2:deviceReaderData' of XSD type 'xsd:string'
        std::string *deviceReaderData;
        /// Optional element 'ns2:encryptionAlgorithm' of XSD type 'xsd:string'
        std::string *encryptionAlgorithm;
        /// Optional element 'ns2:encodingMethod' of XSD type 'xsd:string'
        std::string *encodingMethod;
        /// Optional element 'ns2:deviceID' of XSD type 'xsd:string'
        std::string *deviceID;
        /// Optional element 'ns2:serviceCode' of XSD type 'xsd:string'
        std::string *serviceCode;
        /// Optional element 'ns2:terminalIDAlternate' of XSD type 'xsd:string'
        std::string *terminalIDAlternate;
        /// Optional element 'ns2:terminalCompliance' of XSD type 'xsd:integer'
        std::string *terminalCompliance;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Pos
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__Pos; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Pos, default initialized and not managed by a soap context
        virtual ns2__Pos *soap_alloc(void) const { return SOAP_NEW(ns2__Pos); }
      public:
        /// Constructor with initializations
        ns2__Pos()
        {
          entryMode = (std::string *)0;
          cardPresent = (std::string *)0;
          terminalCapability = (std::string *)0;
          trackData = (std::string *)0;
          terminalID = (std::string *)0;
          terminalType = (std::string *)0;
          terminalLocation = (std::string *)0;
          transactionSecurity = (std::string *)0;
          catLevel = (std::string *)0;
          conditionCode = (std::string *)0;
          environment = (std::string *)0;
          paymentData = (std::string *)0;
          deviceReaderData = (std::string *)0;
          encryptionAlgorithm = (std::string *)0;
          encodingMethod = (std::string *)0;
          deviceID = (std::string *)0;
          serviceCode = (std::string *)0;
          terminalIDAlternate = (std::string *)0;
          terminalCompliance = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__Pos() { }
        /// Friend allocator used by soap_new_ns2__Pos(struct soap*, int)
        friend SOAP_FMAC1 ns2__Pos * SOAP_FMAC2 soap_instantiate_ns2__Pos(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:807 */
#ifndef SOAP_TYPE_ns2__EncryptedPayment
#define SOAP_TYPE_ns2__EncryptedPayment (328)
/* complex XSD type 'ns2:EncryptedPayment': */
class SOAP_CMAC ns2__EncryptedPayment {
      public:
        /// Optional element 'ns2:descriptor' of XSD type 'xsd:string'
        std::string *descriptor;
        /// Optional element 'ns2:data' of XSD type 'xsd:string'
        std::string *data;
        /// Optional element 'ns2:encoding' of XSD type 'xsd:string'
        std::string *encoding;
        /// Optional element 'ns2:wrappedKey' of XSD type 'xsd:string'
        std::string *wrappedKey;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__EncryptedPayment
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__EncryptedPayment; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__EncryptedPayment, default initialized and not managed by a soap context
        virtual ns2__EncryptedPayment *soap_alloc(void) const { return SOAP_NEW(ns2__EncryptedPayment); }
      public:
        /// Constructor with initializations
        ns2__EncryptedPayment()
        {
          descriptor = (std::string *)0;
          data = (std::string *)0;
          encoding = (std::string *)0;
          wrappedKey = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__EncryptedPayment() { }
        /// Friend allocator used by soap_new_ns2__EncryptedPayment(struct soap*, int)
        friend SOAP_FMAC1 ns2__EncryptedPayment * SOAP_FMAC2 soap_instantiate_ns2__EncryptedPayment(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:810 */
#ifndef SOAP_TYPE_ns2__Installment
#define SOAP_TYPE_ns2__Installment (329)
/* complex XSD type 'ns2:Installment': */
class SOAP_CMAC ns2__Installment {
      public:
        /// Optional element 'ns2:sequence' of XSD type 'xsd:string'
        std::string *sequence;
        /// Optional element 'ns2:totalCount' of XSD type 'xsd:string'
        std::string *totalCount;
        /// Optional element 'ns2:totalAmount' of XSD type 'xsd:string'
        std::string *totalAmount;
        /// Optional element 'ns2:frequency' of XSD type 'xsd:string'
        std::string *frequency;
        /// Optional element 'ns2:amount' of XSD type 'xsd:string'
        std::string *amount;
        /// Optional element 'ns2:planType' of XSD type 'xsd:string'
        std::string *planType;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__Installment
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__Installment; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__Installment, default initialized and not managed by a soap context
        virtual ns2__Installment *soap_alloc(void) const { return SOAP_NEW(ns2__Installment); }
      public:
        /// Constructor with initializations
        ns2__Installment()
        {
          sequence = (std::string *)0;
          totalCount = (std::string *)0;
          totalAmount = (std::string *)0;
          frequency = (std::string *)0;
          amount = (std::string *)0;
          planType = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__Installment() { }
        /// Friend allocator used by soap_new_ns2__Installment(struct soap*, int)
        friend SOAP_FMAC1 ns2__Installment * SOAP_FMAC2 soap_instantiate_ns2__Installment(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:816 */
#ifndef SOAP_TYPE_ns2__MerchantDefinedData
#define SOAP_TYPE_ns2__MerchantDefinedData (331)
/* complex XSD type 'ns2:MerchantDefinedData': */
class SOAP_CMAC ns2__MerchantDefinedData {
      public:
        /// Optional element 'ns2:field1' of XSD type 'xsd:string'
        std::string *field1;
        /// Optional element 'ns2:field2' of XSD type 'xsd:string'
        std::string *field2;
        /// Optional element 'ns2:field3' of XSD type 'xsd:string'
        std::string *field3;
        /// Optional element 'ns2:field4' of XSD type 'xsd:string'
        std::string *field4;
        /// Optional element 'ns2:field5' of XSD type 'xsd:string'
        std::string *field5;
        /// Optional element 'ns2:field6' of XSD type 'xsd:string'
        std::string *field6;
        /// Optional element 'ns2:field7' of XSD type 'xsd:string'
        std::string *field7;
        /// Optional element 'ns2:field8' of XSD type 'xsd:string'
        std::string *field8;
        /// Optional element 'ns2:field9' of XSD type 'xsd:string'
        std::string *field9;
        /// Optional element 'ns2:field10' of XSD type 'xsd:string'
        std::string *field10;
        /// Optional element 'ns2:field11' of XSD type 'xsd:string'
        std::string *field11;
        /// Optional element 'ns2:field12' of XSD type 'xsd:string'
        std::string *field12;
        /// Optional element 'ns2:field13' of XSD type 'xsd:string'
        std::string *field13;
        /// Optional element 'ns2:field14' of XSD type 'xsd:string'
        std::string *field14;
        /// Optional element 'ns2:field15' of XSD type 'xsd:string'
        std::string *field15;
        /// Optional element 'ns2:field16' of XSD type 'xsd:string'
        std::string *field16;
        /// Optional element 'ns2:field17' of XSD type 'xsd:string'
        std::string *field17;
        /// Optional element 'ns2:field18' of XSD type 'xsd:string'
        std::string *field18;
        /// Optional element 'ns2:field19' of XSD type 'xsd:string'
        std::string *field19;
        /// Optional element 'ns2:field20' of XSD type 'xsd:string'
        std::string *field20;
        /// Sequence of 0 to 100 elements 'ns2:mddField' of XSD type 'ns2:MDDField'
        std::vector<ns2__MDDField *> mddField;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__MerchantDefinedData
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__MerchantDefinedData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__MerchantDefinedData, default initialized and not managed by a soap context
        virtual ns2__MerchantDefinedData *soap_alloc(void) const { return SOAP_NEW(ns2__MerchantDefinedData); }
      public:
        /// Constructor with initializations
        ns2__MerchantDefinedData()
        {
          field1 = (std::string *)0;
          field2 = (std::string *)0;
          field3 = (std::string *)0;
          field4 = (std::string *)0;
          field5 = (std::string *)0;
          field6 = (std::string *)0;
          field7 = (std::string *)0;
          field8 = (std::string *)0;
          field9 = (std::string *)0;
          field10 = (std::string *)0;
          field11 = (std::string *)0;
          field12 = (std::string *)0;
          field13 = (std::string *)0;
          field14 = (std::string *)0;
          field15 = (std::string *)0;
          field16 = (std::string *)0;
          field17 = (std::string *)0;
          field18 = (std::string *)0;
          field19 = (std::string *)0;
          field20 = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__MerchantDefinedData() { }
        /// Friend allocator used by soap_new_ns2__MerchantDefinedData(struct soap*, int)
        friend SOAP_FMAC1 ns2__MerchantDefinedData * SOAP_FMAC2 soap_instantiate_ns2__MerchantDefinedData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:819 */
#ifndef SOAP_TYPE_ns2__MerchantSecureData
#define SOAP_TYPE_ns2__MerchantSecureData (332)
/* complex XSD type 'ns2:MerchantSecureData': */
class SOAP_CMAC ns2__MerchantSecureData {
      public:
        /// Optional element 'ns2:field1' of XSD type 'xsd:string'
        std::string *field1;
        /// Optional element 'ns2:field2' of XSD type 'xsd:string'
        std::string *field2;
        /// Optional element 'ns2:field3' of XSD type 'xsd:string'
        std::string *field3;
        /// Optional element 'ns2:field4' of XSD type 'xsd:string'
        std::string *field4;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__MerchantSecureData
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__MerchantSecureData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__MerchantSecureData, default initialized and not managed by a soap context
        virtual ns2__MerchantSecureData *soap_alloc(void) const { return SOAP_NEW(ns2__MerchantSecureData); }
      public:
        /// Constructor with initializations
        ns2__MerchantSecureData()
        {
          field1 = (std::string *)0;
          field2 = (std::string *)0;
          field3 = (std::string *)0;
          field4 = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__MerchantSecureData() { }
        /// Friend allocator used by soap_new_ns2__MerchantSecureData(struct soap*, int)
        friend SOAP_FMAC1 ns2__MerchantSecureData * SOAP_FMAC2 soap_instantiate_ns2__MerchantSecureData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:822 */
#ifndef SOAP_TYPE_ns2__ReplyReserved
#define SOAP_TYPE_ns2__ReplyReserved (333)
/* complex XSD type 'ns2:ReplyReserved': */
class SOAP_CMAC ns2__ReplyReserved {
      public:
        std::vector<char *> __any;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ReplyReserved
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ReplyReserved; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ReplyReserved, default initialized and not managed by a soap context
        virtual ns2__ReplyReserved *soap_alloc(void) const { return SOAP_NEW(ns2__ReplyReserved); }
      public:
        /// Constructor with initializations
        ns2__ReplyReserved()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__ReplyReserved() { }
        /// Friend allocator used by soap_new_ns2__ReplyReserved(struct soap*, int)
        friend SOAP_FMAC1 ns2__ReplyReserved * SOAP_FMAC2 soap_instantiate_ns2__ReplyReserved(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:825 */
#ifndef SOAP_TYPE_ns2__RequestReserved
#define SOAP_TYPE_ns2__RequestReserved (334)
/* complex XSD type 'ns2:RequestReserved': */
class SOAP_CMAC ns2__RequestReserved {
      public:
        /// Required element 'ns2:name' of XSD type 'xsd:string'
        std::string name;
        /// Required element 'ns2:value' of XSD type 'xsd:string'
        std::string value;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__RequestReserved
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__RequestReserved; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__RequestReserved, default initialized and not managed by a soap context
        virtual ns2__RequestReserved *soap_alloc(void) const { return SOAP_NEW(ns2__RequestReserved); }
      public:
        /// Constructor with initializations
        ns2__RequestReserved()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__RequestReserved() { }
        /// Friend allocator used by soap_new_ns2__RequestReserved(struct soap*, int)
        friend SOAP_FMAC1 ns2__RequestReserved * SOAP_FMAC2 soap_instantiate_ns2__RequestReserved(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:828 */
#ifndef SOAP_TYPE_ns2__PayPalGetTxnDetailsReply
#define SOAP_TYPE_ns2__PayPalGetTxnDetailsReply (335)
/* complex XSD type 'ns2:PayPalGetTxnDetailsReply': */
class SOAP_CMAC ns2__PayPalGetTxnDetailsReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:payer' of XSD type 'xsd:string'
        std::string *payer;
        /// Optional element 'ns2:payerId' of XSD type 'xsd:string'
        std::string *payerId;
        /// Optional element 'ns2:payerStatus' of XSD type 'xsd:string'
        std::string *payerStatus;
        /// Optional element 'ns2:payerCountry' of XSD type 'xsd:string'
        std::string *payerCountry;
        /// Optional element 'ns2:payerBusiness' of XSD type 'xsd:string'
        std::string *payerBusiness;
        /// Optional element 'ns2:payerSalutation' of XSD type 'xsd:string'
        std::string *payerSalutation;
        /// Optional element 'ns2:payerFirstname' of XSD type 'xsd:string'
        std::string *payerFirstname;
        /// Optional element 'ns2:payerMiddlename' of XSD type 'xsd:string'
        std::string *payerMiddlename;
        /// Optional element 'ns2:payerLastname' of XSD type 'xsd:string'
        std::string *payerLastname;
        /// Optional element 'ns2:payerSuffix' of XSD type 'xsd:string'
        std::string *payerSuffix;
        /// Optional element 'ns2:addressID' of XSD type 'xsd:string'
        std::string *addressID;
        /// Optional element 'ns2:addressStatus' of XSD type 'xsd:string'
        std::string *addressStatus;
        /// Optional element 'ns2:shipToName' of XSD type 'xsd:string'
        std::string *shipToName;
        /// Optional element 'ns2:shipToAddress1' of XSD type 'xsd:string'
        std::string *shipToAddress1;
        /// Optional element 'ns2:shipToAddress2' of XSD type 'xsd:string'
        std::string *shipToAddress2;
        /// Optional element 'ns2:shipToCity' of XSD type 'xsd:string'
        std::string *shipToCity;
        /// Optional element 'ns2:shipToState' of XSD type 'xsd:string'
        std::string *shipToState;
        /// Optional element 'ns2:shipToCountry' of XSD type 'xsd:string'
        std::string *shipToCountry;
        /// Optional element 'ns2:shipToZip' of XSD type 'xsd:string'
        std::string *shipToZip;
        /// Optional element 'ns2:payerPhone' of XSD type 'xsd:string'
        std::string *payerPhone;
        /// Optional element 'ns2:transactionId' of XSD type 'xsd:string'
        std::string *transactionId;
        /// Optional element 'ns2:parentTransactionId' of XSD type 'xsd:string'
        std::string *parentTransactionId;
        /// Optional element 'ns2:paypalReceiptId' of XSD type 'xsd:string'
        std::string *paypalReceiptId;
        /// Optional element 'ns2:paypalTransactiontype' of XSD type 'xsd:string'
        std::string *paypalTransactiontype;
        /// Optional element 'ns2:paypalPaymentType' of XSD type 'xsd:string'
        std::string *paypalPaymentType;
        /// Optional element 'ns2:paypalOrderTime' of XSD type 'xsd:string'
        std::string *paypalOrderTime;
        /// Optional element 'ns2:paypalPaymentGrossAmount' of XSD type 'xsd:string'
        std::string *paypalPaymentGrossAmount;
        /// Optional element 'ns2:paypalFeeAmount' of XSD type 'xsd:string'
        std::string *paypalFeeAmount;
        /// Optional element 'ns2:currency' of XSD type 'xsd:string'
        std::string *currency;
        /// Optional element 'ns2:paypalSettleAmount' of XSD type 'xsd:string'
        std::string *paypalSettleAmount;
        /// Optional element 'ns2:paypalTaxAmount' of XSD type 'xsd:string'
        std::string *paypalTaxAmount;
        /// Optional element 'ns2:paypalExchangeRate' of XSD type 'xsd:string'
        std::string *paypalExchangeRate;
        /// Optional element 'ns2:paypalPaymentStatus' of XSD type 'xsd:string'
        std::string *paypalPaymentStatus;
        /// Optional element 'ns2:paypalPendingReason' of XSD type 'xsd:string'
        std::string *paypalPendingReason;
        /// Optional element 'ns2:paypalReasonCode' of XSD type 'xsd:string'
        std::string *paypalReasonCode;
        /// Optional element 'ns2:protectionEligibility' of XSD type 'xsd:string'
        std::string *protectionEligibility;
        /// Optional element 'ns2:protectionEligibilityType' of XSD type 'xsd:string'
        std::string *protectionEligibilityType;
        /// Optional element 'ns2:paypalNote' of XSD type 'xsd:string'
        std::string *paypalNote;
        /// Optional element 'ns2:invoiceNumber' of XSD type 'xsd:string'
        std::string *invoiceNumber;
        /// Sequence of 0 to 1000 elements 'ns2:item' of XSD type 'ns2:Item'
        std::vector<ns2__Item *> item;
        /// Optional element 'ns2:errorCode' of XSD type 'xsd:string'
        std::string *errorCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalGetTxnDetailsReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PayPalGetTxnDetailsReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalGetTxnDetailsReply, default initialized and not managed by a soap context
        virtual ns2__PayPalGetTxnDetailsReply *soap_alloc(void) const { return SOAP_NEW(ns2__PayPalGetTxnDetailsReply); }
      public:
        /// Constructor with initializations
        ns2__PayPalGetTxnDetailsReply()
        {
          payer = (std::string *)0;
          payerId = (std::string *)0;
          payerStatus = (std::string *)0;
          payerCountry = (std::string *)0;
          payerBusiness = (std::string *)0;
          payerSalutation = (std::string *)0;
          payerFirstname = (std::string *)0;
          payerMiddlename = (std::string *)0;
          payerLastname = (std::string *)0;
          payerSuffix = (std::string *)0;
          addressID = (std::string *)0;
          addressStatus = (std::string *)0;
          shipToName = (std::string *)0;
          shipToAddress1 = (std::string *)0;
          shipToAddress2 = (std::string *)0;
          shipToCity = (std::string *)0;
          shipToState = (std::string *)0;
          shipToCountry = (std::string *)0;
          shipToZip = (std::string *)0;
          payerPhone = (std::string *)0;
          transactionId = (std::string *)0;
          parentTransactionId = (std::string *)0;
          paypalReceiptId = (std::string *)0;
          paypalTransactiontype = (std::string *)0;
          paypalPaymentType = (std::string *)0;
          paypalOrderTime = (std::string *)0;
          paypalPaymentGrossAmount = (std::string *)0;
          paypalFeeAmount = (std::string *)0;
          currency = (std::string *)0;
          paypalSettleAmount = (std::string *)0;
          paypalTaxAmount = (std::string *)0;
          paypalExchangeRate = (std::string *)0;
          paypalPaymentStatus = (std::string *)0;
          paypalPendingReason = (std::string *)0;
          paypalReasonCode = (std::string *)0;
          protectionEligibility = (std::string *)0;
          protectionEligibilityType = (std::string *)0;
          paypalNote = (std::string *)0;
          invoiceNumber = (std::string *)0;
          errorCode = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PayPalGetTxnDetailsReply() { }
        /// Friend allocator used by soap_new_ns2__PayPalGetTxnDetailsReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalGetTxnDetailsReply * SOAP_FMAC2 soap_instantiate_ns2__PayPalGetTxnDetailsReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:831 */
#ifndef SOAP_TYPE_ns2__PayPalTransactionSearchReply
#define SOAP_TYPE_ns2__PayPalTransactionSearchReply (336)
/* complex XSD type 'ns2:PayPalTransactionSearchReply': */
class SOAP_CMAC ns2__PayPalTransactionSearchReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Sequence of 0 to 999 elements 'ns2:transaction' of XSD type 'ns2:PaypalTransaction'
        std::vector<ns2__PaypalTransaction *> transaction;
        /// Optional element 'ns2:errorCode' of XSD type 'xsd:string'
        std::string *errorCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PayPalTransactionSearchReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PayPalTransactionSearchReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PayPalTransactionSearchReply, default initialized and not managed by a soap context
        virtual ns2__PayPalTransactionSearchReply *soap_alloc(void) const { return SOAP_NEW(ns2__PayPalTransactionSearchReply); }
      public:
        /// Constructor with initializations
        ns2__PayPalTransactionSearchReply()
        {
          errorCode = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PayPalTransactionSearchReply() { }
        /// Friend allocator used by soap_new_ns2__PayPalTransactionSearchReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__PayPalTransactionSearchReply * SOAP_FMAC2 soap_instantiate_ns2__PayPalTransactionSearchReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:834 */
#ifndef SOAP_TYPE_ns2__PaypalTransaction
#define SOAP_TYPE_ns2__PaypalTransaction (337)
/* complex XSD type 'ns2:PaypalTransaction': */
class SOAP_CMAC ns2__PaypalTransaction {
      public:
        /// Optional element 'ns2:transactionTime' of XSD type 'ns2:dateTime'
        std::string *transactionTime;
        /// Optional element 'ns2:transactionTimeZone' of XSD type 'xsd:string'
        std::string *transactionTimeZone;
        /// Optional element 'ns2:transactionType' of XSD type 'xsd:string'
        std::string *transactionType;
        /// Optional element 'ns2:paypalPayerOrPayeeEmail' of XSD type 'xsd:string'
        std::string *paypalPayerOrPayeeEmail;
        /// Optional element 'ns2:customerDisplayName' of XSD type 'xsd:string'
        std::string *customerDisplayName;
        /// Optional element 'ns2:transactionID' of XSD type 'xsd:string'
        std::string *transactionID;
        /// Optional element 'ns2:paypalPaymentStatus' of XSD type 'xsd:string'
        std::string *paypalPaymentStatus;
        /// Optional element 'ns2:grandTotalAmount' of XSD type 'xsd:string'
        std::string *grandTotalAmount;
        /// Optional element 'ns2:currency' of XSD type 'xsd:string'
        std::string *currency;
        /// Optional element 'ns2:paypalFeeAmount' of XSD type 'xsd:string'
        std::string *paypalFeeAmount;
        /// Optional element 'ns2:paypalNetAmount' of XSD type 'xsd:string'
        std::string *paypalNetAmount;
        /// optional attribute 'id' of XSD type 'xsd:integer'
        std::string *id;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__PaypalTransaction
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__PaypalTransaction; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__PaypalTransaction, default initialized and not managed by a soap context
        virtual ns2__PaypalTransaction *soap_alloc(void) const { return SOAP_NEW(ns2__PaypalTransaction); }
      public:
        /// Constructor with initializations
        ns2__PaypalTransaction()
        {
          transactionTime = (std::string *)0;
          transactionTimeZone = (std::string *)0;
          transactionType = (std::string *)0;
          paypalPayerOrPayeeEmail = (std::string *)0;
          customerDisplayName = (std::string *)0;
          transactionID = (std::string *)0;
          paypalPaymentStatus = (std::string *)0;
          grandTotalAmount = (std::string *)0;
          currency = (std::string *)0;
          paypalFeeAmount = (std::string *)0;
          paypalNetAmount = (std::string *)0;
          id = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__PaypalTransaction() { }
        /// Friend allocator used by soap_new_ns2__PaypalTransaction(struct soap*, int)
        friend SOAP_FMAC1 ns2__PaypalTransaction * SOAP_FMAC2 soap_instantiate_ns2__PaypalTransaction(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:837 */
#ifndef SOAP_TYPE_ns2__CCDCCUpdateService
#define SOAP_TYPE_ns2__CCDCCUpdateService (338)
/* complex XSD type 'ns2:CCDCCUpdateService': */
class SOAP_CMAC ns2__CCDCCUpdateService {
      public:
        /// Optional element 'ns2:reason' of XSD type 'xsd:string'
        std::string *reason;
        /// Optional element 'ns2:action' of XSD type 'xsd:string'
        std::string *action;
        /// Optional element 'ns2:dccRequestID' of XSD type 'xsd:string'
        std::string *dccRequestID;
        /// Optional element 'ns2:captureRequestID' of XSD type 'xsd:string'
        std::string *captureRequestID;
        /// Optional element 'ns2:creditRequestID' of XSD type 'xsd:string'
        std::string *creditRequestID;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__CCDCCUpdateService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__CCDCCUpdateService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__CCDCCUpdateService, default initialized and not managed by a soap context
        virtual ns2__CCDCCUpdateService *soap_alloc(void) const { return SOAP_NEW(ns2__CCDCCUpdateService); }
      public:
        /// Constructor with initializations
        ns2__CCDCCUpdateService()
        {
          reason = (std::string *)0;
          action = (std::string *)0;
          dccRequestID = (std::string *)0;
          captureRequestID = (std::string *)0;
          creditRequestID = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__CCDCCUpdateService() { }
        /// Friend allocator used by soap_new_ns2__CCDCCUpdateService(struct soap*, int)
        friend SOAP_FMAC1 ns2__CCDCCUpdateService * SOAP_FMAC2 soap_instantiate_ns2__CCDCCUpdateService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:840 */
#ifndef SOAP_TYPE_ns2__ServiceFee
#define SOAP_TYPE_ns2__ServiceFee (339)
/* complex XSD type 'ns2:ServiceFee': */
class SOAP_CMAC ns2__ServiceFee {
      public:
        /// Optional element 'ns2:merchantDescriptor' of XSD type 'xsd:string'
        std::string *merchantDescriptor;
        /// Optional element 'ns2:merchantDescriptorContact' of XSD type 'xsd:string'
        std::string *merchantDescriptorContact;
        /// Optional element 'ns2:merchantDescriptorState' of XSD type 'xsd:string'
        std::string *merchantDescriptorState;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__ServiceFee
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__ServiceFee; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__ServiceFee, default initialized and not managed by a soap context
        virtual ns2__ServiceFee *soap_alloc(void) const { return SOAP_NEW(ns2__ServiceFee); }
      public:
        /// Constructor with initializations
        ns2__ServiceFee()
        {
          merchantDescriptor = (std::string *)0;
          merchantDescriptorContact = (std::string *)0;
          merchantDescriptorState = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__ServiceFee() { }
        /// Friend allocator used by soap_new_ns2__ServiceFee(struct soap*, int)
        friend SOAP_FMAC1 ns2__ServiceFee * SOAP_FMAC2 soap_instantiate_ns2__ServiceFee(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:843 */
#ifndef SOAP_TYPE_ns2__EmvRequest
#define SOAP_TYPE_ns2__EmvRequest (340)
/* complex XSD type 'ns2:EmvRequest': */
class SOAP_CMAC ns2__EmvRequest {
      public:
        /// Optional element 'ns2:combinedTags' of XSD type 'xsd:string'
        std::string *combinedTags;
        /// Optional element 'ns2:cardSequenceNumber' of XSD type 'xsd:string'
        std::string *cardSequenceNumber;
        /// Optional element 'ns2:aidAndDFname' of XSD type 'xsd:string'
        std::string *aidAndDFname;
        /// Optional element 'ns2:fallback' of XSD type 'xsd:string'
        std::string *fallback;
        /// Optional element 'ns2:fallbackCondition' of XSD type 'xsd:string'
        std::string *fallbackCondition;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__EmvRequest
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__EmvRequest; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__EmvRequest, default initialized and not managed by a soap context
        virtual ns2__EmvRequest *soap_alloc(void) const { return SOAP_NEW(ns2__EmvRequest); }
      public:
        /// Constructor with initializations
        ns2__EmvRequest()
        {
          combinedTags = (std::string *)0;
          cardSequenceNumber = (std::string *)0;
          aidAndDFname = (std::string *)0;
          fallback = (std::string *)0;
          fallbackCondition = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__EmvRequest() { }
        /// Friend allocator used by soap_new_ns2__EmvRequest(struct soap*, int)
        friend SOAP_FMAC1 ns2__EmvRequest * SOAP_FMAC2 soap_instantiate_ns2__EmvRequest(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:846 */
#ifndef SOAP_TYPE_ns2__EmvReply
#define SOAP_TYPE_ns2__EmvReply (341)
/* complex XSD type 'ns2:EmvReply': */
class SOAP_CMAC ns2__EmvReply {
      public:
        /// Optional element 'ns2:combinedTags' of XSD type 'xsd:string'
        std::string *combinedTags;
        /// Optional element 'ns2:decryptedRequestTags' of XSD type 'xsd:string'
        std::string *decryptedRequestTags;
        /// Optional element 'ns2:chipValidationResults' of XSD type 'xsd:string'
        std::string *chipValidationResults;
        /// Optional element 'ns2:chipValidationType' of XSD type 'xsd:string'
        std::string *chipValidationType;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__EmvReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__EmvReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__EmvReply, default initialized and not managed by a soap context
        virtual ns2__EmvReply *soap_alloc(void) const { return SOAP_NEW(ns2__EmvReply); }
      public:
        /// Constructor with initializations
        ns2__EmvReply()
        {
          combinedTags = (std::string *)0;
          decryptedRequestTags = (std::string *)0;
          chipValidationResults = (std::string *)0;
          chipValidationType = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__EmvReply() { }
        /// Friend allocator used by soap_new_ns2__EmvReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__EmvReply * SOAP_FMAC2 soap_instantiate_ns2__EmvReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:849 */
#ifndef SOAP_TYPE_ns2__OriginalTransaction
#define SOAP_TYPE_ns2__OriginalTransaction (342)
/* complex XSD type 'ns2:OriginalTransaction': */
class SOAP_CMAC ns2__OriginalTransaction {
      public:
        /// Optional element 'ns2:amount' of XSD type 'ns2:amount'
        std::string *amount;
        /// Optional element 'ns2:reasonCode' of XSD type 'xsd:string'
        std::string *reasonCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__OriginalTransaction
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__OriginalTransaction; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__OriginalTransaction, default initialized and not managed by a soap context
        virtual ns2__OriginalTransaction *soap_alloc(void) const { return SOAP_NEW(ns2__OriginalTransaction); }
      public:
        /// Constructor with initializations
        ns2__OriginalTransaction()
        {
          amount = (std::string *)0;
          reasonCode = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__OriginalTransaction() { }
        /// Friend allocator used by soap_new_ns2__OriginalTransaction(struct soap*, int)
        friend SOAP_FMAC1 ns2__OriginalTransaction * SOAP_FMAC2 soap_instantiate_ns2__OriginalTransaction(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:852 */
#ifndef SOAP_TYPE_ns2__HostedDataCreateService
#define SOAP_TYPE_ns2__HostedDataCreateService (343)
/* complex XSD type 'ns2:HostedDataCreateService': */
class SOAP_CMAC ns2__HostedDataCreateService {
      public:
        /// Optional element 'ns2:profileID' of XSD type 'xsd:string'
        std::string *profileID;
        /// Optional element 'ns2:paymentMethod' of XSD type 'xsd:string'
        std::string *paymentMethod;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__HostedDataCreateService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__HostedDataCreateService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__HostedDataCreateService, default initialized and not managed by a soap context
        virtual ns2__HostedDataCreateService *soap_alloc(void) const { return SOAP_NEW(ns2__HostedDataCreateService); }
      public:
        /// Constructor with initializations
        ns2__HostedDataCreateService()
        {
          profileID = (std::string *)0;
          paymentMethod = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__HostedDataCreateService() { }
        /// Friend allocator used by soap_new_ns2__HostedDataCreateService(struct soap*, int)
        friend SOAP_FMAC1 ns2__HostedDataCreateService * SOAP_FMAC2 soap_instantiate_ns2__HostedDataCreateService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:855 */
#ifndef SOAP_TYPE_ns2__HostedDataRetrieveService
#define SOAP_TYPE_ns2__HostedDataRetrieveService (344)
/* complex XSD type 'ns2:HostedDataRetrieveService': */
class SOAP_CMAC ns2__HostedDataRetrieveService {
      public:
        /// Optional element 'ns2:profileID' of XSD type 'xsd:string'
        std::string *profileID;
        /// Optional element 'ns2:tokenValue' of XSD type 'xsd:string'
        std::string *tokenValue;
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__HostedDataRetrieveService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__HostedDataRetrieveService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__HostedDataRetrieveService, default initialized and not managed by a soap context
        virtual ns2__HostedDataRetrieveService *soap_alloc(void) const { return SOAP_NEW(ns2__HostedDataRetrieveService); }
      public:
        /// Constructor with initializations
        ns2__HostedDataRetrieveService()
        {
          profileID = (std::string *)0;
          tokenValue = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__HostedDataRetrieveService() { }
        /// Friend allocator used by soap_new_ns2__HostedDataRetrieveService(struct soap*, int)
        friend SOAP_FMAC1 ns2__HostedDataRetrieveService * SOAP_FMAC2 soap_instantiate_ns2__HostedDataRetrieveService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:858 */
#ifndef SOAP_TYPE_ns2__HostedDataCreateReply
#define SOAP_TYPE_ns2__HostedDataCreateReply (345)
/* complex XSD type 'ns2:HostedDataCreateReply': */
class SOAP_CMAC ns2__HostedDataCreateReply {
      public:
        /// Optional element 'ns2:responseMessage' of XSD type 'xsd:string'
        std::string *responseMessage;
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:cardAccountNumberToken' of XSD type 'xsd:string'
        std::string *cardAccountNumberToken;
        /// Optional element 'ns2:customerID' of XSD type 'xsd:string'
        std::string *customerID;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__HostedDataCreateReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__HostedDataCreateReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__HostedDataCreateReply, default initialized and not managed by a soap context
        virtual ns2__HostedDataCreateReply *soap_alloc(void) const { return SOAP_NEW(ns2__HostedDataCreateReply); }
      public:
        /// Constructor with initializations
        ns2__HostedDataCreateReply()
        {
          responseMessage = (std::string *)0;
          cardAccountNumberToken = (std::string *)0;
          customerID = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__HostedDataCreateReply() { }
        /// Friend allocator used by soap_new_ns2__HostedDataCreateReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__HostedDataCreateReply * SOAP_FMAC2 soap_instantiate_ns2__HostedDataCreateReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:861 */
#ifndef SOAP_TYPE_ns2__HostedDataRetrieveReply
#define SOAP_TYPE_ns2__HostedDataRetrieveReply (346)
/* complex XSD type 'ns2:HostedDataRetrieveReply': */
class SOAP_CMAC ns2__HostedDataRetrieveReply {
      public:
        /// Optional element 'ns2:responseMessage' of XSD type 'xsd:string'
        std::string *responseMessage;
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:aggregatorMerchantIdentifier' of XSD type 'xsd:string'
        std::string *aggregatorMerchantIdentifier;
        /// Optional element 'ns2:customerFirstName' of XSD type 'xsd:string'
        std::string *customerFirstName;
        /// Optional element 'ns2:customerLastName' of XSD type 'xsd:string'
        std::string *customerLastName;
        /// Optional element 'ns2:customerID' of XSD type 'xsd:string'
        std::string *customerID;
        /// Optional element 'ns2:paymentMethod' of XSD type 'xsd:string'
        std::string *paymentMethod;
        /// Optional element 'ns2:billToStreet1' of XSD type 'xsd:string'
        std::string *billToStreet1;
        /// Optional element 'ns2:billToStreet2' of XSD type 'xsd:string'
        std::string *billToStreet2;
        /// Optional element 'ns2:billToEmail' of XSD type 'xsd:string'
        std::string *billToEmail;
        /// Optional element 'ns2:billToState' of XSD type 'xsd:string'
        std::string *billToState;
        /// Optional element 'ns2:billToFirstName' of XSD type 'xsd:string'
        std::string *billToFirstName;
        /// Optional element 'ns2:billToLastName' of XSD type 'xsd:string'
        std::string *billToLastName;
        /// Optional element 'ns2:billToCity' of XSD type 'xsd:string'
        std::string *billToCity;
        /// Optional element 'ns2:billToCountry' of XSD type 'xsd:string'
        std::string *billToCountry;
        /// Optional element 'ns2:billToPostalCode' of XSD type 'xsd:string'
        std::string *billToPostalCode;
        /// Optional element 'ns2:cardAccountNumber' of XSD type 'xsd:string'
        std::string *cardAccountNumber;
        /// Optional element 'ns2:cardType' of XSD type 'xsd:string'
        std::string *cardType;
        /// Optional element 'ns2:cardExpirationMonth' of XSD type 'xsd:string'
        std::string *cardExpirationMonth;
        /// Optional element 'ns2:cardExpirationYear' of XSD type 'xsd:string'
        std::string *cardExpirationYear;
        /// Optional element 'ns2:cardIssueNumber' of XSD type 'xsd:string'
        std::string *cardIssueNumber;
        /// Optional element 'ns2:cardStartMonth' of XSD type 'xsd:string'
        std::string *cardStartMonth;
        /// Optional element 'ns2:cardStartYear' of XSD type 'xsd:string'
        std::string *cardStartYear;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__HostedDataRetrieveReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__HostedDataRetrieveReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__HostedDataRetrieveReply, default initialized and not managed by a soap context
        virtual ns2__HostedDataRetrieveReply *soap_alloc(void) const { return SOAP_NEW(ns2__HostedDataRetrieveReply); }
      public:
        /// Constructor with initializations
        ns2__HostedDataRetrieveReply()
        {
          responseMessage = (std::string *)0;
          aggregatorMerchantIdentifier = (std::string *)0;
          customerFirstName = (std::string *)0;
          customerLastName = (std::string *)0;
          customerID = (std::string *)0;
          paymentMethod = (std::string *)0;
          billToStreet1 = (std::string *)0;
          billToStreet2 = (std::string *)0;
          billToEmail = (std::string *)0;
          billToState = (std::string *)0;
          billToFirstName = (std::string *)0;
          billToLastName = (std::string *)0;
          billToCity = (std::string *)0;
          billToCountry = (std::string *)0;
          billToPostalCode = (std::string *)0;
          cardAccountNumber = (std::string *)0;
          cardType = (std::string *)0;
          cardExpirationMonth = (std::string *)0;
          cardExpirationYear = (std::string *)0;
          cardIssueNumber = (std::string *)0;
          cardStartMonth = (std::string *)0;
          cardStartYear = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__HostedDataRetrieveReply() { }
        /// Friend allocator used by soap_new_ns2__HostedDataRetrieveReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__HostedDataRetrieveReply * SOAP_FMAC2 soap_instantiate_ns2__HostedDataRetrieveReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:864 */
#ifndef SOAP_TYPE_ns2__AutoRentalData
#define SOAP_TYPE_ns2__AutoRentalData (347)
/* complex XSD type 'ns2:AutoRentalData': */
class SOAP_CMAC ns2__AutoRentalData {
      public:
        /// Optional element 'ns2:adjustmentCost' of XSD type 'ns2:amount'
        std::string *adjustmentCost;
        /// Optional element 'ns2:adjustmentCode' of XSD type 'xsd:string'
        std::string *adjustmentCode;
        /// Optional element 'ns2:agreementNumber' of XSD type 'xsd:string'
        std::string *agreementNumber;
        /// Optional element 'ns2:classCode' of XSD type 'xsd:string'
        std::string *classCode;
        /// Optional element 'ns2:customerServicePhoneNumber' of XSD type 'xsd:string'
        std::string *customerServicePhoneNumber;
        /// Optional element 'ns2:dailyRate' of XSD type 'ns2:amount'
        std::string *dailyRate;
        /// Optional element 'ns2:mileageCost' of XSD type 'ns2:amount'
        std::string *mileageCost;
        /// Optional element 'ns2:gasCost' of XSD type 'ns2:amount'
        std::string *gasCost;
        /// Optional element 'ns2:insuranceCost' of XSD type 'ns2:amount'
        std::string *insuranceCost;
        /// Optional element 'ns2:lateReturnCost' of XSD type 'ns2:amount'
        std::string *lateReturnCost;
        /// Optional element 'ns2:maximumFreeMiles' of XSD type 'xsd:integer'
        std::string *maximumFreeMiles;
        /// Optional element 'ns2:milesTraveled' of XSD type 'xsd:integer'
        std::string *milesTraveled;
        /// Optional element 'ns2:oneWayCost' of XSD type 'ns2:amount'
        std::string *oneWayCost;
        /// Optional element 'ns2:parkingViolationCost' of XSD type 'ns2:amount'
        std::string *parkingViolationCost;
        /// Optional element 'ns2:pickUpCity' of XSD type 'xsd:string'
        std::string *pickUpCity;
        /// Optional element 'ns2:pickUpCountry' of XSD type 'xsd:string'
        std::string *pickUpCountry;
        /// Optional element 'ns2:pickUpDate' of XSD type 'xsd:string'
        std::string *pickUpDate;
        /// Optional element 'ns2:pickUpState' of XSD type 'xsd:string'
        std::string *pickUpState;
        /// Optional element 'ns2:pickUpTime' of XSD type 'xsd:integer'
        std::string *pickUpTime;
        /// Optional element 'ns2:ratePerMile' of XSD type 'ns2:amount'
        std::string *ratePerMile;
        /// Optional element 'ns2:renterName' of XSD type 'xsd:string'
        std::string *renterName;
        /// Optional element 'ns2:returnCity' of XSD type 'xsd:string'
        std::string *returnCity;
        /// Optional element 'ns2:returnCountry' of XSD type 'xsd:string'
        std::string *returnCountry;
        /// Optional element 'ns2:returnDate' of XSD type 'xsd:string'
        std::string *returnDate;
        /// Optional element 'ns2:returnLocationID' of XSD type 'xsd:string'
        std::string *returnLocationID;
        /// Optional element 'ns2:returnState' of XSD type 'xsd:string'
        std::string *returnState;
        /// Optional element 'ns2:returnTime' of XSD type 'xsd:integer'
        std::string *returnTime;
        /// Optional element 'ns2:specialProgramCode' of XSD type 'xsd:string'
        std::string *specialProgramCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__AutoRentalData
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__AutoRentalData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__AutoRentalData, default initialized and not managed by a soap context
        virtual ns2__AutoRentalData *soap_alloc(void) const { return SOAP_NEW(ns2__AutoRentalData); }
      public:
        /// Constructor with initializations
        ns2__AutoRentalData()
        {
          adjustmentCost = (std::string *)0;
          adjustmentCode = (std::string *)0;
          agreementNumber = (std::string *)0;
          classCode = (std::string *)0;
          customerServicePhoneNumber = (std::string *)0;
          dailyRate = (std::string *)0;
          mileageCost = (std::string *)0;
          gasCost = (std::string *)0;
          insuranceCost = (std::string *)0;
          lateReturnCost = (std::string *)0;
          maximumFreeMiles = (std::string *)0;
          milesTraveled = (std::string *)0;
          oneWayCost = (std::string *)0;
          parkingViolationCost = (std::string *)0;
          pickUpCity = (std::string *)0;
          pickUpCountry = (std::string *)0;
          pickUpDate = (std::string *)0;
          pickUpState = (std::string *)0;
          pickUpTime = (std::string *)0;
          ratePerMile = (std::string *)0;
          renterName = (std::string *)0;
          returnCity = (std::string *)0;
          returnCountry = (std::string *)0;
          returnDate = (std::string *)0;
          returnLocationID = (std::string *)0;
          returnState = (std::string *)0;
          returnTime = (std::string *)0;
          specialProgramCode = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__AutoRentalData() { }
        /// Friend allocator used by soap_new_ns2__AutoRentalData(struct soap*, int)
        friend SOAP_FMAC1 ns2__AutoRentalData * SOAP_FMAC2 soap_instantiate_ns2__AutoRentalData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:867 */
#ifndef SOAP_TYPE_ns2__VCReply
#define SOAP_TYPE_ns2__VCReply (348)
/* complex XSD type 'ns2:VCReply': */
class SOAP_CMAC ns2__VCReply {
      public:
        /// Optional element 'ns2:creationTimeStamp' of XSD type 'xsd:string'
        std::string *creationTimeStamp;
        /// Optional element 'ns2:alternateShippingAddressCountryCode' of XSD type 'xsd:string'
        std::string *alternateShippingAddressCountryCode;
        /// Optional element 'ns2:alternateShippingAddressPostalCode' of XSD type 'xsd:string'
        std::string *alternateShippingAddressPostalCode;
        /// Optional element 'ns2:vcAccountLoginName' of XSD type 'xsd:string'
        std::string *vcAccountLoginName;
        /// Optional element 'ns2:vcAccountFirstName' of XSD type 'xsd:string'
        std::string *vcAccountFirstName;
        /// Optional element 'ns2:vcAccountLastName' of XSD type 'xsd:string'
        std::string *vcAccountLastName;
        /// Optional element 'ns2:vcAccountEncryptedID' of XSD type 'xsd:string'
        std::string *vcAccountEncryptedID;
        /// Optional element 'ns2:vcAccountEmail' of XSD type 'xsd:string'
        std::string *vcAccountEmail;
        /// Optional element 'ns2:vcAccountMobilePhoneNumber' of XSD type 'xsd:string'
        std::string *vcAccountMobilePhoneNumber;
        /// Optional element 'ns2:merchantReferenceID' of XSD type 'xsd:string'
        std::string *merchantReferenceID;
        /// Optional element 'ns2:subtotalAmount' of XSD type 'xsd:string'
        std::string *subtotalAmount;
        /// Optional element 'ns2:shippingHandlingAmount' of XSD type 'xsd:string'
        std::string *shippingHandlingAmount;
        /// Optional element 'ns2:taxAmount' of XSD type 'xsd:string'
        std::string *taxAmount;
        /// Optional element 'ns2:discountAmount' of XSD type 'xsd:string'
        std::string *discountAmount;
        /// Optional element 'ns2:giftWrapAmount' of XSD type 'xsd:string'
        std::string *giftWrapAmount;
        /// Optional element 'ns2:uncategorizedAmount' of XSD type 'xsd:string'
        std::string *uncategorizedAmount;
        /// Optional element 'ns2:totalPurchaseAmount' of XSD type 'xsd:string'
        std::string *totalPurchaseAmount;
        /// Optional element 'ns2:walletReferenceID' of XSD type 'xsd:string'
        std::string *walletReferenceID;
        /// Optional element 'ns2:promotionCode' of XSD type 'xsd:string'
        std::string *promotionCode;
        /// Optional element 'ns2:paymentInstrumentID' of XSD type 'xsd:string'
        std::string *paymentInstrumentID;
        /// Optional element 'ns2:cardVerificationStatus' of XSD type 'xsd:string'
        std::string *cardVerificationStatus;
        /// Optional element 'ns2:issuerID' of XSD type 'xsd:string'
        std::string *issuerID;
        /// Optional element 'ns2:paymentInstrumentNickName' of XSD type 'xsd:string'
        std::string *paymentInstrumentNickName;
        /// Optional element 'ns2:nameOnCard' of XSD type 'xsd:string'
        std::string *nameOnCard;
        /// Optional element 'ns2:cardType' of XSD type 'xsd:string'
        std::string *cardType;
        /// Optional element 'ns2:cardGroup' of XSD type 'xsd:string'
        std::string *cardGroup;
        /// Optional element 'ns2:cardArt' of XSD type 'ns2:VCCardArt'
        ns2__VCCardArt *cardArt;
        /// Optional element 'ns2:riskAdvice' of XSD type 'xsd:string'
        std::string *riskAdvice;
        /// Optional element 'ns2:riskScore' of XSD type 'xsd:string'
        std::string *riskScore;
        /// Optional element 'ns2:riskAdditionalData' of XSD type 'xsd:string'
        std::string *riskAdditionalData;
        /// Optional element 'ns2:avsCodeRaw' of XSD type 'xsd:string'
        std::string *avsCodeRaw;
        /// Optional element 'ns2:cvnCodeRaw' of XSD type 'xsd:string'
        std::string *cvnCodeRaw;
        /// Optional element 'ns2:eciRaw' of XSD type 'xsd:string'
        std::string *eciRaw;
        /// Optional element 'ns2:eci' of XSD type 'xsd:string'
        std::string *eci;
        /// Optional element 'ns2:cavv' of XSD type 'xsd:string'
        std::string *cavv;
        /// Optional element 'ns2:veresEnrolled' of XSD type 'xsd:string'
        std::string *veresEnrolled;
        /// Optional element 'ns2:veresTimeStamp' of XSD type 'xsd:string'
        std::string *veresTimeStamp;
        /// Optional element 'ns2:paresStatus' of XSD type 'xsd:string'
        std::string *paresStatus;
        /// Optional element 'ns2:paresTimeStamp' of XSD type 'xsd:string'
        std::string *paresTimeStamp;
        /// Optional element 'ns2:xid' of XSD type 'xsd:string'
        std::string *xid;
        /// Optional element 'ns2:customData' of XSD type 'ns2:VCCustomData'
        ns2__VCCustomData *customData;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__VCReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__VCReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__VCReply, default initialized and not managed by a soap context
        virtual ns2__VCReply *soap_alloc(void) const { return SOAP_NEW(ns2__VCReply); }
      public:
        /// Constructor with initializations
        ns2__VCReply()
        {
          creationTimeStamp = (std::string *)0;
          alternateShippingAddressCountryCode = (std::string *)0;
          alternateShippingAddressPostalCode = (std::string *)0;
          vcAccountLoginName = (std::string *)0;
          vcAccountFirstName = (std::string *)0;
          vcAccountLastName = (std::string *)0;
          vcAccountEncryptedID = (std::string *)0;
          vcAccountEmail = (std::string *)0;
          vcAccountMobilePhoneNumber = (std::string *)0;
          merchantReferenceID = (std::string *)0;
          subtotalAmount = (std::string *)0;
          shippingHandlingAmount = (std::string *)0;
          taxAmount = (std::string *)0;
          discountAmount = (std::string *)0;
          giftWrapAmount = (std::string *)0;
          uncategorizedAmount = (std::string *)0;
          totalPurchaseAmount = (std::string *)0;
          walletReferenceID = (std::string *)0;
          promotionCode = (std::string *)0;
          paymentInstrumentID = (std::string *)0;
          cardVerificationStatus = (std::string *)0;
          issuerID = (std::string *)0;
          paymentInstrumentNickName = (std::string *)0;
          nameOnCard = (std::string *)0;
          cardType = (std::string *)0;
          cardGroup = (std::string *)0;
          cardArt = (ns2__VCCardArt *)0;
          riskAdvice = (std::string *)0;
          riskScore = (std::string *)0;
          riskAdditionalData = (std::string *)0;
          avsCodeRaw = (std::string *)0;
          cvnCodeRaw = (std::string *)0;
          eciRaw = (std::string *)0;
          eci = (std::string *)0;
          cavv = (std::string *)0;
          veresEnrolled = (std::string *)0;
          veresTimeStamp = (std::string *)0;
          paresStatus = (std::string *)0;
          paresTimeStamp = (std::string *)0;
          xid = (std::string *)0;
          customData = (ns2__VCCustomData *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__VCReply() { }
        /// Friend allocator used by soap_new_ns2__VCReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__VCReply * SOAP_FMAC2 soap_instantiate_ns2__VCReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:870 */
#ifndef SOAP_TYPE_ns2__VCCardArt
#define SOAP_TYPE_ns2__VCCardArt (349)
/* complex XSD type 'ns2:VCCardArt': */
class SOAP_CMAC ns2__VCCardArt {
      public:
        /// Optional element 'ns2:fileName' of XSD type 'xsd:string'
        std::string *fileName;
        /// Optional element 'ns2:height' of XSD type 'xsd:string'
        std::string *height;
        /// Optional element 'ns2:width' of XSD type 'xsd:string'
        std::string *width;
        /// optional attribute 'id' of XSD type 'xsd:integer'
        std::string *id;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__VCCardArt
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__VCCardArt; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__VCCardArt, default initialized and not managed by a soap context
        virtual ns2__VCCardArt *soap_alloc(void) const { return SOAP_NEW(ns2__VCCardArt); }
      public:
        /// Constructor with initializations
        ns2__VCCardArt()
        {
          fileName = (std::string *)0;
          height = (std::string *)0;
          width = (std::string *)0;
          id = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__VCCardArt() { }
        /// Friend allocator used by soap_new_ns2__VCCardArt(struct soap*, int)
        friend SOAP_FMAC1 ns2__VCCardArt * SOAP_FMAC2 soap_instantiate_ns2__VCCardArt(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:873 */
#ifndef SOAP_TYPE_ns2__VCCustomData
#define SOAP_TYPE_ns2__VCCustomData (350)
/* complex XSD type 'ns2:VCCustomData': */
class SOAP_CMAC ns2__VCCustomData {
      public:
        /// Optional element 'ns2:name' of XSD type 'xsd:string'
        std::string *name;
        /// Optional element 'ns2:value' of XSD type 'xsd:string'
        std::string *value;
        /// optional attribute 'id' of XSD type 'xsd:integer'
        std::string *id;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__VCCustomData
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__VCCustomData; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__VCCustomData, default initialized and not managed by a soap context
        virtual ns2__VCCustomData *soap_alloc(void) const { return SOAP_NEW(ns2__VCCustomData); }
      public:
        /// Constructor with initializations
        ns2__VCCustomData()
        {
          name = (std::string *)0;
          value = (std::string *)0;
          id = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__VCCustomData() { }
        /// Friend allocator used by soap_new_ns2__VCCustomData(struct soap*, int)
        friend SOAP_FMAC1 ns2__VCCustomData * SOAP_FMAC2 soap_instantiate_ns2__VCCustomData(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:876 */
#ifndef SOAP_TYPE_ns2__DecryptVisaCheckoutDataReply
#define SOAP_TYPE_ns2__DecryptVisaCheckoutDataReply (351)
/* complex XSD type 'ns2:DecryptVisaCheckoutDataReply': */
class SOAP_CMAC ns2__DecryptVisaCheckoutDataReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__DecryptVisaCheckoutDataReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__DecryptVisaCheckoutDataReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__DecryptVisaCheckoutDataReply, default initialized and not managed by a soap context
        virtual ns2__DecryptVisaCheckoutDataReply *soap_alloc(void) const { return SOAP_NEW(ns2__DecryptVisaCheckoutDataReply); }
      public:
        /// Constructor with initializations
        ns2__DecryptVisaCheckoutDataReply()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__DecryptVisaCheckoutDataReply() { }
        /// Friend allocator used by soap_new_ns2__DecryptVisaCheckoutDataReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__DecryptVisaCheckoutDataReply * SOAP_FMAC2 soap_instantiate_ns2__DecryptVisaCheckoutDataReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:879 */
#ifndef SOAP_TYPE_ns2__EncryptPaymentDataReply
#define SOAP_TYPE_ns2__EncryptPaymentDataReply (352)
/* complex XSD type 'ns2:EncryptPaymentDataReply': */
class SOAP_CMAC ns2__EncryptPaymentDataReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:requestDateTime' of XSD type 'ns2:dateTime'
        std::string *requestDateTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__EncryptPaymentDataReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__EncryptPaymentDataReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__EncryptPaymentDataReply, default initialized and not managed by a soap context
        virtual ns2__EncryptPaymentDataReply *soap_alloc(void) const { return SOAP_NEW(ns2__EncryptPaymentDataReply); }
      public:
        /// Constructor with initializations
        ns2__EncryptPaymentDataReply()
        {
          requestDateTime = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__EncryptPaymentDataReply() { }
        /// Friend allocator used by soap_new_ns2__EncryptPaymentDataReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__EncryptPaymentDataReply * SOAP_FMAC2 soap_instantiate_ns2__EncryptPaymentDataReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:882 */
#ifndef SOAP_TYPE_ns2__BinLookupService
#define SOAP_TYPE_ns2__BinLookupService (353)
/* complex XSD type 'ns2:BinLookupService': */
class SOAP_CMAC ns2__BinLookupService {
      public:
        /// required attribute 'run' of XSD type 'ns2:boolean'
        std::string run;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__BinLookupService
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__BinLookupService; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__BinLookupService, default initialized and not managed by a soap context
        virtual ns2__BinLookupService *soap_alloc(void) const { return SOAP_NEW(ns2__BinLookupService); }
      public:
        /// Constructor with initializations
        ns2__BinLookupService()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__BinLookupService() { }
        /// Friend allocator used by soap_new_ns2__BinLookupService(struct soap*, int)
        friend SOAP_FMAC1 ns2__BinLookupService * SOAP_FMAC2 soap_instantiate_ns2__BinLookupService(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:885 */
#ifndef SOAP_TYPE_ns2__BinLookupReply
#define SOAP_TYPE_ns2__BinLookupReply (354)
/* complex XSD type 'ns2:BinLookupReply': */
class SOAP_CMAC ns2__BinLookupReply {
      public:
        /// Required element 'ns2:reasonCode' of XSD type 'xsd:integer'
        std::string reasonCode;
        /// Optional element 'ns2:cardType' of XSD type 'xsd:string'
        std::string *cardType;
        /// Optional element 'ns2:cardGroup' of XSD type 'xsd:string'
        std::string *cardGroup;
        /// Optional element 'ns2:issuerName' of XSD type 'xsd:string'
        std::string *issuerName;
        /// Optional element 'ns2:issuerCountry' of XSD type 'xsd:string'
        std::string *issuerCountry;
        /// Optional element 'ns2:issuedCurrency' of XSD type 'xsd:string'
        std::string *issuedCurrency;
        /// Optional element 'ns2:level2Eligibility' of XSD type 'xsd:string'
        std::string *level2Eligibility;
        /// Optional element 'ns2:level3Eligibility' of XSD type 'xsd:string'
        std::string *level3Eligibility;
        /// Optional element 'ns2:cardCategory' of XSD type 'xsd:string'
        std::string *cardCategory;
        /// Optional element 'ns2:crossBorderIndicator' of XSD type 'xsd:string'
        std::string *crossBorderIndicator;
        /// Optional element 'ns2:issuerPhoneNumber' of XSD type 'xsd:string'
        std::string *issuerPhoneNumber;
        /// Optional element 'ns2:billingCurrency' of XSD type 'xsd:string'
        std::string *billingCurrency;
        /// Optional element 'ns2:billingCurrencyMinorDigits' of XSD type 'xsd:string'
        std::string *billingCurrencyMinorDigits;
        /// Optional element 'ns2:fastFundsIndicator' of XSD type 'xsd:string'
        std::string *fastFundsIndicator;
        /// Optional element 'ns2:octBlockIndicator' of XSD type 'xsd:string'
        std::string *octBlockIndicator;
        /// Optional element 'ns2:onlineGamblingBlockIndicator' of XSD type 'xsd:string'
        std::string *onlineGamblingBlockIndicator;
        /// Optional element 'ns2:requestDateTime' of XSD type 'ns2:dateTime'
        std::string *requestDateTime;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__BinLookupReply
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__BinLookupReply; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__BinLookupReply, default initialized and not managed by a soap context
        virtual ns2__BinLookupReply *soap_alloc(void) const { return SOAP_NEW(ns2__BinLookupReply); }
      public:
        /// Constructor with initializations
        ns2__BinLookupReply()
        {
          cardType = (std::string *)0;
          cardGroup = (std::string *)0;
          issuerName = (std::string *)0;
          issuerCountry = (std::string *)0;
          issuedCurrency = (std::string *)0;
          level2Eligibility = (std::string *)0;
          level3Eligibility = (std::string *)0;
          cardCategory = (std::string *)0;
          crossBorderIndicator = (std::string *)0;
          issuerPhoneNumber = (std::string *)0;
          billingCurrency = (std::string *)0;
          billingCurrencyMinorDigits = (std::string *)0;
          fastFundsIndicator = (std::string *)0;
          octBlockIndicator = (std::string *)0;
          onlineGamblingBlockIndicator = (std::string *)0;
          requestDateTime = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__BinLookupReply() { }
        /// Friend allocator used by soap_new_ns2__BinLookupReply(struct soap*, int)
        friend SOAP_FMAC1 ns2__BinLookupReply * SOAP_FMAC2 soap_instantiate_ns2__BinLookupReply(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:888 */
#ifndef SOAP_TYPE_ns2__issuer
#define SOAP_TYPE_ns2__issuer (355)
/* complex XSD type 'ns2:issuer': */
class SOAP_CMAC ns2__issuer {
      public:
        /// Optional element 'ns2:additionalData' of XSD type 'xsd:string'
        std::string *additionalData;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__issuer
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__issuer; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__issuer, default initialized and not managed by a soap context
        virtual ns2__issuer *soap_alloc(void) const { return SOAP_NEW(ns2__issuer); }
      public:
        /// Constructor with initializations
        ns2__issuer()
        {
          additionalData = (std::string *)0;
          soap = (struct soap *)0;
        }
        virtual ~ns2__issuer() { }
        /// Friend allocator used by soap_new_ns2__issuer(struct soap*, int)
        friend SOAP_FMAC1 ns2__issuer * SOAP_FMAC2 soap_instantiate_ns2__issuer(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:813 */
#ifndef SOAP_TYPE_ns2__MDDField
#define SOAP_TYPE_ns2__MDDField (330)
/* simple XSD type 'ns2:MDDField': */
class SOAP_CMAC ns2__MDDField {
      public:
        /// Simple content of XSD type 'xsd:string' wrapped by this struct
        std::string __item;
        /// required attribute 'id' of XSD type 'xsd:integer'
        std::string id;
        /// Context that manages this object
        struct soap *soap;
      public:
        /// Return unique type id SOAP_TYPE_ns2__MDDField
        virtual int soap_type(void) const { return SOAP_TYPE_ns2__MDDField; }
        /// (Re)set members to default values
        virtual void soap_default(struct soap*);
        /// Serialize object to prepare for SOAP 1.1/1.2 encoded output (or with SOAP_XML_GRAPH) by analyzing its (cyclic) structures
        virtual void soap_serialize(struct soap*) const;
        /// Output object in XML, compliant with SOAP 1.1 encoding style, return error code or SOAP_OK
        virtual int soap_put(struct soap*, const char *tag, const char *type) const;
        /// Output object in XML, with tag and optional id attribute and xsi:type, return error code or SOAP_OK
        virtual int soap_out(struct soap*, const char *tag, int id, const char *type) const;
        /// Get object from XML, compliant with SOAP 1.1 encoding style, return pointer to object or NULL on error
        virtual void *soap_get(struct soap*, const char *tag, const char *type);
        /// Get object from XML, with matching tag and type (NULL matches any tag and type), return pointer to object or NULL on error
        virtual void *soap_in(struct soap*, const char *tag, const char *type);
        /// Return a new object of type ns2__MDDField, default initialized and not managed by a soap context
        virtual ns2__MDDField *soap_alloc(void) const { return SOAP_NEW(ns2__MDDField); }
      public:
        /// Constructor with initializations
        ns2__MDDField()
        {
          soap = (struct soap *)0;
        }
        virtual ~ns2__MDDField() { }
        /// Friend allocator used by soap_new_ns2__MDDField(struct soap*, int)
        friend SOAP_FMAC1 ns2__MDDField * SOAP_FMAC2 soap_instantiate_ns2__MDDField(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:10712 */
#ifndef SOAP_TYPE___ns1__runTransaction
#define SOAP_TYPE___ns1__runTransaction (627)
/* Wrapper: */
struct __ns1__runTransaction {
      public:
        /** Optional element 'ns2:requestMessage' of XSD type 'ns2:RequestMessage' */
        ns2__RequestMessage *ns2__requestMessage;
      public:
        /** Return unique type id SOAP_TYPE___ns1__runTransaction */
        int soap_type() const { return SOAP_TYPE___ns1__runTransaction; }
        /** Constructor with member initializations */
        __ns1__runTransaction()
        {
          ns2__requestMessage = (ns2__RequestMessage *)0;
        }
        /** Friend allocator used by soap_new___ns1__runTransaction(struct soap*, int) */
        friend SOAP_FMAC1 __ns1__runTransaction * SOAP_FMAC2 soap_instantiate___ns1__runTransaction(struct soap*, int, const char*, const char*, size_t*);
};
#endif

/* CyberSourceTransaction_xml_1.129.h:10785 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (628)
/* Type SOAP_ENV__Code is a recursive data type, (in)directly referencing itself through its (base or derived class) members */
/* SOAP_ENV__Code: */
struct SOAP_ENV__Code {
      public:
        /** Optional element 'SOAP-ENV:Value' of XSD type 'xsd:QName' */
        char *SOAP_ENV__Value;
        /** Optional element 'SOAP-ENV:Subcode' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Subcode;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Code */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Code; }
        /** Constructor with member initializations */
        SOAP_ENV__Code()
        {
          SOAP_ENV__Value = (char *)0;
          SOAP_ENV__Subcode = (struct SOAP_ENV__Code *)0;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Code(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Code * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Code(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* CyberSourceTransaction_xml_1.129.h:10785 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (630)
/* SOAP_ENV__Detail: */
struct SOAP_ENV__Detail {
      public:
        char *__any;
        /** Any type of element 'fault' assigned to fault with its SOAP_TYPE_T assigned to __type */
        /** Do not create a cyclic data structure throught this member unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
        int __type;
        void *fault;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Detail */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Detail; }
        /** Constructor with member initializations */
        SOAP_ENV__Detail()
        {
          __any = (char *)0;
          __type = 0;
          fault = NULL;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Detail(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Detail * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Detail(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* CyberSourceTransaction_xml_1.129.h:10785 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (633)
/* SOAP_ENV__Reason: */
struct SOAP_ENV__Reason {
      public:
        /** Optional element 'SOAP-ENV:Text' of XSD type 'xsd:string' */
        char *SOAP_ENV__Text;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Reason */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Reason; }
        /** Constructor with member initializations */
        SOAP_ENV__Reason()
        {
          SOAP_ENV__Text = (char *)0;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Reason(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Reason * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Reason(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/* CyberSourceTransaction_xml_1.129.h:10785 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (634)
/* SOAP_ENV__Fault: */
struct SOAP_ENV__Fault {
      public:
        /** Optional element 'faultcode' of XSD type 'xsd:QName' */
        char *faultcode;
        /** Optional element 'faultstring' of XSD type 'xsd:string' */
        char *faultstring;
        /** Optional element 'faultactor' of XSD type 'xsd:string' */
        char *faultactor;
        /** Optional element 'detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *detail;
        /** Optional element 'SOAP-ENV:Code' of XSD type 'SOAP-ENV:Code' */
        struct SOAP_ENV__Code *SOAP_ENV__Code;
        /** Optional element 'SOAP-ENV:Reason' of XSD type 'SOAP-ENV:Reason' */
        struct SOAP_ENV__Reason *SOAP_ENV__Reason;
        /** Optional element 'SOAP-ENV:Node' of XSD type 'xsd:string' */
        char *SOAP_ENV__Node;
        /** Optional element 'SOAP-ENV:Role' of XSD type 'xsd:string' */
        char *SOAP_ENV__Role;
        /** Optional element 'SOAP-ENV:Detail' of XSD type 'SOAP-ENV:Detail' */
        struct SOAP_ENV__Detail *SOAP_ENV__Detail;
      public:
        /** Return unique type id SOAP_TYPE_SOAP_ENV__Fault */
        int soap_type() const { return SOAP_TYPE_SOAP_ENV__Fault; }
        /** Constructor with member initializations */
        SOAP_ENV__Fault()
        {
          faultcode = (char *)0;
          faultstring = (char *)0;
          faultactor = (char *)0;
          detail = (struct SOAP_ENV__Detail *)0;
          SOAP_ENV__Code = (struct SOAP_ENV__Code *)0;
          SOAP_ENV__Reason = (struct SOAP_ENV__Reason *)0;
          SOAP_ENV__Node = (char *)0;
          SOAP_ENV__Role = (char *)0;
          SOAP_ENV__Detail = (struct SOAP_ENV__Detail *)0;
        }
        /** Friend allocator used by soap_new_SOAP_ENV__Fault(struct soap*, int) */
        friend SOAP_FMAC1 SOAP_ENV__Fault * SOAP_FMAC2 soap_instantiate_SOAP_ENV__Fault(struct soap*, int, const char*, const char*, size_t*);
};
#endif
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* CyberSourceTransaction_xml_1.129.h:102 */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

/* CyberSourceTransaction_xml_1.129.h:102 */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif

/* ds.h:44 */
#ifndef SOAP_TYPE__ds__SignatureValue
#define SOAP_TYPE__ds__SignatureValue (29)
typedef char *_ds__SignatureValue;
#endif

/* ds.h:50 */
#ifndef SOAP_TYPE__ds__Signature
#define SOAP_TYPE__ds__Signature (35)
typedef struct ds__SignatureType _ds__Signature;
#endif

/* ds.h:76 */
#ifndef SOAP_TYPE__ds__Transform
#define SOAP_TYPE__ds__Transform (43)
typedef struct ds__TransformType _ds__Transform;
#endif

/* ds.h:90 */
#ifndef SOAP_TYPE__ds__KeyInfo
#define SOAP_TYPE__ds__KeyInfo (50)
typedef struct ds__KeyInfoType _ds__KeyInfo;
#endif

/* wsc.h:57 */
#ifndef SOAP_TYPE_wsc__FaultCodeOpenEnumType
#define SOAP_TYPE_wsc__FaultCodeOpenEnumType (88)
typedef char *wsc__FaultCodeOpenEnumType;
#endif

/* CyberSourceTransaction_xml_1.129.h:142 */
#ifndef SOAP_TYPE_xsd__integer
#define SOAP_TYPE_xsd__integer (109)
typedef std::string xsd__integer;
#endif

/* CyberSourceTransaction_xml_1.129.h:908 */
#ifndef SOAP_TYPE_ns2__amount
#define SOAP_TYPE_ns2__amount (356)
typedef std::string ns2__amount;
#endif

/* CyberSourceTransaction_xml_1.129.h:912 */
#ifndef SOAP_TYPE_ns2__boolean
#define SOAP_TYPE_ns2__boolean (357)
typedef std::string ns2__boolean;
#endif

/* CyberSourceTransaction_xml_1.129.h:916 */
#ifndef SOAP_TYPE_ns2__dateTime
#define SOAP_TYPE_ns2__dateTime (358)
typedef std::string ns2__dateTime;
#endif

/******************************************************************************\
 *                                                                            *
 * Serializable Types                                                         *
 *                                                                            *
\******************************************************************************/


/* char has binding name 'byte' for type 'xsd:byte' */
#ifndef SOAP_TYPE_byte
#define SOAP_TYPE_byte (3)
#endif

/* int has binding name 'int' for type 'xsd:int' */
#ifndef SOAP_TYPE_int
#define SOAP_TYPE_int (1)
#endif

/* ULONG64 has binding name 'ULONG64' for type 'xsd:unsignedLong' */
#ifndef SOAP_TYPE_ULONG64
#define SOAP_TYPE_ULONG64 (95)
#endif

/* enum wsc__FaultCodeType has binding name 'wsc__FaultCodeType' for type 'wsc:FaultCodeType' */
#ifndef SOAP_TYPE_wsc__FaultCodeType
#define SOAP_TYPE_wsc__FaultCodeType (89)
#endif

/* enum wsse__FaultcodeEnum has binding name 'wsse__FaultcodeEnum' for type 'wsse:FaultcodeEnum' */
#ifndef SOAP_TYPE_wsse__FaultcodeEnum
#define SOAP_TYPE_wsse__FaultcodeEnum (14)
#endif

/* enum wsu__tTimestampFault has binding name 'wsu__tTimestampFault' for type 'wsu:tTimestampFault' */
#ifndef SOAP_TYPE_wsu__tTimestampFault
#define SOAP_TYPE_wsu__tTimestampFault (11)
#endif

/* ns2__dateTime has binding name 'ns2__dateTime' for type 'ns2:dateTime' */
#ifndef SOAP_TYPE_ns2__dateTime
#define SOAP_TYPE_ns2__dateTime (358)
#endif

/* ns2__boolean has binding name 'ns2__boolean' for type 'ns2:boolean' */
#ifndef SOAP_TYPE_ns2__boolean
#define SOAP_TYPE_ns2__boolean (357)
#endif

/* ns2__amount has binding name 'ns2__amount' for type 'ns2:amount' */
#ifndef SOAP_TYPE_ns2__amount
#define SOAP_TYPE_ns2__amount (356)
#endif

/* ns2__issuer has binding name 'ns2__issuer' for type 'ns2:issuer' */
#ifndef SOAP_TYPE_ns2__issuer
#define SOAP_TYPE_ns2__issuer (355)
#endif

/* ns2__BinLookupReply has binding name 'ns2__BinLookupReply' for type 'ns2:BinLookupReply' */
#ifndef SOAP_TYPE_ns2__BinLookupReply
#define SOAP_TYPE_ns2__BinLookupReply (354)
#endif

/* ns2__BinLookupService has binding name 'ns2__BinLookupService' for type 'ns2:BinLookupService' */
#ifndef SOAP_TYPE_ns2__BinLookupService
#define SOAP_TYPE_ns2__BinLookupService (353)
#endif

/* ns2__EncryptPaymentDataReply has binding name 'ns2__EncryptPaymentDataReply' for type 'ns2:EncryptPaymentDataReply' */
#ifndef SOAP_TYPE_ns2__EncryptPaymentDataReply
#define SOAP_TYPE_ns2__EncryptPaymentDataReply (352)
#endif

/* ns2__DecryptVisaCheckoutDataReply has binding name 'ns2__DecryptVisaCheckoutDataReply' for type 'ns2:DecryptVisaCheckoutDataReply' */
#ifndef SOAP_TYPE_ns2__DecryptVisaCheckoutDataReply
#define SOAP_TYPE_ns2__DecryptVisaCheckoutDataReply (351)
#endif

/* ns2__VCCustomData has binding name 'ns2__VCCustomData' for type 'ns2:VCCustomData' */
#ifndef SOAP_TYPE_ns2__VCCustomData
#define SOAP_TYPE_ns2__VCCustomData (350)
#endif

/* ns2__VCCardArt has binding name 'ns2__VCCardArt' for type 'ns2:VCCardArt' */
#ifndef SOAP_TYPE_ns2__VCCardArt
#define SOAP_TYPE_ns2__VCCardArt (349)
#endif

/* ns2__VCReply has binding name 'ns2__VCReply' for type 'ns2:VCReply' */
#ifndef SOAP_TYPE_ns2__VCReply
#define SOAP_TYPE_ns2__VCReply (348)
#endif

/* ns2__AutoRentalData has binding name 'ns2__AutoRentalData' for type 'ns2:AutoRentalData' */
#ifndef SOAP_TYPE_ns2__AutoRentalData
#define SOAP_TYPE_ns2__AutoRentalData (347)
#endif

/* ns2__HostedDataRetrieveReply has binding name 'ns2__HostedDataRetrieveReply' for type 'ns2:HostedDataRetrieveReply' */
#ifndef SOAP_TYPE_ns2__HostedDataRetrieveReply
#define SOAP_TYPE_ns2__HostedDataRetrieveReply (346)
#endif

/* ns2__HostedDataCreateReply has binding name 'ns2__HostedDataCreateReply' for type 'ns2:HostedDataCreateReply' */
#ifndef SOAP_TYPE_ns2__HostedDataCreateReply
#define SOAP_TYPE_ns2__HostedDataCreateReply (345)
#endif

/* ns2__HostedDataRetrieveService has binding name 'ns2__HostedDataRetrieveService' for type 'ns2:HostedDataRetrieveService' */
#ifndef SOAP_TYPE_ns2__HostedDataRetrieveService
#define SOAP_TYPE_ns2__HostedDataRetrieveService (344)
#endif

/* ns2__HostedDataCreateService has binding name 'ns2__HostedDataCreateService' for type 'ns2:HostedDataCreateService' */
#ifndef SOAP_TYPE_ns2__HostedDataCreateService
#define SOAP_TYPE_ns2__HostedDataCreateService (343)
#endif

/* ns2__OriginalTransaction has binding name 'ns2__OriginalTransaction' for type 'ns2:OriginalTransaction' */
#ifndef SOAP_TYPE_ns2__OriginalTransaction
#define SOAP_TYPE_ns2__OriginalTransaction (342)
#endif

/* ns2__EmvReply has binding name 'ns2__EmvReply' for type 'ns2:EmvReply' */
#ifndef SOAP_TYPE_ns2__EmvReply
#define SOAP_TYPE_ns2__EmvReply (341)
#endif

/* ns2__EmvRequest has binding name 'ns2__EmvRequest' for type 'ns2:EmvRequest' */
#ifndef SOAP_TYPE_ns2__EmvRequest
#define SOAP_TYPE_ns2__EmvRequest (340)
#endif

/* ns2__ServiceFee has binding name 'ns2__ServiceFee' for type 'ns2:ServiceFee' */
#ifndef SOAP_TYPE_ns2__ServiceFee
#define SOAP_TYPE_ns2__ServiceFee (339)
#endif

/* ns2__CCDCCUpdateService has binding name 'ns2__CCDCCUpdateService' for type 'ns2:CCDCCUpdateService' */
#ifndef SOAP_TYPE_ns2__CCDCCUpdateService
#define SOAP_TYPE_ns2__CCDCCUpdateService (338)
#endif

/* ns2__PaypalTransaction has binding name 'ns2__PaypalTransaction' for type 'ns2:PaypalTransaction' */
#ifndef SOAP_TYPE_ns2__PaypalTransaction
#define SOAP_TYPE_ns2__PaypalTransaction (337)
#endif

/* ns2__PayPalTransactionSearchReply has binding name 'ns2__PayPalTransactionSearchReply' for type 'ns2:PayPalTransactionSearchReply' */
#ifndef SOAP_TYPE_ns2__PayPalTransactionSearchReply
#define SOAP_TYPE_ns2__PayPalTransactionSearchReply (336)
#endif

/* ns2__PayPalGetTxnDetailsReply has binding name 'ns2__PayPalGetTxnDetailsReply' for type 'ns2:PayPalGetTxnDetailsReply' */
#ifndef SOAP_TYPE_ns2__PayPalGetTxnDetailsReply
#define SOAP_TYPE_ns2__PayPalGetTxnDetailsReply (335)
#endif

/* ns2__RequestReserved has binding name 'ns2__RequestReserved' for type 'ns2:RequestReserved' */
#ifndef SOAP_TYPE_ns2__RequestReserved
#define SOAP_TYPE_ns2__RequestReserved (334)
#endif

/* ns2__ReplyReserved has binding name 'ns2__ReplyReserved' for type 'ns2:ReplyReserved' */
#ifndef SOAP_TYPE_ns2__ReplyReserved
#define SOAP_TYPE_ns2__ReplyReserved (333)
#endif

/* ns2__MerchantSecureData has binding name 'ns2__MerchantSecureData' for type 'ns2:MerchantSecureData' */
#ifndef SOAP_TYPE_ns2__MerchantSecureData
#define SOAP_TYPE_ns2__MerchantSecureData (332)
#endif

/* ns2__MerchantDefinedData has binding name 'ns2__MerchantDefinedData' for type 'ns2:MerchantDefinedData' */
#ifndef SOAP_TYPE_ns2__MerchantDefinedData
#define SOAP_TYPE_ns2__MerchantDefinedData (331)
#endif

/* ns2__MDDField has binding name 'ns2__MDDField' for type 'ns2:MDDField' */
#ifndef SOAP_TYPE_ns2__MDDField
#define SOAP_TYPE_ns2__MDDField (330)
#endif

/* ns2__Installment has binding name 'ns2__Installment' for type 'ns2:Installment' */
#ifndef SOAP_TYPE_ns2__Installment
#define SOAP_TYPE_ns2__Installment (329)
#endif

/* ns2__EncryptedPayment has binding name 'ns2__EncryptedPayment' for type 'ns2:EncryptedPayment' */
#ifndef SOAP_TYPE_ns2__EncryptedPayment
#define SOAP_TYPE_ns2__EncryptedPayment (328)
#endif

/* ns2__Pos has binding name 'ns2__Pos' for type 'ns2:Pos' */
#ifndef SOAP_TYPE_ns2__Pos
#define SOAP_TYPE_ns2__Pos (327)
#endif

/* ns2__LodgingData has binding name 'ns2__LodgingData' for type 'ns2:LodgingData' */
#ifndef SOAP_TYPE_ns2__LodgingData
#define SOAP_TYPE_ns2__LodgingData (326)
#endif

/* ns2__Service has binding name 'ns2__Service' for type 'ns2:Service' */
#ifndef SOAP_TYPE_ns2__Service
#define SOAP_TYPE_ns2__Service (325)
#endif

/* ns2__AncillaryData has binding name 'ns2__AncillaryData' for type 'ns2:AncillaryData' */
#ifndef SOAP_TYPE_ns2__AncillaryData
#define SOAP_TYPE_ns2__AncillaryData (324)
#endif

/* ns2__Leg has binding name 'ns2__Leg' for type 'ns2:Leg' */
#ifndef SOAP_TYPE_ns2__Leg
#define SOAP_TYPE_ns2__Leg (323)
#endif

/* ns2__AirlineData has binding name 'ns2__AirlineData' for type 'ns2:AirlineData' */
#ifndef SOAP_TYPE_ns2__AirlineData
#define SOAP_TYPE_ns2__AirlineData (322)
#endif

/* ns2__FaultDetails has binding name 'ns2__FaultDetails' for type 'ns2:FaultDetails' */
#ifndef SOAP_TYPE_ns2__FaultDetails
#define SOAP_TYPE_ns2__FaultDetails (321)
#endif

/* ns2__ReplyMessage has binding name 'ns2__ReplyMessage' for type 'ns2:ReplyMessage' */
#ifndef SOAP_TYPE_ns2__ReplyMessage
#define SOAP_TYPE_ns2__ReplyMessage (320)
#endif

/* ns2__APConfirmPurchaseReply has binding name 'ns2__APConfirmPurchaseReply' for type 'ns2:APConfirmPurchaseReply' */
#ifndef SOAP_TYPE_ns2__APConfirmPurchaseReply
#define SOAP_TYPE_ns2__APConfirmPurchaseReply (319)
#endif

/* ns2__APTransactionDetailsReply has binding name 'ns2__APTransactionDetailsReply' for type 'ns2:APTransactionDetailsReply' */
#ifndef SOAP_TYPE_ns2__APTransactionDetailsReply
#define SOAP_TYPE_ns2__APTransactionDetailsReply (318)
#endif

/* ns2__APCheckOutDetailsReply has binding name 'ns2__APCheckOutDetailsReply' for type 'ns2:APCheckOutDetailsReply' */
#ifndef SOAP_TYPE_ns2__APCheckOutDetailsReply
#define SOAP_TYPE_ns2__APCheckOutDetailsReply (317)
#endif

/* ns2__APSaleReply has binding name 'ns2__APSaleReply' for type 'ns2:APSaleReply' */
#ifndef SOAP_TYPE_ns2__APSaleReply
#define SOAP_TYPE_ns2__APSaleReply (316)
#endif

/* ns2__APRefundReply has binding name 'ns2__APRefundReply' for type 'ns2:APRefundReply' */
#ifndef SOAP_TYPE_ns2__APRefundReply
#define SOAP_TYPE_ns2__APRefundReply (315)
#endif

/* ns2__APOptionsOption has binding name 'ns2__APOptionsOption' for type 'ns2:APOptionsOption' */
#ifndef SOAP_TYPE_ns2__APOptionsOption
#define SOAP_TYPE_ns2__APOptionsOption (314)
#endif

/* ns2__APOptionsReply has binding name 'ns2__APOptionsReply' for type 'ns2:APOptionsReply' */
#ifndef SOAP_TYPE_ns2__APOptionsReply
#define SOAP_TYPE_ns2__APOptionsReply (313)
#endif

/* ns2__APCaptureReply has binding name 'ns2__APCaptureReply' for type 'ns2:APCaptureReply' */
#ifndef SOAP_TYPE_ns2__APCaptureReply
#define SOAP_TYPE_ns2__APCaptureReply (312)
#endif

/* ns2__APAuthReversalReply has binding name 'ns2__APAuthReversalReply' for type 'ns2:APAuthReversalReply' */
#ifndef SOAP_TYPE_ns2__APAuthReversalReply
#define SOAP_TYPE_ns2__APAuthReversalReply (311)
#endif

/* ns2__APAuthReply has binding name 'ns2__APAuthReply' for type 'ns2:APAuthReply' */
#ifndef SOAP_TYPE_ns2__APAuthReply
#define SOAP_TYPE_ns2__APAuthReply (310)
#endif

/* ns2__APReply has binding name 'ns2__APReply' for type 'ns2:APReply' */
#ifndef SOAP_TYPE_ns2__APReply
#define SOAP_TYPE_ns2__APReply (309)
#endif

/* ns2__APCheckStatusReply has binding name 'ns2__APCheckStatusReply' for type 'ns2:APCheckStatusReply' */
#ifndef SOAP_TYPE_ns2__APCheckStatusReply
#define SOAP_TYPE_ns2__APCheckStatusReply (308)
#endif

/* ns2__APInitiateReply has binding name 'ns2__APInitiateReply' for type 'ns2:APInitiateReply' */
#ifndef SOAP_TYPE_ns2__APInitiateReply
#define SOAP_TYPE_ns2__APInitiateReply (307)
#endif

/* ns2__BoletoPaymentReply has binding name 'ns2__BoletoPaymentReply' for type 'ns2:BoletoPaymentReply' */
#ifndef SOAP_TYPE_ns2__BoletoPaymentReply
#define SOAP_TYPE_ns2__BoletoPaymentReply (306)
#endif

/* ns2__ChinaRefundReply has binding name 'ns2__ChinaRefundReply' for type 'ns2:ChinaRefundReply' */
#ifndef SOAP_TYPE_ns2__ChinaRefundReply
#define SOAP_TYPE_ns2__ChinaRefundReply (305)
#endif

/* ns2__ChinaPaymentReply has binding name 'ns2__ChinaPaymentReply' for type 'ns2:ChinaPaymentReply' */
#ifndef SOAP_TYPE_ns2__ChinaPaymentReply
#define SOAP_TYPE_ns2__ChinaPaymentReply (304)
#endif

/* ns2__CCDCCUpdateReply has binding name 'ns2__CCDCCUpdateReply' for type 'ns2:CCDCCUpdateReply' */
#ifndef SOAP_TYPE_ns2__CCDCCUpdateReply
#define SOAP_TYPE_ns2__CCDCCUpdateReply (303)
#endif

/* ns2__CCDCCReply has binding name 'ns2__CCDCCReply' for type 'ns2:CCDCCReply' */
#ifndef SOAP_TYPE_ns2__CCDCCReply
#define SOAP_TYPE_ns2__CCDCCReply (302)
#endif

/* ns2__ProfileReply has binding name 'ns2__ProfileReply' for type 'ns2:ProfileReply' */
#ifndef SOAP_TYPE_ns2__ProfileReply
#define SOAP_TYPE_ns2__ProfileReply (301)
#endif

/* ns2__DMEReply has binding name 'ns2__DMEReply' for type 'ns2:DMEReply' */
#ifndef SOAP_TYPE_ns2__DMEReply
#define SOAP_TYPE_ns2__DMEReply (300)
#endif

/* ns2__Field has binding name 'ns2__Field' for type 'ns2:Field' */
#ifndef SOAP_TYPE_ns2__Field
#define SOAP_TYPE_ns2__Field (299)
#endif

/* ns2__AdditionalFields has binding name 'ns2__AdditionalFields' for type 'ns2:AdditionalFields' */
#ifndef SOAP_TYPE_ns2__AdditionalFields
#define SOAP_TYPE_ns2__AdditionalFields (298)
#endif

/* ns2__DecisionReply has binding name 'ns2__DecisionReply' for type 'ns2:DecisionReply' */
#ifndef SOAP_TYPE_ns2__DecisionReply
#define SOAP_TYPE_ns2__DecisionReply (297)
#endif

/* ns2__RuleResultItems has binding name 'ns2__RuleResultItems' for type 'ns2:RuleResultItems' */
#ifndef SOAP_TYPE_ns2__RuleResultItems
#define SOAP_TYPE_ns2__RuleResultItems (296)
#endif

/* ns2__RuleResultItem has binding name 'ns2__RuleResultItem' for type 'ns2:RuleResultItem' */
#ifndef SOAP_TYPE_ns2__RuleResultItem
#define SOAP_TYPE_ns2__RuleResultItem (295)
#endif

/* ns2__CaseManagementActionReply has binding name 'ns2__CaseManagementActionReply' for type 'ns2:CaseManagementActionReply' */
#ifndef SOAP_TYPE_ns2__CaseManagementActionReply
#define SOAP_TYPE_ns2__CaseManagementActionReply (294)
#endif

/* ns2__FraudUpdateReply has binding name 'ns2__FraudUpdateReply' for type 'ns2:FraudUpdateReply' */
#ifndef SOAP_TYPE_ns2__FraudUpdateReply
#define SOAP_TYPE_ns2__FraudUpdateReply (293)
#endif

/* ns2__RiskUpdateReply has binding name 'ns2__RiskUpdateReply' for type 'ns2:RiskUpdateReply' */
#ifndef SOAP_TYPE_ns2__RiskUpdateReply
#define SOAP_TYPE_ns2__RiskUpdateReply (292)
#endif

/* ns2__PayPalDoRefTransactionReply has binding name 'ns2__PayPalDoRefTransactionReply' for type 'ns2:PayPalDoRefTransactionReply' */
#ifndef SOAP_TYPE_ns2__PayPalDoRefTransactionReply
#define SOAP_TYPE_ns2__PayPalDoRefTransactionReply (291)
#endif

/* ns2__PayPalCreateAgreementReply has binding name 'ns2__PayPalCreateAgreementReply' for type 'ns2:PayPalCreateAgreementReply' */
#ifndef SOAP_TYPE_ns2__PayPalCreateAgreementReply
#define SOAP_TYPE_ns2__PayPalCreateAgreementReply (290)
#endif

/* ns2__PayPalUpdateAgreementReply has binding name 'ns2__PayPalUpdateAgreementReply' for type 'ns2:PayPalUpdateAgreementReply' */
#ifndef SOAP_TYPE_ns2__PayPalUpdateAgreementReply
#define SOAP_TYPE_ns2__PayPalUpdateAgreementReply (289)
#endif

/* ns2__PayPalAuthorizationReply has binding name 'ns2__PayPalAuthorizationReply' for type 'ns2:PayPalAuthorizationReply' */
#ifndef SOAP_TYPE_ns2__PayPalAuthorizationReply
#define SOAP_TYPE_ns2__PayPalAuthorizationReply (288)
#endif

/* ns2__PayPalEcOrderSetupReply has binding name 'ns2__PayPalEcOrderSetupReply' for type 'ns2:PayPalEcOrderSetupReply' */
#ifndef SOAP_TYPE_ns2__PayPalEcOrderSetupReply
#define SOAP_TYPE_ns2__PayPalEcOrderSetupReply (287)
#endif

/* ns2__PayPalRefundReply has binding name 'ns2__PayPalRefundReply' for type 'ns2:PayPalRefundReply' */
#ifndef SOAP_TYPE_ns2__PayPalRefundReply
#define SOAP_TYPE_ns2__PayPalRefundReply (286)
#endif

/* ns2__PayPalAuthReversalReply has binding name 'ns2__PayPalAuthReversalReply' for type 'ns2:PayPalAuthReversalReply' */
#ifndef SOAP_TYPE_ns2__PayPalAuthReversalReply
#define SOAP_TYPE_ns2__PayPalAuthReversalReply (285)
#endif

/* ns2__PayPalDoCaptureReply has binding name 'ns2__PayPalDoCaptureReply' for type 'ns2:PayPalDoCaptureReply' */
#ifndef SOAP_TYPE_ns2__PayPalDoCaptureReply
#define SOAP_TYPE_ns2__PayPalDoCaptureReply (284)
#endif

/* ns2__PayPalEcDoPaymentReply has binding name 'ns2__PayPalEcDoPaymentReply' for type 'ns2:PayPalEcDoPaymentReply' */
#ifndef SOAP_TYPE_ns2__PayPalEcDoPaymentReply
#define SOAP_TYPE_ns2__PayPalEcDoPaymentReply (283)
#endif

/* ns2__PayPalEcGetDetailsReply has binding name 'ns2__PayPalEcGetDetailsReply' for type 'ns2:PayPalEcGetDetailsReply' */
#ifndef SOAP_TYPE_ns2__PayPalEcGetDetailsReply
#define SOAP_TYPE_ns2__PayPalEcGetDetailsReply (282)
#endif

/* ns2__PayPalEcSetReply has binding name 'ns2__PayPalEcSetReply' for type 'ns2:PayPalEcSetReply' */
#ifndef SOAP_TYPE_ns2__PayPalEcSetReply
#define SOAP_TYPE_ns2__PayPalEcSetReply (281)
#endif

/* ns2__PayPalPreapprovedUpdateReply has binding name 'ns2__PayPalPreapprovedUpdateReply' for type 'ns2:PayPalPreapprovedUpdateReply' */
#ifndef SOAP_TYPE_ns2__PayPalPreapprovedUpdateReply
#define SOAP_TYPE_ns2__PayPalPreapprovedUpdateReply (280)
#endif

/* ns2__PayPalPreapprovedPaymentReply has binding name 'ns2__PayPalPreapprovedPaymentReply' for type 'ns2:PayPalPreapprovedPaymentReply' */
#ifndef SOAP_TYPE_ns2__PayPalPreapprovedPaymentReply
#define SOAP_TYPE_ns2__PayPalPreapprovedPaymentReply (279)
#endif

/* ns2__PayPalButtonCreateReply has binding name 'ns2__PayPalButtonCreateReply' for type 'ns2:PayPalButtonCreateReply' */
#ifndef SOAP_TYPE_ns2__PayPalButtonCreateReply
#define SOAP_TYPE_ns2__PayPalButtonCreateReply (278)
#endif

/* ns2__PinlessDebitReversalReply has binding name 'ns2__PinlessDebitReversalReply' for type 'ns2:PinlessDebitReversalReply' */
#ifndef SOAP_TYPE_ns2__PinlessDebitReversalReply
#define SOAP_TYPE_ns2__PinlessDebitReversalReply (277)
#endif

/* ns2__PinlessDebitValidateReply has binding name 'ns2__PinlessDebitValidateReply' for type 'ns2:PinlessDebitValidateReply' */
#ifndef SOAP_TYPE_ns2__PinlessDebitValidateReply
#define SOAP_TYPE_ns2__PinlessDebitValidateReply (276)
#endif

/* ns2__PinlessDebitReply has binding name 'ns2__PinlessDebitReply' for type 'ns2:PinlessDebitReply' */
#ifndef SOAP_TYPE_ns2__PinlessDebitReply
#define SOAP_TYPE_ns2__PinlessDebitReply (275)
#endif

/* ns2__VoidReply has binding name 'ns2__VoidReply' for type 'ns2:VoidReply' */
#ifndef SOAP_TYPE_ns2__VoidReply
#define SOAP_TYPE_ns2__VoidReply (274)
#endif

/* ns2__PayPalCreditReply has binding name 'ns2__PayPalCreditReply' for type 'ns2:PayPalCreditReply' */
#ifndef SOAP_TYPE_ns2__PayPalCreditReply
#define SOAP_TYPE_ns2__PayPalCreditReply (273)
#endif

/* ns2__PayPalPaymentReply has binding name 'ns2__PayPalPaymentReply' for type 'ns2:PayPalPaymentReply' */
#ifndef SOAP_TYPE_ns2__PayPalPaymentReply
#define SOAP_TYPE_ns2__PayPalPaymentReply (272)
#endif

/* ns2__PaySubscriptionDeleteReply has binding name 'ns2__PaySubscriptionDeleteReply' for type 'ns2:PaySubscriptionDeleteReply' */
#ifndef SOAP_TYPE_ns2__PaySubscriptionDeleteReply
#define SOAP_TYPE_ns2__PaySubscriptionDeleteReply (271)
#endif

/* ns2__PaySubscriptionRetrieveReply has binding name 'ns2__PaySubscriptionRetrieveReply' for type 'ns2:PaySubscriptionRetrieveReply' */
#ifndef SOAP_TYPE_ns2__PaySubscriptionRetrieveReply
#define SOAP_TYPE_ns2__PaySubscriptionRetrieveReply (270)
#endif

/* ns2__PaySubscriptionEventUpdateReply has binding name 'ns2__PaySubscriptionEventUpdateReply' for type 'ns2:PaySubscriptionEventUpdateReply' */
#ifndef SOAP_TYPE_ns2__PaySubscriptionEventUpdateReply
#define SOAP_TYPE_ns2__PaySubscriptionEventUpdateReply (269)
#endif

/* ns2__PaySubscriptionUpdateReply has binding name 'ns2__PaySubscriptionUpdateReply' for type 'ns2:PaySubscriptionUpdateReply' */
#ifndef SOAP_TYPE_ns2__PaySubscriptionUpdateReply
#define SOAP_TYPE_ns2__PaySubscriptionUpdateReply (268)
#endif

/* ns2__PaySubscriptionCreateReply has binding name 'ns2__PaySubscriptionCreateReply' for type 'ns2:PaySubscriptionCreateReply' */
#ifndef SOAP_TYPE_ns2__PaySubscriptionCreateReply
#define SOAP_TYPE_ns2__PaySubscriptionCreateReply (267)
#endif

/* ns2__DirectDebitRefundReply has binding name 'ns2__DirectDebitRefundReply' for type 'ns2:DirectDebitRefundReply' */
#ifndef SOAP_TYPE_ns2__DirectDebitRefundReply
#define SOAP_TYPE_ns2__DirectDebitRefundReply (266)
#endif

/* ns2__DirectDebitValidateReply has binding name 'ns2__DirectDebitValidateReply' for type 'ns2:DirectDebitValidateReply' */
#ifndef SOAP_TYPE_ns2__DirectDebitValidateReply
#define SOAP_TYPE_ns2__DirectDebitValidateReply (265)
#endif

/* ns2__DirectDebitReply has binding name 'ns2__DirectDebitReply' for type 'ns2:DirectDebitReply' */
#ifndef SOAP_TYPE_ns2__DirectDebitReply
#define SOAP_TYPE_ns2__DirectDebitReply (264)
#endif

/* ns2__BankTransferRefundReply has binding name 'ns2__BankTransferRefundReply' for type 'ns2:BankTransferRefundReply' */
#ifndef SOAP_TYPE_ns2__BankTransferRefundReply
#define SOAP_TYPE_ns2__BankTransferRefundReply (263)
#endif

/* ns2__DirectDebitMandateReply has binding name 'ns2__DirectDebitMandateReply' for type 'ns2:DirectDebitMandateReply' */
#ifndef SOAP_TYPE_ns2__DirectDebitMandateReply
#define SOAP_TYPE_ns2__DirectDebitMandateReply (262)
#endif

/* ns2__BankTransferRealTimeReply has binding name 'ns2__BankTransferRealTimeReply' for type 'ns2:BankTransferRealTimeReply' */
#ifndef SOAP_TYPE_ns2__BankTransferRealTimeReply
#define SOAP_TYPE_ns2__BankTransferRealTimeReply (261)
#endif

/* ns2__BankTransferReply has binding name 'ns2__BankTransferReply' for type 'ns2:BankTransferReply' */
#ifndef SOAP_TYPE_ns2__BankTransferReply
#define SOAP_TYPE_ns2__BankTransferReply (260)
#endif

/* ns2__FXRatesReply has binding name 'ns2__FXRatesReply' for type 'ns2:FXRatesReply' */
#ifndef SOAP_TYPE_ns2__FXRatesReply
#define SOAP_TYPE_ns2__FXRatesReply (259)
#endif

/* ns2__FXQuote has binding name 'ns2__FXQuote' for type 'ns2:FXQuote' */
#ifndef SOAP_TYPE_ns2__FXQuote
#define SOAP_TYPE_ns2__FXQuote (258)
#endif

/* ns2__ExportReply has binding name 'ns2__ExportReply' for type 'ns2:ExportReply' */
#ifndef SOAP_TYPE_ns2__ExportReply
#define SOAP_TYPE_ns2__ExportReply (257)
#endif

/* ns2__DeniedPartiesMatch has binding name 'ns2__DeniedPartiesMatch' for type 'ns2:DeniedPartiesMatch' */
#ifndef SOAP_TYPE_ns2__DeniedPartiesMatch
#define SOAP_TYPE_ns2__DeniedPartiesMatch (256)
#endif

/* ns2__DAVReply has binding name 'ns2__DAVReply' for type 'ns2:DAVReply' */
#ifndef SOAP_TYPE_ns2__DAVReply
#define SOAP_TYPE_ns2__DAVReply (255)
#endif

/* ns2__AFSReply has binding name 'ns2__AFSReply' for type 'ns2:AFSReply' */
#ifndef SOAP_TYPE_ns2__AFSReply
#define SOAP_TYPE_ns2__AFSReply (254)
#endif

/* ns2__DeviceFingerprint has binding name 'ns2__DeviceFingerprint' for type 'ns2:DeviceFingerprint' */
#ifndef SOAP_TYPE_ns2__DeviceFingerprint
#define SOAP_TYPE_ns2__DeviceFingerprint (253)
#endif

/* ns2__TaxReply has binding name 'ns2__TaxReply' for type 'ns2:TaxReply' */
#ifndef SOAP_TYPE_ns2__TaxReply
#define SOAP_TYPE_ns2__TaxReply (252)
#endif

/* ns2__TaxReplyItem has binding name 'ns2__TaxReplyItem' for type 'ns2:TaxReplyItem' */
#ifndef SOAP_TYPE_ns2__TaxReplyItem
#define SOAP_TYPE_ns2__TaxReplyItem (251)
#endif

/* ns2__PayerAuthValidateReply has binding name 'ns2__PayerAuthValidateReply' for type 'ns2:PayerAuthValidateReply' */
#ifndef SOAP_TYPE_ns2__PayerAuthValidateReply
#define SOAP_TYPE_ns2__PayerAuthValidateReply (250)
#endif

/* ns2__PayerAuthEnrollReply has binding name 'ns2__PayerAuthEnrollReply' for type 'ns2:PayerAuthEnrollReply' */
#ifndef SOAP_TYPE_ns2__PayerAuthEnrollReply
#define SOAP_TYPE_ns2__PayerAuthEnrollReply (249)
#endif

/* ns2__ECAuthenticateReply has binding name 'ns2__ECAuthenticateReply' for type 'ns2:ECAuthenticateReply' */
#ifndef SOAP_TYPE_ns2__ECAuthenticateReply
#define SOAP_TYPE_ns2__ECAuthenticateReply (248)
#endif

/* ns2__ECCreditReply has binding name 'ns2__ECCreditReply' for type 'ns2:ECCreditReply' */
#ifndef SOAP_TYPE_ns2__ECCreditReply
#define SOAP_TYPE_ns2__ECCreditReply (247)
#endif

/* ns2__ECDebitReply has binding name 'ns2__ECDebitReply' for type 'ns2:ECDebitReply' */
#ifndef SOAP_TYPE_ns2__ECDebitReply
#define SOAP_TYPE_ns2__ECDebitReply (246)
#endif

/* ns2__CCAutoAuthReversalReply has binding name 'ns2__CCAutoAuthReversalReply' for type 'ns2:CCAutoAuthReversalReply' */
#ifndef SOAP_TYPE_ns2__CCAutoAuthReversalReply
#define SOAP_TYPE_ns2__CCAutoAuthReversalReply (245)
#endif

/* ns2__CCAuthReversalReply has binding name 'ns2__CCAuthReversalReply' for type 'ns2:CCAuthReversalReply' */
#ifndef SOAP_TYPE_ns2__CCAuthReversalReply
#define SOAP_TYPE_ns2__CCAuthReversalReply (244)
#endif

/* ns2__PinDebitReversalReply has binding name 'ns2__PinDebitReversalReply' for type 'ns2:PinDebitReversalReply' */
#ifndef SOAP_TYPE_ns2__PinDebitReversalReply
#define SOAP_TYPE_ns2__PinDebitReversalReply (243)
#endif

/* ns2__PinDebitCreditReply has binding name 'ns2__PinDebitCreditReply' for type 'ns2:PinDebitCreditReply' */
#ifndef SOAP_TYPE_ns2__PinDebitCreditReply
#define SOAP_TYPE_ns2__PinDebitCreditReply (242)
#endif

/* ns2__PinDebitPurchaseReply has binding name 'ns2__PinDebitPurchaseReply' for type 'ns2:PinDebitPurchaseReply' */
#ifndef SOAP_TYPE_ns2__PinDebitPurchaseReply
#define SOAP_TYPE_ns2__PinDebitPurchaseReply (241)
#endif

/* ns2__CCCreditReply has binding name 'ns2__CCCreditReply' for type 'ns2:CCCreditReply' */
#ifndef SOAP_TYPE_ns2__CCCreditReply
#define SOAP_TYPE_ns2__CCCreditReply (240)
#endif

/* ns2__ServiceFeeCalculateReply has binding name 'ns2__ServiceFeeCalculateReply' for type 'ns2:ServiceFeeCalculateReply' */
#ifndef SOAP_TYPE_ns2__ServiceFeeCalculateReply
#define SOAP_TYPE_ns2__ServiceFeeCalculateReply (239)
#endif

/* ns2__CCCaptureReply has binding name 'ns2__CCCaptureReply' for type 'ns2:CCCaptureReply' */
#ifndef SOAP_TYPE_ns2__CCCaptureReply
#define SOAP_TYPE_ns2__CCCaptureReply (238)
#endif

/* ns2__CCIncrementalAuthReply has binding name 'ns2__CCIncrementalAuthReply' for type 'ns2:CCIncrementalAuthReply' */
#ifndef SOAP_TYPE_ns2__CCIncrementalAuthReply
#define SOAP_TYPE_ns2__CCIncrementalAuthReply (237)
#endif

/* ns2__CCSaleReversalReply has binding name 'ns2__CCSaleReversalReply' for type 'ns2:CCSaleReversalReply' */
#ifndef SOAP_TYPE_ns2__CCSaleReversalReply
#define SOAP_TYPE_ns2__CCSaleReversalReply (236)
#endif

/* ns2__CCSaleCreditReply has binding name 'ns2__CCSaleCreditReply' for type 'ns2:CCSaleCreditReply' */
#ifndef SOAP_TYPE_ns2__CCSaleCreditReply
#define SOAP_TYPE_ns2__CCSaleCreditReply (235)
#endif

/* ns2__CCSaleReply has binding name 'ns2__CCSaleReply' for type 'ns2:CCSaleReply' */
#ifndef SOAP_TYPE_ns2__CCSaleReply
#define SOAP_TYPE_ns2__CCSaleReply (234)
#endif

/* ns2__VerificationReply has binding name 'ns2__VerificationReply' for type 'ns2:VerificationReply' */
#ifndef SOAP_TYPE_ns2__VerificationReply
#define SOAP_TYPE_ns2__VerificationReply (233)
#endif

/* ns2__OCTReply has binding name 'ns2__OCTReply' for type 'ns2:OCTReply' */
#ifndef SOAP_TYPE_ns2__OCTReply
#define SOAP_TYPE_ns2__OCTReply (232)
#endif

/* ns2__CCAuthReply has binding name 'ns2__CCAuthReply' for type 'ns2:CCAuthReply' */
#ifndef SOAP_TYPE_ns2__CCAuthReply
#define SOAP_TYPE_ns2__CCAuthReply (231)
#endif

/* ns2__PromotionGroupReply has binding name 'ns2__PromotionGroupReply' for type 'ns2:PromotionGroupReply' */
#ifndef SOAP_TYPE_ns2__PromotionGroupReply
#define SOAP_TYPE_ns2__PromotionGroupReply (230)
#endif

/* ns2__PromotionGroup has binding name 'ns2__PromotionGroup' for type 'ns2:PromotionGroup' */
#ifndef SOAP_TYPE_ns2__PromotionGroup
#define SOAP_TYPE_ns2__PromotionGroup (229)
#endif

/* ns2__Promotion has binding name 'ns2__Promotion' for type 'ns2:Promotion' */
#ifndef SOAP_TYPE_ns2__Promotion
#define SOAP_TYPE_ns2__Promotion (228)
#endif

/* ns2__DCC has binding name 'ns2__DCC' for type 'ns2:DCC' */
#ifndef SOAP_TYPE_ns2__DCC
#define SOAP_TYPE_ns2__DCC (227)
#endif

/* ns2__DecryptVisaCheckoutDataService has binding name 'ns2__DecryptVisaCheckoutDataService' for type 'ns2:DecryptVisaCheckoutDataService' */
#ifndef SOAP_TYPE_ns2__DecryptVisaCheckoutDataService
#define SOAP_TYPE_ns2__DecryptVisaCheckoutDataService (226)
#endif

/* ns2__VC has binding name 'ns2__VC' for type 'ns2:VC' */
#ifndef SOAP_TYPE_ns2__VC
#define SOAP_TYPE_ns2__VC (225)
#endif

/* ns2__RequestMessage has binding name 'ns2__RequestMessage' for type 'ns2:RequestMessage' */
#ifndef SOAP_TYPE_ns2__RequestMessage
#define SOAP_TYPE_ns2__RequestMessage (224)
#endif

/* ns2__Sender has binding name 'ns2__Sender' for type 'ns2:Sender' */
#ifndef SOAP_TYPE_ns2__Sender
#define SOAP_TYPE_ns2__Sender (223)
#endif

/* ns2__Recipient has binding name 'ns2__Recipient' for type 'ns2:Recipient' */
#ifndef SOAP_TYPE_ns2__Recipient
#define SOAP_TYPE_ns2__Recipient (222)
#endif

/* ns2__PayPalTransactionSearchService has binding name 'ns2__PayPalTransactionSearchService' for type 'ns2:PayPalTransactionSearchService' */
#ifndef SOAP_TYPE_ns2__PayPalTransactionSearchService
#define SOAP_TYPE_ns2__PayPalTransactionSearchService (221)
#endif

/* ns2__PayPalGetTxnDetailsService has binding name 'ns2__PayPalGetTxnDetailsService' for type 'ns2:PayPalGetTxnDetailsService' */
#ifndef SOAP_TYPE_ns2__PayPalGetTxnDetailsService
#define SOAP_TYPE_ns2__PayPalGetTxnDetailsService (220)
#endif

/* ns2__APConfirmPurchaseService has binding name 'ns2__APConfirmPurchaseService' for type 'ns2:APConfirmPurchaseService' */
#ifndef SOAP_TYPE_ns2__APConfirmPurchaseService
#define SOAP_TYPE_ns2__APConfirmPurchaseService (219)
#endif

/* ns2__APTransactionDetailsService has binding name 'ns2__APTransactionDetailsService' for type 'ns2:APTransactionDetailsService' */
#ifndef SOAP_TYPE_ns2__APTransactionDetailsService
#define SOAP_TYPE_ns2__APTransactionDetailsService (218)
#endif

/* ns2__APCheckOutDetailsService has binding name 'ns2__APCheckOutDetailsService' for type 'ns2:APCheckOutDetailsService' */
#ifndef SOAP_TYPE_ns2__APCheckOutDetailsService
#define SOAP_TYPE_ns2__APCheckOutDetailsService (217)
#endif

/* ns2__APSaleService has binding name 'ns2__APSaleService' for type 'ns2:APSaleService' */
#ifndef SOAP_TYPE_ns2__APSaleService
#define SOAP_TYPE_ns2__APSaleService (216)
#endif

/* ns2__APRefundService has binding name 'ns2__APRefundService' for type 'ns2:APRefundService' */
#ifndef SOAP_TYPE_ns2__APRefundService
#define SOAP_TYPE_ns2__APRefundService (215)
#endif

/* ns2__APOptionsService has binding name 'ns2__APOptionsService' for type 'ns2:APOptionsService' */
#ifndef SOAP_TYPE_ns2__APOptionsService
#define SOAP_TYPE_ns2__APOptionsService (214)
#endif

/* ns2__APCaptureService has binding name 'ns2__APCaptureService' for type 'ns2:APCaptureService' */
#ifndef SOAP_TYPE_ns2__APCaptureService
#define SOAP_TYPE_ns2__APCaptureService (213)
#endif

/* ns2__APAuthReversalService has binding name 'ns2__APAuthReversalService' for type 'ns2:APAuthReversalService' */
#ifndef SOAP_TYPE_ns2__APAuthReversalService
#define SOAP_TYPE_ns2__APAuthReversalService (212)
#endif

/* ns2__APAuthService has binding name 'ns2__APAuthService' for type 'ns2:APAuthService' */
#ifndef SOAP_TYPE_ns2__APAuthService
#define SOAP_TYPE_ns2__APAuthService (211)
#endif

/* ns2__APDevice has binding name 'ns2__APDevice' for type 'ns2:APDevice' */
#ifndef SOAP_TYPE_ns2__APDevice
#define SOAP_TYPE_ns2__APDevice (210)
#endif

/* ns2__AP has binding name 'ns2__AP' for type 'ns2:AP' */
#ifndef SOAP_TYPE_ns2__AP
#define SOAP_TYPE_ns2__AP (209)
#endif

/* ns2__Token has binding name 'ns2__Token' for type 'ns2:Token' */
#ifndef SOAP_TYPE_ns2__Token
#define SOAP_TYPE_ns2__Token (208)
#endif

/* ns2__JPO has binding name 'ns2__JPO' for type 'ns2:JPO' */
#ifndef SOAP_TYPE_ns2__JPO
#define SOAP_TYPE_ns2__JPO (207)
#endif

/* ns2__PayPal has binding name 'ns2__PayPal' for type 'ns2:PayPal' */
#ifndef SOAP_TYPE_ns2__PayPal
#define SOAP_TYPE_ns2__PayPal (206)
#endif

/* ns2__Batch has binding name 'ns2__Batch' for type 'ns2:Batch' */
#ifndef SOAP_TYPE_ns2__Batch
#define SOAP_TYPE_ns2__Batch (205)
#endif

/* ns2__DecisionManagerTravelLeg has binding name 'ns2__DecisionManagerTravelLeg' for type 'ns2:DecisionManagerTravelLeg' */
#ifndef SOAP_TYPE_ns2__DecisionManagerTravelLeg
#define SOAP_TYPE_ns2__DecisionManagerTravelLeg (204)
#endif

/* ns2__DecisionManagerTravelData has binding name 'ns2__DecisionManagerTravelData' for type 'ns2:DecisionManagerTravelData' */
#ifndef SOAP_TYPE_ns2__DecisionManagerTravelData
#define SOAP_TYPE_ns2__DecisionManagerTravelData (203)
#endif

/* ns2__DecisionManager has binding name 'ns2__DecisionManager' for type 'ns2:DecisionManager' */
#ifndef SOAP_TYPE_ns2__DecisionManager
#define SOAP_TYPE_ns2__DecisionManager (202)
#endif

/* ns2__PaymentNetworkToken has binding name 'ns2__PaymentNetworkToken' for type 'ns2:PaymentNetworkToken' */
#ifndef SOAP_TYPE_ns2__PaymentNetworkToken
#define SOAP_TYPE_ns2__PaymentNetworkToken (201)
#endif

/* ns2__Subscription has binding name 'ns2__Subscription' for type 'ns2:Subscription' */
#ifndef SOAP_TYPE_ns2__Subscription
#define SOAP_TYPE_ns2__Subscription (200)
#endif

/* ns2__PaySubscriptionEvent has binding name 'ns2__PaySubscriptionEvent' for type 'ns2:PaySubscriptionEvent' */
#ifndef SOAP_TYPE_ns2__PaySubscriptionEvent
#define SOAP_TYPE_ns2__PaySubscriptionEvent (199)
#endif

/* ns2__RecurringSubscriptionInfo has binding name 'ns2__RecurringSubscriptionInfo' for type 'ns2:RecurringSubscriptionInfo' */
#ifndef SOAP_TYPE_ns2__RecurringSubscriptionInfo
#define SOAP_TYPE_ns2__RecurringSubscriptionInfo (198)
#endif

/* ns2__BankInfo has binding name 'ns2__BankInfo' for type 'ns2:BankInfo' */
#ifndef SOAP_TYPE_ns2__BankInfo
#define SOAP_TYPE_ns2__BankInfo (197)
#endif

/* ns2__FundTransfer has binding name 'ns2__FundTransfer' for type 'ns2:FundTransfer' */
#ifndef SOAP_TYPE_ns2__FundTransfer
#define SOAP_TYPE_ns2__FundTransfer (196)
#endif

/* ns2__UCAF has binding name 'ns2__UCAF' for type 'ns2:UCAF' */
#ifndef SOAP_TYPE_ns2__UCAF
#define SOAP_TYPE_ns2__UCAF (195)
#endif

/* ns2__GECC has binding name 'ns2__GECC' for type 'ns2:GECC' */
#ifndef SOAP_TYPE_ns2__GECC
#define SOAP_TYPE_ns2__GECC (194)
#endif

/* ns2__FundingTotals has binding name 'ns2__FundingTotals' for type 'ns2:FundingTotals' */
#ifndef SOAP_TYPE_ns2__FundingTotals
#define SOAP_TYPE_ns2__FundingTotals (193)
#endif

/* ns2__PurchaseTotals has binding name 'ns2__PurchaseTotals' for type 'ns2:PurchaseTotals' */
#ifndef SOAP_TYPE_ns2__PurchaseTotals
#define SOAP_TYPE_ns2__PurchaseTotals (192)
#endif

/* ns2__Wallet has binding name 'ns2__Wallet' for type 'ns2:Wallet' */
#ifndef SOAP_TYPE_ns2__Wallet
#define SOAP_TYPE_ns2__Wallet (191)
#endif

/* ns2__Aft has binding name 'ns2__Aft' for type 'ns2:Aft' */
#ifndef SOAP_TYPE_ns2__Aft
#define SOAP_TYPE_ns2__Aft (190)
#endif

/* ns2__OtherTax has binding name 'ns2__OtherTax' for type 'ns2:OtherTax' */
#ifndef SOAP_TYPE_ns2__OtherTax
#define SOAP_TYPE_ns2__OtherTax (189)
#endif

/* ns2__BML has binding name 'ns2__BML' for type 'ns2:BML' */
#ifndef SOAP_TYPE_ns2__BML
#define SOAP_TYPE_ns2__BML (188)
#endif

/* ns2__Check has binding name 'ns2__Check' for type 'ns2:Check' */
#ifndef SOAP_TYPE_ns2__Check
#define SOAP_TYPE_ns2__Check (187)
#endif

/* ns2__Card has binding name 'ns2__Card' for type 'ns2:Card' */
#ifndef SOAP_TYPE_ns2__Card
#define SOAP_TYPE_ns2__Card (186)
#endif

/* ns2__ShipFrom has binding name 'ns2__ShipFrom' for type 'ns2:ShipFrom' */
#ifndef SOAP_TYPE_ns2__ShipFrom
#define SOAP_TYPE_ns2__ShipFrom (185)
#endif

/* ns2__ShipTo has binding name 'ns2__ShipTo' for type 'ns2:ShipTo' */
#ifndef SOAP_TYPE_ns2__ShipTo
#define SOAP_TYPE_ns2__ShipTo (184)
#endif

/* ns2__BillTo has binding name 'ns2__BillTo' for type 'ns2:BillTo' */
#ifndef SOAP_TYPE_ns2__BillTo
#define SOAP_TYPE_ns2__BillTo (183)
#endif

/* ns2__BusinessRules has binding name 'ns2__BusinessRules' for type 'ns2:BusinessRules' */
#ifndef SOAP_TYPE_ns2__BusinessRules
#define SOAP_TYPE_ns2__BusinessRules (182)
#endif

/* ns2__InvoiceHeader has binding name 'ns2__InvoiceHeader' for type 'ns2:InvoiceHeader' */
#ifndef SOAP_TYPE_ns2__InvoiceHeader
#define SOAP_TYPE_ns2__InvoiceHeader (181)
#endif

/* ns2__EncryptPaymentDataService has binding name 'ns2__EncryptPaymentDataService' for type 'ns2:EncryptPaymentDataService' */
#ifndef SOAP_TYPE_ns2__EncryptPaymentDataService
#define SOAP_TYPE_ns2__EncryptPaymentDataService (180)
#endif

/* ns2__CaseManagementActionService has binding name 'ns2__CaseManagementActionService' for type 'ns2:CaseManagementActionService' */
#ifndef SOAP_TYPE_ns2__CaseManagementActionService
#define SOAP_TYPE_ns2__CaseManagementActionService (179)
#endif

/* ns2__FraudUpdateService has binding name 'ns2__FraudUpdateService' for type 'ns2:FraudUpdateService' */
#ifndef SOAP_TYPE_ns2__FraudUpdateService
#define SOAP_TYPE_ns2__FraudUpdateService (178)
#endif

/* ns2__RiskUpdateService has binding name 'ns2__RiskUpdateService' for type 'ns2:RiskUpdateService' */
#ifndef SOAP_TYPE_ns2__RiskUpdateService
#define SOAP_TYPE_ns2__RiskUpdateService (177)
#endif

/* ns2__APCheckStatusService has binding name 'ns2__APCheckStatusService' for type 'ns2:APCheckStatusService' */
#ifndef SOAP_TYPE_ns2__APCheckStatusService
#define SOAP_TYPE_ns2__APCheckStatusService (176)
#endif

/* ns2__APInitiateService has binding name 'ns2__APInitiateService' for type 'ns2:APInitiateService' */
#ifndef SOAP_TYPE_ns2__APInitiateService
#define SOAP_TYPE_ns2__APInitiateService (175)
#endif

/* ns2__Address has binding name 'ns2__Address' for type 'ns2:Address' */
#ifndef SOAP_TYPE_ns2__Address
#define SOAP_TYPE_ns2__Address (174)
#endif

/* ns2__PersonalId has binding name 'ns2__PersonalId' for type 'ns2:PersonalId' */
#ifndef SOAP_TYPE_ns2__PersonalId
#define SOAP_TYPE_ns2__PersonalId (173)
#endif

/* ns2__BoletoPaymentService has binding name 'ns2__BoletoPaymentService' for type 'ns2:BoletoPaymentService' */
#ifndef SOAP_TYPE_ns2__BoletoPaymentService
#define SOAP_TYPE_ns2__BoletoPaymentService (172)
#endif

/* ns2__ChinaRefundService has binding name 'ns2__ChinaRefundService' for type 'ns2:ChinaRefundService' */
#ifndef SOAP_TYPE_ns2__ChinaRefundService
#define SOAP_TYPE_ns2__ChinaRefundService (171)
#endif

/* ns2__ChinaPaymentService has binding name 'ns2__ChinaPaymentService' for type 'ns2:ChinaPaymentService' */
#ifndef SOAP_TYPE_ns2__ChinaPaymentService
#define SOAP_TYPE_ns2__ChinaPaymentService (170)
#endif

/* ns2__PayPalPreapprovedUpdateService has binding name 'ns2__PayPalPreapprovedUpdateService' for type 'ns2:PayPalPreapprovedUpdateService' */
#ifndef SOAP_TYPE_ns2__PayPalPreapprovedUpdateService
#define SOAP_TYPE_ns2__PayPalPreapprovedUpdateService (169)
#endif

/* ns2__PayPalPreapprovedPaymentService has binding name 'ns2__PayPalPreapprovedPaymentService' for type 'ns2:PayPalPreapprovedPaymentService' */
#ifndef SOAP_TYPE_ns2__PayPalPreapprovedPaymentService
#define SOAP_TYPE_ns2__PayPalPreapprovedPaymentService (168)
#endif

/* ns2__PayPalButtonCreateService has binding name 'ns2__PayPalButtonCreateService' for type 'ns2:PayPalButtonCreateService' */
#ifndef SOAP_TYPE_ns2__PayPalButtonCreateService
#define SOAP_TYPE_ns2__PayPalButtonCreateService (167)
#endif

/* ns2__PinDebitReversalService has binding name 'ns2__PinDebitReversalService' for type 'ns2:PinDebitReversalService' */
#ifndef SOAP_TYPE_ns2__PinDebitReversalService
#define SOAP_TYPE_ns2__PinDebitReversalService (166)
#endif

/* ns2__PinDebitCreditService has binding name 'ns2__PinDebitCreditService' for type 'ns2:PinDebitCreditService' */
#ifndef SOAP_TYPE_ns2__PinDebitCreditService
#define SOAP_TYPE_ns2__PinDebitCreditService (165)
#endif

/* ns2__PinDebitPurchaseService has binding name 'ns2__PinDebitPurchaseService' for type 'ns2:PinDebitPurchaseService' */
#ifndef SOAP_TYPE_ns2__PinDebitPurchaseService
#define SOAP_TYPE_ns2__PinDebitPurchaseService (164)
#endif

/* ns2__PinlessDebitReversalService has binding name 'ns2__PinlessDebitReversalService' for type 'ns2:PinlessDebitReversalService' */
#ifndef SOAP_TYPE_ns2__PinlessDebitReversalService
#define SOAP_TYPE_ns2__PinlessDebitReversalService (163)
#endif

/* ns2__PinlessDebitValidateService has binding name 'ns2__PinlessDebitValidateService' for type 'ns2:PinlessDebitValidateService' */
#ifndef SOAP_TYPE_ns2__PinlessDebitValidateService
#define SOAP_TYPE_ns2__PinlessDebitValidateService (162)
#endif

/* ns2__PinlessDebitService has binding name 'ns2__PinlessDebitService' for type 'ns2:PinlessDebitService' */
#ifndef SOAP_TYPE_ns2__PinlessDebitService
#define SOAP_TYPE_ns2__PinlessDebitService (161)
#endif

/* ns2__VoidService has binding name 'ns2__VoidService' for type 'ns2:VoidService' */
#ifndef SOAP_TYPE_ns2__VoidService
#define SOAP_TYPE_ns2__VoidService (160)
#endif

/* ns2__PayPalDoRefTransactionService has binding name 'ns2__PayPalDoRefTransactionService' for type 'ns2:PayPalDoRefTransactionService' */
#ifndef SOAP_TYPE_ns2__PayPalDoRefTransactionService
#define SOAP_TYPE_ns2__PayPalDoRefTransactionService (159)
#endif

/* ns2__PayPalCreateAgreementService has binding name 'ns2__PayPalCreateAgreementService' for type 'ns2:PayPalCreateAgreementService' */
#ifndef SOAP_TYPE_ns2__PayPalCreateAgreementService
#define SOAP_TYPE_ns2__PayPalCreateAgreementService (158)
#endif

/* ns2__PayPalUpdateAgreementService has binding name 'ns2__PayPalUpdateAgreementService' for type 'ns2:PayPalUpdateAgreementService' */
#ifndef SOAP_TYPE_ns2__PayPalUpdateAgreementService
#define SOAP_TYPE_ns2__PayPalUpdateAgreementService (157)
#endif

/* ns2__PayPalAuthorizationService has binding name 'ns2__PayPalAuthorizationService' for type 'ns2:PayPalAuthorizationService' */
#ifndef SOAP_TYPE_ns2__PayPalAuthorizationService
#define SOAP_TYPE_ns2__PayPalAuthorizationService (156)
#endif

/* ns2__PayPalEcOrderSetupService has binding name 'ns2__PayPalEcOrderSetupService' for type 'ns2:PayPalEcOrderSetupService' */
#ifndef SOAP_TYPE_ns2__PayPalEcOrderSetupService
#define SOAP_TYPE_ns2__PayPalEcOrderSetupService (155)
#endif

/* ns2__PayPalRefundService has binding name 'ns2__PayPalRefundService' for type 'ns2:PayPalRefundService' */
#ifndef SOAP_TYPE_ns2__PayPalRefundService
#define SOAP_TYPE_ns2__PayPalRefundService (154)
#endif

/* ns2__PayPalAuthReversalService has binding name 'ns2__PayPalAuthReversalService' for type 'ns2:PayPalAuthReversalService' */
#ifndef SOAP_TYPE_ns2__PayPalAuthReversalService
#define SOAP_TYPE_ns2__PayPalAuthReversalService (153)
#endif

/* ns2__PayPalDoCaptureService has binding name 'ns2__PayPalDoCaptureService' for type 'ns2:PayPalDoCaptureService' */
#ifndef SOAP_TYPE_ns2__PayPalDoCaptureService
#define SOAP_TYPE_ns2__PayPalDoCaptureService (152)
#endif

/* ns2__PayPalEcDoPaymentService has binding name 'ns2__PayPalEcDoPaymentService' for type 'ns2:PayPalEcDoPaymentService' */
#ifndef SOAP_TYPE_ns2__PayPalEcDoPaymentService
#define SOAP_TYPE_ns2__PayPalEcDoPaymentService (151)
#endif

/* ns2__PayPalEcGetDetailsService has binding name 'ns2__PayPalEcGetDetailsService' for type 'ns2:PayPalEcGetDetailsService' */
#ifndef SOAP_TYPE_ns2__PayPalEcGetDetailsService
#define SOAP_TYPE_ns2__PayPalEcGetDetailsService (150)
#endif

/* ns2__PayPalEcSetService has binding name 'ns2__PayPalEcSetService' for type 'ns2:PayPalEcSetService' */
#ifndef SOAP_TYPE_ns2__PayPalEcSetService
#define SOAP_TYPE_ns2__PayPalEcSetService (149)
#endif

/* ns2__PayPalCreditService has binding name 'ns2__PayPalCreditService' for type 'ns2:PayPalCreditService' */
#ifndef SOAP_TYPE_ns2__PayPalCreditService
#define SOAP_TYPE_ns2__PayPalCreditService (148)
#endif

/* ns2__PayPalPaymentService has binding name 'ns2__PayPalPaymentService' for type 'ns2:PayPalPaymentService' */
#ifndef SOAP_TYPE_ns2__PayPalPaymentService
#define SOAP_TYPE_ns2__PayPalPaymentService (147)
#endif

/* ns2__PaySubscriptionDeleteService has binding name 'ns2__PaySubscriptionDeleteService' for type 'ns2:PaySubscriptionDeleteService' */
#ifndef SOAP_TYPE_ns2__PaySubscriptionDeleteService
#define SOAP_TYPE_ns2__PaySubscriptionDeleteService (146)
#endif

/* ns2__PaySubscriptionRetrieveService has binding name 'ns2__PaySubscriptionRetrieveService' for type 'ns2:PaySubscriptionRetrieveService' */
#ifndef SOAP_TYPE_ns2__PaySubscriptionRetrieveService
#define SOAP_TYPE_ns2__PaySubscriptionRetrieveService (145)
#endif

/* ns2__PaySubscriptionEventUpdateService has binding name 'ns2__PaySubscriptionEventUpdateService' for type 'ns2:PaySubscriptionEventUpdateService' */
#ifndef SOAP_TYPE_ns2__PaySubscriptionEventUpdateService
#define SOAP_TYPE_ns2__PaySubscriptionEventUpdateService (144)
#endif

/* ns2__PaySubscriptionUpdateService has binding name 'ns2__PaySubscriptionUpdateService' for type 'ns2:PaySubscriptionUpdateService' */
#ifndef SOAP_TYPE_ns2__PaySubscriptionUpdateService
#define SOAP_TYPE_ns2__PaySubscriptionUpdateService (143)
#endif

/* ns2__PaySubscriptionCreateService has binding name 'ns2__PaySubscriptionCreateService' for type 'ns2:PaySubscriptionCreateService' */
#ifndef SOAP_TYPE_ns2__PaySubscriptionCreateService
#define SOAP_TYPE_ns2__PaySubscriptionCreateService (142)
#endif

/* ns2__DirectDebitValidateService has binding name 'ns2__DirectDebitValidateService' for type 'ns2:DirectDebitValidateService' */
#ifndef SOAP_TYPE_ns2__DirectDebitValidateService
#define SOAP_TYPE_ns2__DirectDebitValidateService (141)
#endif

/* ns2__DirectDebitRefundService has binding name 'ns2__DirectDebitRefundService' for type 'ns2:DirectDebitRefundService' */
#ifndef SOAP_TYPE_ns2__DirectDebitRefundService
#define SOAP_TYPE_ns2__DirectDebitRefundService (140)
#endif

/* ns2__DirectDebitService has binding name 'ns2__DirectDebitService' for type 'ns2:DirectDebitService' */
#ifndef SOAP_TYPE_ns2__DirectDebitService
#define SOAP_TYPE_ns2__DirectDebitService (139)
#endif

/* ns2__DirectDebitMandateService has binding name 'ns2__DirectDebitMandateService' for type 'ns2:DirectDebitMandateService' */
#ifndef SOAP_TYPE_ns2__DirectDebitMandateService
#define SOAP_TYPE_ns2__DirectDebitMandateService (138)
#endif

/* ns2__BankTransferRealTimeService has binding name 'ns2__BankTransferRealTimeService' for type 'ns2:BankTransferRealTimeService' */
#ifndef SOAP_TYPE_ns2__BankTransferRealTimeService
#define SOAP_TYPE_ns2__BankTransferRealTimeService (137)
#endif

/* ns2__BankTransferRefundService has binding name 'ns2__BankTransferRefundService' for type 'ns2:BankTransferRefundService' */
#ifndef SOAP_TYPE_ns2__BankTransferRefundService
#define SOAP_TYPE_ns2__BankTransferRefundService (136)
#endif

/* ns2__BankTransferService has binding name 'ns2__BankTransferService' for type 'ns2:BankTransferService' */
#ifndef SOAP_TYPE_ns2__BankTransferService
#define SOAP_TYPE_ns2__BankTransferService (135)
#endif

/* ns2__FXRatesService has binding name 'ns2__FXRatesService' for type 'ns2:FXRatesService' */
#ifndef SOAP_TYPE_ns2__FXRatesService
#define SOAP_TYPE_ns2__FXRatesService (134)
#endif

/* ns2__ExportService has binding name 'ns2__ExportService' for type 'ns2:ExportService' */
#ifndef SOAP_TYPE_ns2__ExportService
#define SOAP_TYPE_ns2__ExportService (133)
#endif

/* ns2__DAVService has binding name 'ns2__DAVService' for type 'ns2:DAVService' */
#ifndef SOAP_TYPE_ns2__DAVService
#define SOAP_TYPE_ns2__DAVService (132)
#endif

/* ns2__AFSService has binding name 'ns2__AFSService' for type 'ns2:AFSService' */
#ifndef SOAP_TYPE_ns2__AFSService
#define SOAP_TYPE_ns2__AFSService (131)
#endif

/* ns2__DMEService has binding name 'ns2__DMEService' for type 'ns2:DMEService' */
#ifndef SOAP_TYPE_ns2__DMEService
#define SOAP_TYPE_ns2__DMEService (130)
#endif

/* ns2__TaxService has binding name 'ns2__TaxService' for type 'ns2:TaxService' */
#ifndef SOAP_TYPE_ns2__TaxService
#define SOAP_TYPE_ns2__TaxService (129)
#endif

/* ns2__PayerAuthValidateService has binding name 'ns2__PayerAuthValidateService' for type 'ns2:PayerAuthValidateService' */
#ifndef SOAP_TYPE_ns2__PayerAuthValidateService
#define SOAP_TYPE_ns2__PayerAuthValidateService (128)
#endif

/* ns2__PayerAuthEnrollService has binding name 'ns2__PayerAuthEnrollService' for type 'ns2:PayerAuthEnrollService' */
#ifndef SOAP_TYPE_ns2__PayerAuthEnrollService
#define SOAP_TYPE_ns2__PayerAuthEnrollService (127)
#endif

/* ns2__ECAuthenticateService has binding name 'ns2__ECAuthenticateService' for type 'ns2:ECAuthenticateService' */
#ifndef SOAP_TYPE_ns2__ECAuthenticateService
#define SOAP_TYPE_ns2__ECAuthenticateService (126)
#endif

/* ns2__ECCreditService has binding name 'ns2__ECCreditService' for type 'ns2:ECCreditService' */
#ifndef SOAP_TYPE_ns2__ECCreditService
#define SOAP_TYPE_ns2__ECCreditService (125)
#endif

/* ns2__ECDebitService has binding name 'ns2__ECDebitService' for type 'ns2:ECDebitService' */
#ifndef SOAP_TYPE_ns2__ECDebitService
#define SOAP_TYPE_ns2__ECDebitService (124)
#endif

/* ns2__ServiceFeeCalculateService has binding name 'ns2__ServiceFeeCalculateService' for type 'ns2:ServiceFeeCalculateService' */
#ifndef SOAP_TYPE_ns2__ServiceFeeCalculateService
#define SOAP_TYPE_ns2__ServiceFeeCalculateService (123)
#endif

/* ns2__CCDCCService has binding name 'ns2__CCDCCService' for type 'ns2:CCDCCService' */
#ifndef SOAP_TYPE_ns2__CCDCCService
#define SOAP_TYPE_ns2__CCDCCService (122)
#endif

/* ns2__CCAutoAuthReversalService has binding name 'ns2__CCAutoAuthReversalService' for type 'ns2:CCAutoAuthReversalService' */
#ifndef SOAP_TYPE_ns2__CCAutoAuthReversalService
#define SOAP_TYPE_ns2__CCAutoAuthReversalService (121)
#endif

/* ns2__CCAuthReversalService has binding name 'ns2__CCAuthReversalService' for type 'ns2:CCAuthReversalService' */
#ifndef SOAP_TYPE_ns2__CCAuthReversalService
#define SOAP_TYPE_ns2__CCAuthReversalService (120)
#endif

/* ns2__CCCreditService has binding name 'ns2__CCCreditService' for type 'ns2:CCCreditService' */
#ifndef SOAP_TYPE_ns2__CCCreditService
#define SOAP_TYPE_ns2__CCCreditService (119)
#endif

/* ns2__CCCaptureService has binding name 'ns2__CCCaptureService' for type 'ns2:CCCaptureService' */
#ifndef SOAP_TYPE_ns2__CCCaptureService
#define SOAP_TYPE_ns2__CCCaptureService (118)
#endif

/* ns2__CCIncrementalAuthService has binding name 'ns2__CCIncrementalAuthService' for type 'ns2:CCIncrementalAuthService' */
#ifndef SOAP_TYPE_ns2__CCIncrementalAuthService
#define SOAP_TYPE_ns2__CCIncrementalAuthService (117)
#endif

/* ns2__CCSaleReversalService has binding name 'ns2__CCSaleReversalService' for type 'ns2:CCSaleReversalService' */
#ifndef SOAP_TYPE_ns2__CCSaleReversalService
#define SOAP_TYPE_ns2__CCSaleReversalService (116)
#endif

/* ns2__CCSaleCreditService has binding name 'ns2__CCSaleCreditService' for type 'ns2:CCSaleCreditService' */
#ifndef SOAP_TYPE_ns2__CCSaleCreditService
#define SOAP_TYPE_ns2__CCSaleCreditService (115)
#endif

/* ns2__CCSaleService has binding name 'ns2__CCSaleService' for type 'ns2:CCSaleService' */
#ifndef SOAP_TYPE_ns2__CCSaleService
#define SOAP_TYPE_ns2__CCSaleService (114)
#endif

/* ns2__VerificationService has binding name 'ns2__VerificationService' for type 'ns2:VerificationService' */
#ifndef SOAP_TYPE_ns2__VerificationService
#define SOAP_TYPE_ns2__VerificationService (113)
#endif

/* ns2__OCTService has binding name 'ns2__OCTService' for type 'ns2:OCTService' */
#ifndef SOAP_TYPE_ns2__OCTService
#define SOAP_TYPE_ns2__OCTService (112)
#endif

/* ns2__CCAuthService has binding name 'ns2__CCAuthService' for type 'ns2:CCAuthService' */
#ifndef SOAP_TYPE_ns2__CCAuthService
#define SOAP_TYPE_ns2__CCAuthService (111)
#endif

/* ns2__Item has binding name 'ns2__Item' for type 'ns2:Item' */
#ifndef SOAP_TYPE_ns2__Item
#define SOAP_TYPE_ns2__Item (110)
#endif

/* xsd__integer has binding name 'xsd__integer' for type 'xsd:integer' */
#ifndef SOAP_TYPE_xsd__integer
#define SOAP_TYPE_xsd__integer (109)
#endif

/* std::string has binding name 'std__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__string
#define SOAP_TYPE_std__string (108)
#endif

/* struct SOAP_ENV__Fault has binding name 'SOAP_ENV__Fault' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (634)
#endif

/* struct SOAP_ENV__Reason has binding name 'SOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (633)
#endif

/* struct SOAP_ENV__Detail has binding name 'SOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (630)
#endif

/* struct SOAP_ENV__Code has binding name 'SOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (628)
#endif

/* struct SOAP_ENV__Header has binding name 'SOAP_ENV__Header' for type '' */
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (106)
#endif

/* struct _wsse__Security has binding name '_wsse__Security' for type '' */
#ifndef SOAP_TYPE__wsse__Security
#define SOAP_TYPE__wsse__Security (99)
#endif

/* struct wsc__PropertiesType has binding name 'wsc__PropertiesType' for type 'wsc:PropertiesType' */
#ifndef SOAP_TYPE_wsc__PropertiesType
#define SOAP_TYPE_wsc__PropertiesType (92)
#endif

/* struct wsc__DerivedKeyTokenType has binding name 'wsc__DerivedKeyTokenType' for type 'wsc:DerivedKeyTokenType' */
#ifndef SOAP_TYPE_wsc__DerivedKeyTokenType
#define SOAP_TYPE_wsc__DerivedKeyTokenType (91)
#endif

/* struct wsc__SecurityContextTokenType has binding name 'wsc__SecurityContextTokenType' for type 'wsc:SecurityContextTokenType' */
#ifndef SOAP_TYPE_wsc__SecurityContextTokenType
#define SOAP_TYPE_wsc__SecurityContextTokenType (90)
#endif

/* struct _xenc__ReferenceList has binding name '_xenc__ReferenceList' for type '' */
#ifndef SOAP_TYPE__xenc__ReferenceList
#define SOAP_TYPE__xenc__ReferenceList (76)
#endif

/* struct xenc__EncryptionPropertyType has binding name 'xenc__EncryptionPropertyType' for type 'xenc:EncryptionPropertyType' */
#ifndef SOAP_TYPE_xenc__EncryptionPropertyType
#define SOAP_TYPE_xenc__EncryptionPropertyType (75)
#endif

/* struct xenc__EncryptionPropertiesType has binding name 'xenc__EncryptionPropertiesType' for type 'xenc:EncryptionPropertiesType' */
#ifndef SOAP_TYPE_xenc__EncryptionPropertiesType
#define SOAP_TYPE_xenc__EncryptionPropertiesType (74)
#endif

/* struct xenc__ReferenceType has binding name 'xenc__ReferenceType' for type 'xenc:ReferenceType' */
#ifndef SOAP_TYPE_xenc__ReferenceType
#define SOAP_TYPE_xenc__ReferenceType (73)
#endif

/* struct xenc__AgreementMethodType has binding name 'xenc__AgreementMethodType' for type 'xenc:AgreementMethodType' */
#ifndef SOAP_TYPE_xenc__AgreementMethodType
#define SOAP_TYPE_xenc__AgreementMethodType (72)
#endif

/* struct xenc__EncryptedKeyType has binding name 'xenc__EncryptedKeyType' for type 'xenc:EncryptedKeyType' */
#ifndef SOAP_TYPE_xenc__EncryptedKeyType
#define SOAP_TYPE_xenc__EncryptedKeyType (71)
#endif

/* struct xenc__EncryptedDataType has binding name 'xenc__EncryptedDataType' for type 'xenc:EncryptedDataType' */
#ifndef SOAP_TYPE_xenc__EncryptedDataType
#define SOAP_TYPE_xenc__EncryptedDataType (70)
#endif

/* struct xenc__TransformsType has binding name 'xenc__TransformsType' for type 'xenc:TransformsType' */
#ifndef SOAP_TYPE_xenc__TransformsType
#define SOAP_TYPE_xenc__TransformsType (69)
#endif

/* struct xenc__CipherReferenceType has binding name 'xenc__CipherReferenceType' for type 'xenc:CipherReferenceType' */
#ifndef SOAP_TYPE_xenc__CipherReferenceType
#define SOAP_TYPE_xenc__CipherReferenceType (68)
#endif

/* struct xenc__CipherDataType has binding name 'xenc__CipherDataType' for type 'xenc:CipherDataType' */
#ifndef SOAP_TYPE_xenc__CipherDataType
#define SOAP_TYPE_xenc__CipherDataType (67)
#endif

/* struct xenc__EncryptionMethodType has binding name 'xenc__EncryptionMethodType' for type 'xenc:EncryptionMethodType' */
#ifndef SOAP_TYPE_xenc__EncryptionMethodType
#define SOAP_TYPE_xenc__EncryptionMethodType (66)
#endif

/* struct xenc__EncryptedType has binding name 'xenc__EncryptedType' for type 'xenc:EncryptedType' */
#ifndef SOAP_TYPE_xenc__EncryptedType
#define SOAP_TYPE_xenc__EncryptedType (65)
#endif

/* struct ds__RSAKeyValueType has binding name 'ds__RSAKeyValueType' for type 'ds:RSAKeyValueType' */
#ifndef SOAP_TYPE_ds__RSAKeyValueType
#define SOAP_TYPE_ds__RSAKeyValueType (53)
#endif

/* struct ds__DSAKeyValueType has binding name 'ds__DSAKeyValueType' for type 'ds:DSAKeyValueType' */
#ifndef SOAP_TYPE_ds__DSAKeyValueType
#define SOAP_TYPE_ds__DSAKeyValueType (52)
#endif

/* struct ds__X509IssuerSerialType has binding name 'ds__X509IssuerSerialType' for type 'ds:X509IssuerSerialType' */
#ifndef SOAP_TYPE_ds__X509IssuerSerialType
#define SOAP_TYPE_ds__X509IssuerSerialType (51)
#endif

/* _ds__KeyInfo has binding name '_ds__KeyInfo' for type '' */
#ifndef SOAP_TYPE__ds__KeyInfo
#define SOAP_TYPE__ds__KeyInfo (50)
#endif

/* struct ds__RetrievalMethodType has binding name 'ds__RetrievalMethodType' for type 'ds:RetrievalMethodType' */
#ifndef SOAP_TYPE_ds__RetrievalMethodType
#define SOAP_TYPE_ds__RetrievalMethodType (47)
#endif

/* struct ds__KeyValueType has binding name 'ds__KeyValueType' for type 'ds:KeyValueType' */
#ifndef SOAP_TYPE_ds__KeyValueType
#define SOAP_TYPE_ds__KeyValueType (45)
#endif

/* struct ds__DigestMethodType has binding name 'ds__DigestMethodType' for type 'ds:DigestMethodType' */
#ifndef SOAP_TYPE_ds__DigestMethodType
#define SOAP_TYPE_ds__DigestMethodType (44)
#endif

/* _ds__Transform has binding name '_ds__Transform' for type '' */
#ifndef SOAP_TYPE__ds__Transform
#define SOAP_TYPE__ds__Transform (43)
#endif

/* struct ds__TransformType has binding name 'ds__TransformType' for type 'ds:TransformType' */
#ifndef SOAP_TYPE_ds__TransformType
#define SOAP_TYPE_ds__TransformType (41)
#endif

/* struct _c14n__InclusiveNamespaces has binding name '_c14n__InclusiveNamespaces' for type '' */
#ifndef SOAP_TYPE__c14n__InclusiveNamespaces
#define SOAP_TYPE__c14n__InclusiveNamespaces (40)
#endif

/* struct ds__TransformsType has binding name 'ds__TransformsType' for type 'ds:TransformsType' */
#ifndef SOAP_TYPE_ds__TransformsType
#define SOAP_TYPE_ds__TransformsType (39)
#endif

/* struct ds__ReferenceType has binding name 'ds__ReferenceType' for type 'ds:ReferenceType' */
#ifndef SOAP_TYPE_ds__ReferenceType
#define SOAP_TYPE_ds__ReferenceType (38)
#endif

/* struct ds__SignatureMethodType has binding name 'ds__SignatureMethodType' for type 'ds:SignatureMethodType' */
#ifndef SOAP_TYPE_ds__SignatureMethodType
#define SOAP_TYPE_ds__SignatureMethodType (37)
#endif

/* struct ds__CanonicalizationMethodType has binding name 'ds__CanonicalizationMethodType' for type 'ds:CanonicalizationMethodType' */
#ifndef SOAP_TYPE_ds__CanonicalizationMethodType
#define SOAP_TYPE_ds__CanonicalizationMethodType (36)
#endif

/* _ds__Signature has binding name '_ds__Signature' for type '' */
#ifndef SOAP_TYPE__ds__Signature
#define SOAP_TYPE__ds__Signature (35)
#endif

/* struct ds__KeyInfoType has binding name 'ds__KeyInfoType' for type 'ds:KeyInfoType' */
#ifndef SOAP_TYPE_ds__KeyInfoType
#define SOAP_TYPE_ds__KeyInfoType (33)
#endif

/* struct ds__SignedInfoType has binding name 'ds__SignedInfoType' for type 'ds:SignedInfoType' */
#ifndef SOAP_TYPE_ds__SignedInfoType
#define SOAP_TYPE_ds__SignedInfoType (31)
#endif

/* struct ds__SignatureType has binding name 'ds__SignatureType' for type 'ds:SignatureType' */
#ifndef SOAP_TYPE_ds__SignatureType
#define SOAP_TYPE_ds__SignatureType (30)
#endif

/* struct ds__X509DataType has binding name 'ds__X509DataType' for type 'ds:X509DataType' */
#ifndef SOAP_TYPE_ds__X509DataType
#define SOAP_TYPE_ds__X509DataType (27)
#endif

/* struct _wsse__SecurityTokenReference has binding name '_wsse__SecurityTokenReference' for type '' */
#ifndef SOAP_TYPE__wsse__SecurityTokenReference
#define SOAP_TYPE__wsse__SecurityTokenReference (23)
#endif

/* struct _wsse__KeyIdentifier has binding name '_wsse__KeyIdentifier' for type '' */
#ifndef SOAP_TYPE__wsse__KeyIdentifier
#define SOAP_TYPE__wsse__KeyIdentifier (22)
#endif

/* struct _wsse__Embedded has binding name '_wsse__Embedded' for type '' */
#ifndef SOAP_TYPE__wsse__Embedded
#define SOAP_TYPE__wsse__Embedded (21)
#endif

/* struct _wsse__Reference has binding name '_wsse__Reference' for type '' */
#ifndef SOAP_TYPE__wsse__Reference
#define SOAP_TYPE__wsse__Reference (20)
#endif

/* struct _wsse__BinarySecurityToken has binding name '_wsse__BinarySecurityToken' for type '' */
#ifndef SOAP_TYPE__wsse__BinarySecurityToken
#define SOAP_TYPE__wsse__BinarySecurityToken (19)
#endif

/* struct _wsse__Password has binding name '_wsse__Password' for type '' */
#ifndef SOAP_TYPE__wsse__Password
#define SOAP_TYPE__wsse__Password (16)
#endif

/* struct _wsse__UsernameToken has binding name '_wsse__UsernameToken' for type '' */
#ifndef SOAP_TYPE__wsse__UsernameToken
#define SOAP_TYPE__wsse__UsernameToken (15)
#endif

/* struct wsse__EncodedString has binding name 'wsse__EncodedString' for type 'wsse:EncodedString' */
#ifndef SOAP_TYPE_wsse__EncodedString
#define SOAP_TYPE_wsse__EncodedString (13)
#endif

/* struct _wsu__Timestamp has binding name '_wsu__Timestamp' for type '' */
#ifndef SOAP_TYPE__wsu__Timestamp
#define SOAP_TYPE__wsu__Timestamp (12)
#endif

/* struct SOAP_ENV__Reason * has binding name 'PointerToSOAP_ENV__Reason' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Reason
#define SOAP_TYPE_PointerToSOAP_ENV__Reason (636)
#endif

/* struct SOAP_ENV__Detail * has binding name 'PointerToSOAP_ENV__Detail' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Detail
#define SOAP_TYPE_PointerToSOAP_ENV__Detail (635)
#endif

/* struct SOAP_ENV__Code * has binding name 'PointerToSOAP_ENV__Code' for type '' */
#ifndef SOAP_TYPE_PointerToSOAP_ENV__Code
#define SOAP_TYPE_PointerToSOAP_ENV__Code (629)
#endif

/* ns2__RequestMessage * has binding name 'PointerTons2__RequestMessage' for type 'ns2:RequestMessage' */
#ifndef SOAP_TYPE_PointerTons2__RequestMessage
#define SOAP_TYPE_PointerTons2__RequestMessage (624)
#endif

/* ns2__VCCustomData * has binding name 'PointerTons2__VCCustomData' for type 'ns2:VCCustomData' */
#ifndef SOAP_TYPE_PointerTons2__VCCustomData
#define SOAP_TYPE_PointerTons2__VCCustomData (623)
#endif

/* ns2__VCCardArt * has binding name 'PointerTons2__VCCardArt' for type 'ns2:VCCardArt' */
#ifndef SOAP_TYPE_PointerTons2__VCCardArt
#define SOAP_TYPE_PointerTons2__VCCardArt (622)
#endif

/* ns2__PaypalTransaction * has binding name 'PointerTons2__PaypalTransaction' for type 'ns2:PaypalTransaction' */
#ifndef SOAP_TYPE_PointerTons2__PaypalTransaction
#define SOAP_TYPE_PointerTons2__PaypalTransaction (620)
#endif

/* ns2__MDDField * has binding name 'PointerTons2__MDDField' for type 'ns2:MDDField' */
#ifndef SOAP_TYPE_PointerTons2__MDDField
#define SOAP_TYPE_PointerTons2__MDDField (618)
#endif

/* ns2__Service * has binding name 'PointerTons2__Service' for type 'ns2:Service' */
#ifndef SOAP_TYPE_PointerTons2__Service
#define SOAP_TYPE_PointerTons2__Service (616)
#endif

/* ns2__Leg * has binding name 'PointerTons2__Leg' for type 'ns2:Leg' */
#ifndef SOAP_TYPE_PointerTons2__Leg
#define SOAP_TYPE_PointerTons2__Leg (614)
#endif

/* ns2__ReplyReserved * has binding name 'PointerTons2__ReplyReserved' for type 'ns2:ReplyReserved' */
#ifndef SOAP_TYPE_PointerTons2__ReplyReserved
#define SOAP_TYPE_PointerTons2__ReplyReserved (613)
#endif

/* ns2__Token * has binding name 'PointerTons2__Token' for type 'ns2:Token' */
#ifndef SOAP_TYPE_PointerTons2__Token
#define SOAP_TYPE_PointerTons2__Token (612)
#endif

/* ns2__BinLookupReply * has binding name 'PointerTons2__BinLookupReply' for type 'ns2:BinLookupReply' */
#ifndef SOAP_TYPE_PointerTons2__BinLookupReply
#define SOAP_TYPE_PointerTons2__BinLookupReply (611)
#endif

/* ns2__DecryptVisaCheckoutDataReply * has binding name 'PointerTons2__DecryptVisaCheckoutDataReply' for type 'ns2:DecryptVisaCheckoutDataReply' */
#ifndef SOAP_TYPE_PointerTons2__DecryptVisaCheckoutDataReply
#define SOAP_TYPE_PointerTons2__DecryptVisaCheckoutDataReply (610)
#endif

/* ns2__VCReply * has binding name 'PointerTons2__VCReply' for type 'ns2:VCReply' */
#ifndef SOAP_TYPE_PointerTons2__VCReply
#define SOAP_TYPE_PointerTons2__VCReply (609)
#endif

/* ns2__HostedDataRetrieveReply * has binding name 'PointerTons2__HostedDataRetrieveReply' for type 'ns2:HostedDataRetrieveReply' */
#ifndef SOAP_TYPE_PointerTons2__HostedDataRetrieveReply
#define SOAP_TYPE_PointerTons2__HostedDataRetrieveReply (608)
#endif

/* ns2__HostedDataCreateReply * has binding name 'PointerTons2__HostedDataCreateReply' for type 'ns2:HostedDataCreateReply' */
#ifndef SOAP_TYPE_PointerTons2__HostedDataCreateReply
#define SOAP_TYPE_PointerTons2__HostedDataCreateReply (607)
#endif

/* ns2__OriginalTransaction * has binding name 'PointerTons2__OriginalTransaction' for type 'ns2:OriginalTransaction' */
#ifndef SOAP_TYPE_PointerTons2__OriginalTransaction
#define SOAP_TYPE_PointerTons2__OriginalTransaction (606)
#endif

/* ns2__EmvReply * has binding name 'PointerTons2__EmvReply' for type 'ns2:EmvReply' */
#ifndef SOAP_TYPE_PointerTons2__EmvReply
#define SOAP_TYPE_PointerTons2__EmvReply (605)
#endif

/* ns2__PayPalTransactionSearchReply * has binding name 'PointerTons2__PayPalTransactionSearchReply' for type 'ns2:PayPalTransactionSearchReply' */
#ifndef SOAP_TYPE_PointerTons2__PayPalTransactionSearchReply
#define SOAP_TYPE_PointerTons2__PayPalTransactionSearchReply (604)
#endif

/* ns2__PayPalGetTxnDetailsReply * has binding name 'PointerTons2__PayPalGetTxnDetailsReply' for type 'ns2:PayPalGetTxnDetailsReply' */
#ifndef SOAP_TYPE_PointerTons2__PayPalGetTxnDetailsReply
#define SOAP_TYPE_PointerTons2__PayPalGetTxnDetailsReply (603)
#endif

/* ns2__PromotionGroupReply * has binding name 'PointerTons2__PromotionGroupReply' for type 'ns2:PromotionGroupReply' */
#ifndef SOAP_TYPE_PointerTons2__PromotionGroupReply
#define SOAP_TYPE_PointerTons2__PromotionGroupReply (601)
#endif

/* ns2__Promotion * has binding name 'PointerTons2__Promotion' for type 'ns2:Promotion' */
#ifndef SOAP_TYPE_PointerTons2__Promotion
#define SOAP_TYPE_PointerTons2__Promotion (600)
#endif

/* ns2__APConfirmPurchaseReply * has binding name 'PointerTons2__APConfirmPurchaseReply' for type 'ns2:APConfirmPurchaseReply' */
#ifndef SOAP_TYPE_PointerTons2__APConfirmPurchaseReply
#define SOAP_TYPE_PointerTons2__APConfirmPurchaseReply (599)
#endif

/* ns2__APTransactionDetailsReply * has binding name 'PointerTons2__APTransactionDetailsReply' for type 'ns2:APTransactionDetailsReply' */
#ifndef SOAP_TYPE_PointerTons2__APTransactionDetailsReply
#define SOAP_TYPE_PointerTons2__APTransactionDetailsReply (598)
#endif

/* ns2__APCheckOutDetailsReply * has binding name 'PointerTons2__APCheckOutDetailsReply' for type 'ns2:APCheckOutDetailsReply' */
#ifndef SOAP_TYPE_PointerTons2__APCheckOutDetailsReply
#define SOAP_TYPE_PointerTons2__APCheckOutDetailsReply (597)
#endif

/* ns2__APSaleReply * has binding name 'PointerTons2__APSaleReply' for type 'ns2:APSaleReply' */
#ifndef SOAP_TYPE_PointerTons2__APSaleReply
#define SOAP_TYPE_PointerTons2__APSaleReply (596)
#endif

/* ns2__APRefundReply * has binding name 'PointerTons2__APRefundReply' for type 'ns2:APRefundReply' */
#ifndef SOAP_TYPE_PointerTons2__APRefundReply
#define SOAP_TYPE_PointerTons2__APRefundReply (595)
#endif

/* ns2__APOptionsReply * has binding name 'PointerTons2__APOptionsReply' for type 'ns2:APOptionsReply' */
#ifndef SOAP_TYPE_PointerTons2__APOptionsReply
#define SOAP_TYPE_PointerTons2__APOptionsReply (594)
#endif

/* ns2__APCaptureReply * has binding name 'PointerTons2__APCaptureReply' for type 'ns2:APCaptureReply' */
#ifndef SOAP_TYPE_PointerTons2__APCaptureReply
#define SOAP_TYPE_PointerTons2__APCaptureReply (593)
#endif

/* ns2__APAuthReversalReply * has binding name 'PointerTons2__APAuthReversalReply' for type 'ns2:APAuthReversalReply' */
#ifndef SOAP_TYPE_PointerTons2__APAuthReversalReply
#define SOAP_TYPE_PointerTons2__APAuthReversalReply (592)
#endif

/* ns2__APAuthReply * has binding name 'PointerTons2__APAuthReply' for type 'ns2:APAuthReply' */
#ifndef SOAP_TYPE_PointerTons2__APAuthReply
#define SOAP_TYPE_PointerTons2__APAuthReply (591)
#endif

/* ns2__APReply * has binding name 'PointerTons2__APReply' for type 'ns2:APReply' */
#ifndef SOAP_TYPE_PointerTons2__APReply
#define SOAP_TYPE_PointerTons2__APReply (590)
#endif

/* ns2__APCheckStatusReply * has binding name 'PointerTons2__APCheckStatusReply' for type 'ns2:APCheckStatusReply' */
#ifndef SOAP_TYPE_PointerTons2__APCheckStatusReply
#define SOAP_TYPE_PointerTons2__APCheckStatusReply (589)
#endif

/* ns2__APInitiateReply * has binding name 'PointerTons2__APInitiateReply' for type 'ns2:APInitiateReply' */
#ifndef SOAP_TYPE_PointerTons2__APInitiateReply
#define SOAP_TYPE_PointerTons2__APInitiateReply (588)
#endif

/* ns2__PinDebitReversalReply * has binding name 'PointerTons2__PinDebitReversalReply' for type 'ns2:PinDebitReversalReply' */
#ifndef SOAP_TYPE_PointerTons2__PinDebitReversalReply
#define SOAP_TYPE_PointerTons2__PinDebitReversalReply (587)
#endif

/* ns2__PinDebitCreditReply * has binding name 'PointerTons2__PinDebitCreditReply' for type 'ns2:PinDebitCreditReply' */
#ifndef SOAP_TYPE_PointerTons2__PinDebitCreditReply
#define SOAP_TYPE_PointerTons2__PinDebitCreditReply (586)
#endif

/* ns2__PinDebitPurchaseReply * has binding name 'PointerTons2__PinDebitPurchaseReply' for type 'ns2:PinDebitPurchaseReply' */
#ifndef SOAP_TYPE_PointerTons2__PinDebitPurchaseReply
#define SOAP_TYPE_PointerTons2__PinDebitPurchaseReply (585)
#endif

/* ns2__BoletoPaymentReply * has binding name 'PointerTons2__BoletoPaymentReply' for type 'ns2:BoletoPaymentReply' */
#ifndef SOAP_TYPE_PointerTons2__BoletoPaymentReply
#define SOAP_TYPE_PointerTons2__BoletoPaymentReply (584)
#endif

/* ns2__ChinaRefundReply * has binding name 'PointerTons2__ChinaRefundReply' for type 'ns2:ChinaRefundReply' */
#ifndef SOAP_TYPE_PointerTons2__ChinaRefundReply
#define SOAP_TYPE_PointerTons2__ChinaRefundReply (583)
#endif

/* ns2__ChinaPaymentReply * has binding name 'PointerTons2__ChinaPaymentReply' for type 'ns2:ChinaPaymentReply' */
#ifndef SOAP_TYPE_PointerTons2__ChinaPaymentReply
#define SOAP_TYPE_PointerTons2__ChinaPaymentReply (582)
#endif

/* ns2__PayPalDoRefTransactionReply * has binding name 'PointerTons2__PayPalDoRefTransactionReply' for type 'ns2:PayPalDoRefTransactionReply' */
#ifndef SOAP_TYPE_PointerTons2__PayPalDoRefTransactionReply
#define SOAP_TYPE_PointerTons2__PayPalDoRefTransactionReply (581)
#endif

/* ns2__PayPalCreateAgreementReply * has binding name 'PointerTons2__PayPalCreateAgreementReply' for type 'ns2:PayPalCreateAgreementReply' */
#ifndef SOAP_TYPE_PointerTons2__PayPalCreateAgreementReply
#define SOAP_TYPE_PointerTons2__PayPalCreateAgreementReply (580)
#endif

/* ns2__PayPalUpdateAgreementReply * has binding name 'PointerTons2__PayPalUpdateAgreementReply' for type 'ns2:PayPalUpdateAgreementReply' */
#ifndef SOAP_TYPE_PointerTons2__PayPalUpdateAgreementReply
#define SOAP_TYPE_PointerTons2__PayPalUpdateAgreementReply (579)
#endif

/* ns2__PayPalEcOrderSetupReply * has binding name 'PointerTons2__PayPalEcOrderSetupReply' for type 'ns2:PayPalEcOrderSetupReply' */
#ifndef SOAP_TYPE_PointerTons2__PayPalEcOrderSetupReply
#define SOAP_TYPE_PointerTons2__PayPalEcOrderSetupReply (578)
#endif

/* ns2__PayPalAuthorizationReply * has binding name 'PointerTons2__PayPalAuthorizationReply' for type 'ns2:PayPalAuthorizationReply' */
#ifndef SOAP_TYPE_PointerTons2__PayPalAuthorizationReply
#define SOAP_TYPE_PointerTons2__PayPalAuthorizationReply (577)
#endif

/* ns2__PayPalEcSetReply * has binding name 'PointerTons2__PayPalEcSetReply' for type 'ns2:PayPalEcSetReply' */
#ifndef SOAP_TYPE_PointerTons2__PayPalEcSetReply
#define SOAP_TYPE_PointerTons2__PayPalEcSetReply (576)
#endif

/* ns2__PayPalEcGetDetailsReply * has binding name 'PointerTons2__PayPalEcGetDetailsReply' for type 'ns2:PayPalEcGetDetailsReply' */
#ifndef SOAP_TYPE_PointerTons2__PayPalEcGetDetailsReply
#define SOAP_TYPE_PointerTons2__PayPalEcGetDetailsReply (575)
#endif

/* ns2__PayPalEcDoPaymentReply * has binding name 'PointerTons2__PayPalEcDoPaymentReply' for type 'ns2:PayPalEcDoPaymentReply' */
#ifndef SOAP_TYPE_PointerTons2__PayPalEcDoPaymentReply
#define SOAP_TYPE_PointerTons2__PayPalEcDoPaymentReply (574)
#endif

/* ns2__PayPalDoCaptureReply * has binding name 'PointerTons2__PayPalDoCaptureReply' for type 'ns2:PayPalDoCaptureReply' */
#ifndef SOAP_TYPE_PointerTons2__PayPalDoCaptureReply
#define SOAP_TYPE_PointerTons2__PayPalDoCaptureReply (573)
#endif

/* ns2__PayPalAuthReversalReply * has binding name 'PointerTons2__PayPalAuthReversalReply' for type 'ns2:PayPalAuthReversalReply' */
#ifndef SOAP_TYPE_PointerTons2__PayPalAuthReversalReply
#define SOAP_TYPE_PointerTons2__PayPalAuthReversalReply (572)
#endif

/* ns2__PayPalRefundReply * has binding name 'PointerTons2__PayPalRefundReply' for type 'ns2:PayPalRefundReply' */
#ifndef SOAP_TYPE_PointerTons2__PayPalRefundReply
#define SOAP_TYPE_PointerTons2__PayPalRefundReply (571)
#endif

/* ns2__DecisionReply * has binding name 'PointerTons2__DecisionReply' for type 'ns2:DecisionReply' */
#ifndef SOAP_TYPE_PointerTons2__DecisionReply
#define SOAP_TYPE_PointerTons2__DecisionReply (570)
#endif

/* ns2__CaseManagementActionReply * has binding name 'PointerTons2__CaseManagementActionReply' for type 'ns2:CaseManagementActionReply' */
#ifndef SOAP_TYPE_PointerTons2__CaseManagementActionReply
#define SOAP_TYPE_PointerTons2__CaseManagementActionReply (569)
#endif

/* ns2__FraudUpdateReply * has binding name 'PointerTons2__FraudUpdateReply' for type 'ns2:FraudUpdateReply' */
#ifndef SOAP_TYPE_PointerTons2__FraudUpdateReply
#define SOAP_TYPE_PointerTons2__FraudUpdateReply (568)
#endif

/* ns2__RiskUpdateReply * has binding name 'PointerTons2__RiskUpdateReply' for type 'ns2:RiskUpdateReply' */
#ifndef SOAP_TYPE_PointerTons2__RiskUpdateReply
#define SOAP_TYPE_PointerTons2__RiskUpdateReply (567)
#endif

/* ns2__PayPalPreapprovedUpdateReply * has binding name 'PointerTons2__PayPalPreapprovedUpdateReply' for type 'ns2:PayPalPreapprovedUpdateReply' */
#ifndef SOAP_TYPE_PointerTons2__PayPalPreapprovedUpdateReply
#define SOAP_TYPE_PointerTons2__PayPalPreapprovedUpdateReply (566)
#endif

/* ns2__PayPalPreapprovedPaymentReply * has binding name 'PointerTons2__PayPalPreapprovedPaymentReply' for type 'ns2:PayPalPreapprovedPaymentReply' */
#ifndef SOAP_TYPE_PointerTons2__PayPalPreapprovedPaymentReply
#define SOAP_TYPE_PointerTons2__PayPalPreapprovedPaymentReply (565)
#endif

/* ns2__PayPalButtonCreateReply * has binding name 'PointerTons2__PayPalButtonCreateReply' for type 'ns2:PayPalButtonCreateReply' */
#ifndef SOAP_TYPE_PointerTons2__PayPalButtonCreateReply
#define SOAP_TYPE_PointerTons2__PayPalButtonCreateReply (564)
#endif

/* ns2__PinlessDebitReversalReply * has binding name 'PointerTons2__PinlessDebitReversalReply' for type 'ns2:PinlessDebitReversalReply' */
#ifndef SOAP_TYPE_PointerTons2__PinlessDebitReversalReply
#define SOAP_TYPE_PointerTons2__PinlessDebitReversalReply (563)
#endif

/* ns2__PinlessDebitValidateReply * has binding name 'PointerTons2__PinlessDebitValidateReply' for type 'ns2:PinlessDebitValidateReply' */
#ifndef SOAP_TYPE_PointerTons2__PinlessDebitValidateReply
#define SOAP_TYPE_PointerTons2__PinlessDebitValidateReply (562)
#endif

/* ns2__PinlessDebitReply * has binding name 'PointerTons2__PinlessDebitReply' for type 'ns2:PinlessDebitReply' */
#ifndef SOAP_TYPE_PointerTons2__PinlessDebitReply
#define SOAP_TYPE_PointerTons2__PinlessDebitReply (561)
#endif

/* ns2__VoidReply * has binding name 'PointerTons2__VoidReply' for type 'ns2:VoidReply' */
#ifndef SOAP_TYPE_PointerTons2__VoidReply
#define SOAP_TYPE_PointerTons2__VoidReply (560)
#endif

/* ns2__PayPalCreditReply * has binding name 'PointerTons2__PayPalCreditReply' for type 'ns2:PayPalCreditReply' */
#ifndef SOAP_TYPE_PointerTons2__PayPalCreditReply
#define SOAP_TYPE_PointerTons2__PayPalCreditReply (559)
#endif

/* ns2__PayPalPaymentReply * has binding name 'PointerTons2__PayPalPaymentReply' for type 'ns2:PayPalPaymentReply' */
#ifndef SOAP_TYPE_PointerTons2__PayPalPaymentReply
#define SOAP_TYPE_PointerTons2__PayPalPaymentReply (558)
#endif

/* ns2__PaySubscriptionDeleteReply * has binding name 'PointerTons2__PaySubscriptionDeleteReply' for type 'ns2:PaySubscriptionDeleteReply' */
#ifndef SOAP_TYPE_PointerTons2__PaySubscriptionDeleteReply
#define SOAP_TYPE_PointerTons2__PaySubscriptionDeleteReply (557)
#endif

/* ns2__PaySubscriptionRetrieveReply * has binding name 'PointerTons2__PaySubscriptionRetrieveReply' for type 'ns2:PaySubscriptionRetrieveReply' */
#ifndef SOAP_TYPE_PointerTons2__PaySubscriptionRetrieveReply
#define SOAP_TYPE_PointerTons2__PaySubscriptionRetrieveReply (556)
#endif

/* ns2__PaySubscriptionEventUpdateReply * has binding name 'PointerTons2__PaySubscriptionEventUpdateReply' for type 'ns2:PaySubscriptionEventUpdateReply' */
#ifndef SOAP_TYPE_PointerTons2__PaySubscriptionEventUpdateReply
#define SOAP_TYPE_PointerTons2__PaySubscriptionEventUpdateReply (555)
#endif

/* ns2__PaySubscriptionUpdateReply * has binding name 'PointerTons2__PaySubscriptionUpdateReply' for type 'ns2:PaySubscriptionUpdateReply' */
#ifndef SOAP_TYPE_PointerTons2__PaySubscriptionUpdateReply
#define SOAP_TYPE_PointerTons2__PaySubscriptionUpdateReply (554)
#endif

/* ns2__PaySubscriptionCreateReply * has binding name 'PointerTons2__PaySubscriptionCreateReply' for type 'ns2:PaySubscriptionCreateReply' */
#ifndef SOAP_TYPE_PointerTons2__PaySubscriptionCreateReply
#define SOAP_TYPE_PointerTons2__PaySubscriptionCreateReply (553)
#endif

/* ns2__DirectDebitRefundReply * has binding name 'PointerTons2__DirectDebitRefundReply' for type 'ns2:DirectDebitRefundReply' */
#ifndef SOAP_TYPE_PointerTons2__DirectDebitRefundReply
#define SOAP_TYPE_PointerTons2__DirectDebitRefundReply (552)
#endif

/* ns2__DirectDebitValidateReply * has binding name 'PointerTons2__DirectDebitValidateReply' for type 'ns2:DirectDebitValidateReply' */
#ifndef SOAP_TYPE_PointerTons2__DirectDebitValidateReply
#define SOAP_TYPE_PointerTons2__DirectDebitValidateReply (551)
#endif

/* ns2__DirectDebitReply * has binding name 'PointerTons2__DirectDebitReply' for type 'ns2:DirectDebitReply' */
#ifndef SOAP_TYPE_PointerTons2__DirectDebitReply
#define SOAP_TYPE_PointerTons2__DirectDebitReply (550)
#endif

/* ns2__DirectDebitMandateReply * has binding name 'PointerTons2__DirectDebitMandateReply' for type 'ns2:DirectDebitMandateReply' */
#ifndef SOAP_TYPE_PointerTons2__DirectDebitMandateReply
#define SOAP_TYPE_PointerTons2__DirectDebitMandateReply (549)
#endif

/* ns2__BankTransferRealTimeReply * has binding name 'PointerTons2__BankTransferRealTimeReply' for type 'ns2:BankTransferRealTimeReply' */
#ifndef SOAP_TYPE_PointerTons2__BankTransferRealTimeReply
#define SOAP_TYPE_PointerTons2__BankTransferRealTimeReply (548)
#endif

/* ns2__BankTransferRefundReply * has binding name 'PointerTons2__BankTransferRefundReply' for type 'ns2:BankTransferRefundReply' */
#ifndef SOAP_TYPE_PointerTons2__BankTransferRefundReply
#define SOAP_TYPE_PointerTons2__BankTransferRefundReply (547)
#endif

/* ns2__BankTransferReply * has binding name 'PointerTons2__BankTransferReply' for type 'ns2:BankTransferReply' */
#ifndef SOAP_TYPE_PointerTons2__BankTransferReply
#define SOAP_TYPE_PointerTons2__BankTransferReply (546)
#endif

/* ns2__FXRatesReply * has binding name 'PointerTons2__FXRatesReply' for type 'ns2:FXRatesReply' */
#ifndef SOAP_TYPE_PointerTons2__FXRatesReply
#define SOAP_TYPE_PointerTons2__FXRatesReply (545)
#endif

/* ns2__ExportReply * has binding name 'PointerTons2__ExportReply' for type 'ns2:ExportReply' */
#ifndef SOAP_TYPE_PointerTons2__ExportReply
#define SOAP_TYPE_PointerTons2__ExportReply (544)
#endif

/* ns2__DAVReply * has binding name 'PointerTons2__DAVReply' for type 'ns2:DAVReply' */
#ifndef SOAP_TYPE_PointerTons2__DAVReply
#define SOAP_TYPE_PointerTons2__DAVReply (543)
#endif

/* ns2__AFSReply * has binding name 'PointerTons2__AFSReply' for type 'ns2:AFSReply' */
#ifndef SOAP_TYPE_PointerTons2__AFSReply
#define SOAP_TYPE_PointerTons2__AFSReply (542)
#endif

/* ns2__DMEReply * has binding name 'PointerTons2__DMEReply' for type 'ns2:DMEReply' */
#ifndef SOAP_TYPE_PointerTons2__DMEReply
#define SOAP_TYPE_PointerTons2__DMEReply (541)
#endif

/* ns2__EncryptPaymentDataReply * has binding name 'PointerTons2__EncryptPaymentDataReply' for type 'ns2:EncryptPaymentDataReply' */
#ifndef SOAP_TYPE_PointerTons2__EncryptPaymentDataReply
#define SOAP_TYPE_PointerTons2__EncryptPaymentDataReply (540)
#endif

/* ns2__TaxReply * has binding name 'PointerTons2__TaxReply' for type 'ns2:TaxReply' */
#ifndef SOAP_TYPE_PointerTons2__TaxReply
#define SOAP_TYPE_PointerTons2__TaxReply (539)
#endif

/* ns2__PayerAuthValidateReply * has binding name 'PointerTons2__PayerAuthValidateReply' for type 'ns2:PayerAuthValidateReply' */
#ifndef SOAP_TYPE_PointerTons2__PayerAuthValidateReply
#define SOAP_TYPE_PointerTons2__PayerAuthValidateReply (538)
#endif

/* ns2__PayerAuthEnrollReply * has binding name 'PointerTons2__PayerAuthEnrollReply' for type 'ns2:PayerAuthEnrollReply' */
#ifndef SOAP_TYPE_PointerTons2__PayerAuthEnrollReply
#define SOAP_TYPE_PointerTons2__PayerAuthEnrollReply (537)
#endif

/* ns2__ECAuthenticateReply * has binding name 'PointerTons2__ECAuthenticateReply' for type 'ns2:ECAuthenticateReply' */
#ifndef SOAP_TYPE_PointerTons2__ECAuthenticateReply
#define SOAP_TYPE_PointerTons2__ECAuthenticateReply (536)
#endif

/* ns2__ECCreditReply * has binding name 'PointerTons2__ECCreditReply' for type 'ns2:ECCreditReply' */
#ifndef SOAP_TYPE_PointerTons2__ECCreditReply
#define SOAP_TYPE_PointerTons2__ECCreditReply (535)
#endif

/* ns2__ECDebitReply * has binding name 'PointerTons2__ECDebitReply' for type 'ns2:ECDebitReply' */
#ifndef SOAP_TYPE_PointerTons2__ECDebitReply
#define SOAP_TYPE_PointerTons2__ECDebitReply (534)
#endif

/* ns2__CCDCCUpdateReply * has binding name 'PointerTons2__CCDCCUpdateReply' for type 'ns2:CCDCCUpdateReply' */
#ifndef SOAP_TYPE_PointerTons2__CCDCCUpdateReply
#define SOAP_TYPE_PointerTons2__CCDCCUpdateReply (533)
#endif

/* ns2__CCDCCReply * has binding name 'PointerTons2__CCDCCReply' for type 'ns2:CCDCCReply' */
#ifndef SOAP_TYPE_PointerTons2__CCDCCReply
#define SOAP_TYPE_PointerTons2__CCDCCReply (532)
#endif

/* ns2__CCAutoAuthReversalReply * has binding name 'PointerTons2__CCAutoAuthReversalReply' for type 'ns2:CCAutoAuthReversalReply' */
#ifndef SOAP_TYPE_PointerTons2__CCAutoAuthReversalReply
#define SOAP_TYPE_PointerTons2__CCAutoAuthReversalReply (531)
#endif

/* ns2__CCAuthReversalReply * has binding name 'PointerTons2__CCAuthReversalReply' for type 'ns2:CCAuthReversalReply' */
#ifndef SOAP_TYPE_PointerTons2__CCAuthReversalReply
#define SOAP_TYPE_PointerTons2__CCAuthReversalReply (530)
#endif

/* ns2__CCCreditReply * has binding name 'PointerTons2__CCCreditReply' for type 'ns2:CCCreditReply' */
#ifndef SOAP_TYPE_PointerTons2__CCCreditReply
#define SOAP_TYPE_PointerTons2__CCCreditReply (529)
#endif

/* ns2__CCCaptureReply * has binding name 'PointerTons2__CCCaptureReply' for type 'ns2:CCCaptureReply' */
#ifndef SOAP_TYPE_PointerTons2__CCCaptureReply
#define SOAP_TYPE_PointerTons2__CCCaptureReply (528)
#endif

/* ns2__ServiceFeeCalculateReply * has binding name 'PointerTons2__ServiceFeeCalculateReply' for type 'ns2:ServiceFeeCalculateReply' */
#ifndef SOAP_TYPE_PointerTons2__ServiceFeeCalculateReply
#define SOAP_TYPE_PointerTons2__ServiceFeeCalculateReply (527)
#endif

/* ns2__CCIncrementalAuthReply * has binding name 'PointerTons2__CCIncrementalAuthReply' for type 'ns2:CCIncrementalAuthReply' */
#ifndef SOAP_TYPE_PointerTons2__CCIncrementalAuthReply
#define SOAP_TYPE_PointerTons2__CCIncrementalAuthReply (526)
#endif

/* ns2__CCSaleReversalReply * has binding name 'PointerTons2__CCSaleReversalReply' for type 'ns2:CCSaleReversalReply' */
#ifndef SOAP_TYPE_PointerTons2__CCSaleReversalReply
#define SOAP_TYPE_PointerTons2__CCSaleReversalReply (525)
#endif

/* ns2__CCSaleCreditReply * has binding name 'PointerTons2__CCSaleCreditReply' for type 'ns2:CCSaleCreditReply' */
#ifndef SOAP_TYPE_PointerTons2__CCSaleCreditReply
#define SOAP_TYPE_PointerTons2__CCSaleCreditReply (524)
#endif

/* ns2__CCSaleReply * has binding name 'PointerTons2__CCSaleReply' for type 'ns2:CCSaleReply' */
#ifndef SOAP_TYPE_PointerTons2__CCSaleReply
#define SOAP_TYPE_PointerTons2__CCSaleReply (523)
#endif

/* ns2__VerificationReply * has binding name 'PointerTons2__VerificationReply' for type 'ns2:VerificationReply' */
#ifndef SOAP_TYPE_PointerTons2__VerificationReply
#define SOAP_TYPE_PointerTons2__VerificationReply (522)
#endif

/* ns2__OCTReply * has binding name 'PointerTons2__OCTReply' for type 'ns2:OCTReply' */
#ifndef SOAP_TYPE_PointerTons2__OCTReply
#define SOAP_TYPE_PointerTons2__OCTReply (521)
#endif

/* ns2__CCAuthReply * has binding name 'PointerTons2__CCAuthReply' for type 'ns2:CCAuthReply' */
#ifndef SOAP_TYPE_PointerTons2__CCAuthReply
#define SOAP_TYPE_PointerTons2__CCAuthReply (520)
#endif

/* ns2__DeniedPartiesMatch * has binding name 'PointerTons2__DeniedPartiesMatch' for type 'ns2:DeniedPartiesMatch' */
#ifndef SOAP_TYPE_PointerTons2__DeniedPartiesMatch
#define SOAP_TYPE_PointerTons2__DeniedPartiesMatch (518)
#endif

/* ns2__APOptionsOption * has binding name 'PointerTons2__APOptionsOption' for type 'ns2:APOptionsOption' */
#ifndef SOAP_TYPE_PointerTons2__APOptionsOption
#define SOAP_TYPE_PointerTons2__APOptionsOption (517)
#endif

/* ns2__RuleResultItems * has binding name 'PointerTons2__RuleResultItems' for type 'ns2:RuleResultItems' */
#ifndef SOAP_TYPE_PointerTons2__RuleResultItems
#define SOAP_TYPE_PointerTons2__RuleResultItems (516)
#endif

/* ns2__Field * has binding name 'PointerTons2__Field' for type 'ns2:Field' */
#ifndef SOAP_TYPE_PointerTons2__Field
#define SOAP_TYPE_PointerTons2__Field (514)
#endif

/* ns2__AdditionalFields * has binding name 'PointerTons2__AdditionalFields' for type 'ns2:AdditionalFields' */
#ifndef SOAP_TYPE_PointerTons2__AdditionalFields
#define SOAP_TYPE_PointerTons2__AdditionalFields (513)
#endif

/* ns2__ProfileReply * has binding name 'PointerTons2__ProfileReply' for type 'ns2:ProfileReply' */
#ifndef SOAP_TYPE_PointerTons2__ProfileReply
#define SOAP_TYPE_PointerTons2__ProfileReply (512)
#endif

/* ns2__RuleResultItem * has binding name 'PointerTons2__RuleResultItem' for type 'ns2:RuleResultItem' */
#ifndef SOAP_TYPE_PointerTons2__RuleResultItem
#define SOAP_TYPE_PointerTons2__RuleResultItem (510)
#endif

/* ns2__FXQuote * has binding name 'PointerTons2__FXQuote' for type 'ns2:FXQuote' */
#ifndef SOAP_TYPE_PointerTons2__FXQuote
#define SOAP_TYPE_PointerTons2__FXQuote (508)
#endif

/* ns2__DeviceFingerprint * has binding name 'PointerTons2__DeviceFingerprint' for type 'ns2:DeviceFingerprint' */
#ifndef SOAP_TYPE_PointerTons2__DeviceFingerprint
#define SOAP_TYPE_PointerTons2__DeviceFingerprint (507)
#endif

/* ns2__TaxReplyItem * has binding name 'PointerTons2__TaxReplyItem' for type 'ns2:TaxReplyItem' */
#ifndef SOAP_TYPE_PointerTons2__TaxReplyItem
#define SOAP_TYPE_PointerTons2__TaxReplyItem (505)
#endif

/* ns2__issuer * has binding name 'PointerTons2__issuer' for type 'ns2:issuer' */
#ifndef SOAP_TYPE_PointerTons2__issuer
#define SOAP_TYPE_PointerTons2__issuer (504)
#endif

/* ns2__BinLookupService * has binding name 'PointerTons2__BinLookupService' for type 'ns2:BinLookupService' */
#ifndef SOAP_TYPE_PointerTons2__BinLookupService
#define SOAP_TYPE_PointerTons2__BinLookupService (503)
#endif

/* ns2__EncryptPaymentDataService * has binding name 'PointerTons2__EncryptPaymentDataService' for type 'ns2:EncryptPaymentDataService' */
#ifndef SOAP_TYPE_PointerTons2__EncryptPaymentDataService
#define SOAP_TYPE_PointerTons2__EncryptPaymentDataService (502)
#endif

/* ns2__Aft * has binding name 'PointerTons2__Aft' for type 'ns2:Aft' */
#ifndef SOAP_TYPE_PointerTons2__Aft
#define SOAP_TYPE_PointerTons2__Aft (501)
#endif

/* ns2__Wallet * has binding name 'PointerTons2__Wallet' for type 'ns2:Wallet' */
#ifndef SOAP_TYPE_PointerTons2__Wallet
#define SOAP_TYPE_PointerTons2__Wallet (500)
#endif

/* ns2__PromotionGroup * has binding name 'PointerTons2__PromotionGroup' for type 'ns2:PromotionGroup' */
#ifndef SOAP_TYPE_PointerTons2__PromotionGroup
#define SOAP_TYPE_PointerTons2__PromotionGroup (498)
#endif

/* ns2__DecryptVisaCheckoutDataService * has binding name 'PointerTons2__DecryptVisaCheckoutDataService' for type 'ns2:DecryptVisaCheckoutDataService' */
#ifndef SOAP_TYPE_PointerTons2__DecryptVisaCheckoutDataService
#define SOAP_TYPE_PointerTons2__DecryptVisaCheckoutDataService (497)
#endif

/* ns2__VC * has binding name 'PointerTons2__VC' for type 'ns2:VC' */
#ifndef SOAP_TYPE_PointerTons2__VC
#define SOAP_TYPE_PointerTons2__VC (496)
#endif

/* ns2__AutoRentalData * has binding name 'PointerTons2__AutoRentalData' for type 'ns2:AutoRentalData' */
#ifndef SOAP_TYPE_PointerTons2__AutoRentalData
#define SOAP_TYPE_PointerTons2__AutoRentalData (495)
#endif

/* ns2__Sender * has binding name 'PointerTons2__Sender' for type 'ns2:Sender' */
#ifndef SOAP_TYPE_PointerTons2__Sender
#define SOAP_TYPE_PointerTons2__Sender (494)
#endif

/* ns2__Recipient * has binding name 'PointerTons2__Recipient' for type 'ns2:Recipient' */
#ifndef SOAP_TYPE_PointerTons2__Recipient
#define SOAP_TYPE_PointerTons2__Recipient (493)
#endif

/* ns2__PaymentNetworkToken * has binding name 'PointerTons2__PaymentNetworkToken' for type 'ns2:PaymentNetworkToken' */
#ifndef SOAP_TYPE_PointerTons2__PaymentNetworkToken
#define SOAP_TYPE_PointerTons2__PaymentNetworkToken (492)
#endif

/* ns2__HostedDataRetrieveService * has binding name 'PointerTons2__HostedDataRetrieveService' for type 'ns2:HostedDataRetrieveService' */
#ifndef SOAP_TYPE_PointerTons2__HostedDataRetrieveService
#define SOAP_TYPE_PointerTons2__HostedDataRetrieveService (491)
#endif

/* ns2__HostedDataCreateService * has binding name 'PointerTons2__HostedDataCreateService' for type 'ns2:HostedDataCreateService' */
#ifndef SOAP_TYPE_PointerTons2__HostedDataCreateService
#define SOAP_TYPE_PointerTons2__HostedDataCreateService (490)
#endif

/* ns2__EmvRequest * has binding name 'PointerTons2__EmvRequest' for type 'ns2:EmvRequest' */
#ifndef SOAP_TYPE_PointerTons2__EmvRequest
#define SOAP_TYPE_PointerTons2__EmvRequest (489)
#endif

/* ns2__CCDCCUpdateService * has binding name 'PointerTons2__CCDCCUpdateService' for type 'ns2:CCDCCUpdateService' */
#ifndef SOAP_TYPE_PointerTons2__CCDCCUpdateService
#define SOAP_TYPE_PointerTons2__CCDCCUpdateService (488)
#endif

/* ns2__PayPalTransactionSearchService * has binding name 'PointerTons2__PayPalTransactionSearchService' for type 'ns2:PayPalTransactionSearchService' */
#ifndef SOAP_TYPE_PointerTons2__PayPalTransactionSearchService
#define SOAP_TYPE_PointerTons2__PayPalTransactionSearchService (487)
#endif

/* ns2__PayPalGetTxnDetailsService * has binding name 'PointerTons2__PayPalGetTxnDetailsService' for type 'ns2:PayPalGetTxnDetailsService' */
#ifndef SOAP_TYPE_PointerTons2__PayPalGetTxnDetailsService
#define SOAP_TYPE_PointerTons2__PayPalGetTxnDetailsService (486)
#endif

/* ns2__APConfirmPurchaseService * has binding name 'PointerTons2__APConfirmPurchaseService' for type 'ns2:APConfirmPurchaseService' */
#ifndef SOAP_TYPE_PointerTons2__APConfirmPurchaseService
#define SOAP_TYPE_PointerTons2__APConfirmPurchaseService (485)
#endif

/* ns2__APTransactionDetailsService * has binding name 'PointerTons2__APTransactionDetailsService' for type 'ns2:APTransactionDetailsService' */
#ifndef SOAP_TYPE_PointerTons2__APTransactionDetailsService
#define SOAP_TYPE_PointerTons2__APTransactionDetailsService (484)
#endif

/* ns2__APCheckOutDetailsService * has binding name 'PointerTons2__APCheckOutDetailsService' for type 'ns2:APCheckOutDetailsService' */
#ifndef SOAP_TYPE_PointerTons2__APCheckOutDetailsService
#define SOAP_TYPE_PointerTons2__APCheckOutDetailsService (483)
#endif

/* ns2__APSaleService * has binding name 'PointerTons2__APSaleService' for type 'ns2:APSaleService' */
#ifndef SOAP_TYPE_PointerTons2__APSaleService
#define SOAP_TYPE_PointerTons2__APSaleService (482)
#endif

/* ns2__APRefundService * has binding name 'PointerTons2__APRefundService' for type 'ns2:APRefundService' */
#ifndef SOAP_TYPE_PointerTons2__APRefundService
#define SOAP_TYPE_PointerTons2__APRefundService (481)
#endif

/* ns2__APOptionsService * has binding name 'PointerTons2__APOptionsService' for type 'ns2:APOptionsService' */
#ifndef SOAP_TYPE_PointerTons2__APOptionsService
#define SOAP_TYPE_PointerTons2__APOptionsService (480)
#endif

/* ns2__APCaptureService * has binding name 'PointerTons2__APCaptureService' for type 'ns2:APCaptureService' */
#ifndef SOAP_TYPE_PointerTons2__APCaptureService
#define SOAP_TYPE_PointerTons2__APCaptureService (479)
#endif

/* ns2__APAuthReversalService * has binding name 'PointerTons2__APAuthReversalService' for type 'ns2:APAuthReversalService' */
#ifndef SOAP_TYPE_PointerTons2__APAuthReversalService
#define SOAP_TYPE_PointerTons2__APAuthReversalService (478)
#endif

/* ns2__APAuthService * has binding name 'PointerTons2__APAuthService' for type 'ns2:APAuthService' */
#ifndef SOAP_TYPE_PointerTons2__APAuthService
#define SOAP_TYPE_PointerTons2__APAuthService (477)
#endif

/* ns2__AP * has binding name 'PointerTons2__AP' for type 'ns2:AP' */
#ifndef SOAP_TYPE_PointerTons2__AP
#define SOAP_TYPE_PointerTons2__AP (476)
#endif

/* ns2__PinDebitReversalService * has binding name 'PointerTons2__PinDebitReversalService' for type 'ns2:PinDebitReversalService' */
#ifndef SOAP_TYPE_PointerTons2__PinDebitReversalService
#define SOAP_TYPE_PointerTons2__PinDebitReversalService (475)
#endif

/* ns2__PinDebitCreditService * has binding name 'PointerTons2__PinDebitCreditService' for type 'ns2:PinDebitCreditService' */
#ifndef SOAP_TYPE_PointerTons2__PinDebitCreditService
#define SOAP_TYPE_PointerTons2__PinDebitCreditService (474)
#endif

/* ns2__PinDebitPurchaseService * has binding name 'PointerTons2__PinDebitPurchaseService' for type 'ns2:PinDebitPurchaseService' */
#ifndef SOAP_TYPE_PointerTons2__PinDebitPurchaseService
#define SOAP_TYPE_PointerTons2__PinDebitPurchaseService (473)
#endif

/* ns2__APCheckStatusService * has binding name 'PointerTons2__APCheckStatusService' for type 'ns2:APCheckStatusService' */
#ifndef SOAP_TYPE_PointerTons2__APCheckStatusService
#define SOAP_TYPE_PointerTons2__APCheckStatusService (472)
#endif

/* ns2__APInitiateService * has binding name 'PointerTons2__APInitiateService' for type 'ns2:APInitiateService' */
#ifndef SOAP_TYPE_PointerTons2__APInitiateService
#define SOAP_TYPE_PointerTons2__APInitiateService (471)
#endif

/* ns2__BoletoPaymentService * has binding name 'PointerTons2__BoletoPaymentService' for type 'ns2:BoletoPaymentService' */
#ifndef SOAP_TYPE_PointerTons2__BoletoPaymentService
#define SOAP_TYPE_PointerTons2__BoletoPaymentService (470)
#endif

/* ns2__ChinaRefundService * has binding name 'PointerTons2__ChinaRefundService' for type 'ns2:ChinaRefundService' */
#ifndef SOAP_TYPE_PointerTons2__ChinaRefundService
#define SOAP_TYPE_PointerTons2__ChinaRefundService (469)
#endif

/* ns2__ChinaPaymentService * has binding name 'PointerTons2__ChinaPaymentService' for type 'ns2:ChinaPaymentService' */
#ifndef SOAP_TYPE_PointerTons2__ChinaPaymentService
#define SOAP_TYPE_PointerTons2__ChinaPaymentService (468)
#endif

/* ns2__PayPalDoRefTransactionService * has binding name 'PointerTons2__PayPalDoRefTransactionService' for type 'ns2:PayPalDoRefTransactionService' */
#ifndef SOAP_TYPE_PointerTons2__PayPalDoRefTransactionService
#define SOAP_TYPE_PointerTons2__PayPalDoRefTransactionService (467)
#endif

/* ns2__PayPalCreateAgreementService * has binding name 'PointerTons2__PayPalCreateAgreementService' for type 'ns2:PayPalCreateAgreementService' */
#ifndef SOAP_TYPE_PointerTons2__PayPalCreateAgreementService
#define SOAP_TYPE_PointerTons2__PayPalCreateAgreementService (466)
#endif

/* ns2__PayPalUpdateAgreementService * has binding name 'PointerTons2__PayPalUpdateAgreementService' for type 'ns2:PayPalUpdateAgreementService' */
#ifndef SOAP_TYPE_PointerTons2__PayPalUpdateAgreementService
#define SOAP_TYPE_PointerTons2__PayPalUpdateAgreementService (465)
#endif

/* ns2__PayPalAuthorizationService * has binding name 'PointerTons2__PayPalAuthorizationService' for type 'ns2:PayPalAuthorizationService' */
#ifndef SOAP_TYPE_PointerTons2__PayPalAuthorizationService
#define SOAP_TYPE_PointerTons2__PayPalAuthorizationService (464)
#endif

/* ns2__PayPalEcOrderSetupService * has binding name 'PointerTons2__PayPalEcOrderSetupService' for type 'ns2:PayPalEcOrderSetupService' */
#ifndef SOAP_TYPE_PointerTons2__PayPalEcOrderSetupService
#define SOAP_TYPE_PointerTons2__PayPalEcOrderSetupService (463)
#endif

/* ns2__PayPalEcSetService * has binding name 'PointerTons2__PayPalEcSetService' for type 'ns2:PayPalEcSetService' */
#ifndef SOAP_TYPE_PointerTons2__PayPalEcSetService
#define SOAP_TYPE_PointerTons2__PayPalEcSetService (462)
#endif

/* ns2__PayPalEcGetDetailsService * has binding name 'PointerTons2__PayPalEcGetDetailsService' for type 'ns2:PayPalEcGetDetailsService' */
#ifndef SOAP_TYPE_PointerTons2__PayPalEcGetDetailsService
#define SOAP_TYPE_PointerTons2__PayPalEcGetDetailsService (461)
#endif

/* ns2__PayPalEcDoPaymentService * has binding name 'PointerTons2__PayPalEcDoPaymentService' for type 'ns2:PayPalEcDoPaymentService' */
#ifndef SOAP_TYPE_PointerTons2__PayPalEcDoPaymentService
#define SOAP_TYPE_PointerTons2__PayPalEcDoPaymentService (460)
#endif

/* ns2__PayPalDoCaptureService * has binding name 'PointerTons2__PayPalDoCaptureService' for type 'ns2:PayPalDoCaptureService' */
#ifndef SOAP_TYPE_PointerTons2__PayPalDoCaptureService
#define SOAP_TYPE_PointerTons2__PayPalDoCaptureService (459)
#endif

/* ns2__PayPalAuthReversalService * has binding name 'PointerTons2__PayPalAuthReversalService' for type 'ns2:PayPalAuthReversalService' */
#ifndef SOAP_TYPE_PointerTons2__PayPalAuthReversalService
#define SOAP_TYPE_PointerTons2__PayPalAuthReversalService (458)
#endif

/* ns2__PayPalRefundService * has binding name 'PointerTons2__PayPalRefundService' for type 'ns2:PayPalRefundService' */
#ifndef SOAP_TYPE_PointerTons2__PayPalRefundService
#define SOAP_TYPE_PointerTons2__PayPalRefundService (457)
#endif

/* ns2__RequestReserved * has binding name 'PointerTons2__RequestReserved' for type 'ns2:RequestReserved' */
#ifndef SOAP_TYPE_PointerTons2__RequestReserved
#define SOAP_TYPE_PointerTons2__RequestReserved (455)
#endif

/* ns2__CaseManagementActionService * has binding name 'PointerTons2__CaseManagementActionService' for type 'ns2:CaseManagementActionService' */
#ifndef SOAP_TYPE_PointerTons2__CaseManagementActionService
#define SOAP_TYPE_PointerTons2__CaseManagementActionService (454)
#endif

/* ns2__FraudUpdateService * has binding name 'PointerTons2__FraudUpdateService' for type 'ns2:FraudUpdateService' */
#ifndef SOAP_TYPE_PointerTons2__FraudUpdateService
#define SOAP_TYPE_PointerTons2__FraudUpdateService (453)
#endif

/* ns2__RiskUpdateService * has binding name 'PointerTons2__RiskUpdateService' for type 'ns2:RiskUpdateService' */
#ifndef SOAP_TYPE_PointerTons2__RiskUpdateService
#define SOAP_TYPE_PointerTons2__RiskUpdateService (452)
#endif

/* ns2__PayPalPreapprovedUpdateService * has binding name 'PointerTons2__PayPalPreapprovedUpdateService' for type 'ns2:PayPalPreapprovedUpdateService' */
#ifndef SOAP_TYPE_PointerTons2__PayPalPreapprovedUpdateService
#define SOAP_TYPE_PointerTons2__PayPalPreapprovedUpdateService (451)
#endif

/* ns2__PayPalPreapprovedPaymentService * has binding name 'PointerTons2__PayPalPreapprovedPaymentService' for type 'ns2:PayPalPreapprovedPaymentService' */
#ifndef SOAP_TYPE_PointerTons2__PayPalPreapprovedPaymentService
#define SOAP_TYPE_PointerTons2__PayPalPreapprovedPaymentService (450)
#endif

/* ns2__PayPalButtonCreateService * has binding name 'PointerTons2__PayPalButtonCreateService' for type 'ns2:PayPalButtonCreateService' */
#ifndef SOAP_TYPE_PointerTons2__PayPalButtonCreateService
#define SOAP_TYPE_PointerTons2__PayPalButtonCreateService (449)
#endif

/* ns2__LodgingData * has binding name 'PointerTons2__LodgingData' for type 'ns2:LodgingData' */
#ifndef SOAP_TYPE_PointerTons2__LodgingData
#define SOAP_TYPE_PointerTons2__LodgingData (448)
#endif

/* ns2__AncillaryData * has binding name 'PointerTons2__AncillaryData' for type 'ns2:AncillaryData' */
#ifndef SOAP_TYPE_PointerTons2__AncillaryData
#define SOAP_TYPE_PointerTons2__AncillaryData (447)
#endif

/* ns2__AirlineData * has binding name 'PointerTons2__AirlineData' for type 'ns2:AirlineData' */
#ifndef SOAP_TYPE_PointerTons2__AirlineData
#define SOAP_TYPE_PointerTons2__AirlineData (446)
#endif

/* ns2__Batch * has binding name 'PointerTons2__Batch' for type 'ns2:Batch' */
#ifndef SOAP_TYPE_PointerTons2__Batch
#define SOAP_TYPE_PointerTons2__Batch (445)
#endif

/* ns2__PinlessDebitReversalService * has binding name 'PointerTons2__PinlessDebitReversalService' for type 'ns2:PinlessDebitReversalService' */
#ifndef SOAP_TYPE_PointerTons2__PinlessDebitReversalService
#define SOAP_TYPE_PointerTons2__PinlessDebitReversalService (444)
#endif

/* ns2__PinlessDebitValidateService * has binding name 'PointerTons2__PinlessDebitValidateService' for type 'ns2:PinlessDebitValidateService' */
#ifndef SOAP_TYPE_PointerTons2__PinlessDebitValidateService
#define SOAP_TYPE_PointerTons2__PinlessDebitValidateService (443)
#endif

/* ns2__PinlessDebitService * has binding name 'PointerTons2__PinlessDebitService' for type 'ns2:PinlessDebitService' */
#ifndef SOAP_TYPE_PointerTons2__PinlessDebitService
#define SOAP_TYPE_PointerTons2__PinlessDebitService (442)
#endif

/* ns2__BusinessRules * has binding name 'PointerTons2__BusinessRules' for type 'ns2:BusinessRules' */
#ifndef SOAP_TYPE_PointerTons2__BusinessRules
#define SOAP_TYPE_PointerTons2__BusinessRules (441)
#endif

/* ns2__VoidService * has binding name 'PointerTons2__VoidService' for type 'ns2:VoidService' */
#ifndef SOAP_TYPE_PointerTons2__VoidService
#define SOAP_TYPE_PointerTons2__VoidService (440)
#endif

/* ns2__PayPalCreditService * has binding name 'PointerTons2__PayPalCreditService' for type 'ns2:PayPalCreditService' */
#ifndef SOAP_TYPE_PointerTons2__PayPalCreditService
#define SOAP_TYPE_PointerTons2__PayPalCreditService (439)
#endif

/* ns2__PayPalPaymentService * has binding name 'PointerTons2__PayPalPaymentService' for type 'ns2:PayPalPaymentService' */
#ifndef SOAP_TYPE_PointerTons2__PayPalPaymentService
#define SOAP_TYPE_PointerTons2__PayPalPaymentService (438)
#endif

/* ns2__PaySubscriptionDeleteService * has binding name 'PointerTons2__PaySubscriptionDeleteService' for type 'ns2:PaySubscriptionDeleteService' */
#ifndef SOAP_TYPE_PointerTons2__PaySubscriptionDeleteService
#define SOAP_TYPE_PointerTons2__PaySubscriptionDeleteService (437)
#endif

/* ns2__PaySubscriptionRetrieveService * has binding name 'PointerTons2__PaySubscriptionRetrieveService' for type 'ns2:PaySubscriptionRetrieveService' */
#ifndef SOAP_TYPE_PointerTons2__PaySubscriptionRetrieveService
#define SOAP_TYPE_PointerTons2__PaySubscriptionRetrieveService (436)
#endif

/* ns2__PaySubscriptionEventUpdateService * has binding name 'PointerTons2__PaySubscriptionEventUpdateService' for type 'ns2:PaySubscriptionEventUpdateService' */
#ifndef SOAP_TYPE_PointerTons2__PaySubscriptionEventUpdateService
#define SOAP_TYPE_PointerTons2__PaySubscriptionEventUpdateService (435)
#endif

/* ns2__PaySubscriptionUpdateService * has binding name 'PointerTons2__PaySubscriptionUpdateService' for type 'ns2:PaySubscriptionUpdateService' */
#ifndef SOAP_TYPE_PointerTons2__PaySubscriptionUpdateService
#define SOAP_TYPE_PointerTons2__PaySubscriptionUpdateService (434)
#endif

/* ns2__PaySubscriptionCreateService * has binding name 'PointerTons2__PaySubscriptionCreateService' for type 'ns2:PaySubscriptionCreateService' */
#ifndef SOAP_TYPE_PointerTons2__PaySubscriptionCreateService
#define SOAP_TYPE_PointerTons2__PaySubscriptionCreateService (433)
#endif

/* ns2__DirectDebitValidateService * has binding name 'PointerTons2__DirectDebitValidateService' for type 'ns2:DirectDebitValidateService' */
#ifndef SOAP_TYPE_PointerTons2__DirectDebitValidateService
#define SOAP_TYPE_PointerTons2__DirectDebitValidateService (432)
#endif

/* ns2__DirectDebitRefundService * has binding name 'PointerTons2__DirectDebitRefundService' for type 'ns2:DirectDebitRefundService' */
#ifndef SOAP_TYPE_PointerTons2__DirectDebitRefundService
#define SOAP_TYPE_PointerTons2__DirectDebitRefundService (431)
#endif

/* ns2__DirectDebitService * has binding name 'PointerTons2__DirectDebitService' for type 'ns2:DirectDebitService' */
#ifndef SOAP_TYPE_PointerTons2__DirectDebitService
#define SOAP_TYPE_PointerTons2__DirectDebitService (430)
#endif

/* ns2__DirectDebitMandateService * has binding name 'PointerTons2__DirectDebitMandateService' for type 'ns2:DirectDebitMandateService' */
#ifndef SOAP_TYPE_PointerTons2__DirectDebitMandateService
#define SOAP_TYPE_PointerTons2__DirectDebitMandateService (429)
#endif

/* ns2__BankTransferRealTimeService * has binding name 'PointerTons2__BankTransferRealTimeService' for type 'ns2:BankTransferRealTimeService' */
#ifndef SOAP_TYPE_PointerTons2__BankTransferRealTimeService
#define SOAP_TYPE_PointerTons2__BankTransferRealTimeService (428)
#endif

/* ns2__BankTransferRefundService * has binding name 'PointerTons2__BankTransferRefundService' for type 'ns2:BankTransferRefundService' */
#ifndef SOAP_TYPE_PointerTons2__BankTransferRefundService
#define SOAP_TYPE_PointerTons2__BankTransferRefundService (427)
#endif

/* ns2__BankTransferService * has binding name 'PointerTons2__BankTransferService' for type 'ns2:BankTransferService' */
#ifndef SOAP_TYPE_PointerTons2__BankTransferService
#define SOAP_TYPE_PointerTons2__BankTransferService (426)
#endif

/* ns2__FXRatesService * has binding name 'PointerTons2__FXRatesService' for type 'ns2:FXRatesService' */
#ifndef SOAP_TYPE_PointerTons2__FXRatesService
#define SOAP_TYPE_PointerTons2__FXRatesService (425)
#endif

/* ns2__ExportService * has binding name 'PointerTons2__ExportService' for type 'ns2:ExportService' */
#ifndef SOAP_TYPE_PointerTons2__ExportService
#define SOAP_TYPE_PointerTons2__ExportService (424)
#endif

/* ns2__DAVService * has binding name 'PointerTons2__DAVService' for type 'ns2:DAVService' */
#ifndef SOAP_TYPE_PointerTons2__DAVService
#define SOAP_TYPE_PointerTons2__DAVService (423)
#endif

/* ns2__AFSService * has binding name 'PointerTons2__AFSService' for type 'ns2:AFSService' */
#ifndef SOAP_TYPE_PointerTons2__AFSService
#define SOAP_TYPE_PointerTons2__AFSService (422)
#endif

/* ns2__DMEService * has binding name 'PointerTons2__DMEService' for type 'ns2:DMEService' */
#ifndef SOAP_TYPE_PointerTons2__DMEService
#define SOAP_TYPE_PointerTons2__DMEService (421)
#endif

/* ns2__TaxService * has binding name 'PointerTons2__TaxService' for type 'ns2:TaxService' */
#ifndef SOAP_TYPE_PointerTons2__TaxService
#define SOAP_TYPE_PointerTons2__TaxService (420)
#endif

/* ns2__PayerAuthValidateService * has binding name 'PointerTons2__PayerAuthValidateService' for type 'ns2:PayerAuthValidateService' */
#ifndef SOAP_TYPE_PointerTons2__PayerAuthValidateService
#define SOAP_TYPE_PointerTons2__PayerAuthValidateService (419)
#endif

/* ns2__PayerAuthEnrollService * has binding name 'PointerTons2__PayerAuthEnrollService' for type 'ns2:PayerAuthEnrollService' */
#ifndef SOAP_TYPE_PointerTons2__PayerAuthEnrollService
#define SOAP_TYPE_PointerTons2__PayerAuthEnrollService (418)
#endif

/* ns2__ECAuthenticateService * has binding name 'PointerTons2__ECAuthenticateService' for type 'ns2:ECAuthenticateService' */
#ifndef SOAP_TYPE_PointerTons2__ECAuthenticateService
#define SOAP_TYPE_PointerTons2__ECAuthenticateService (417)
#endif

/* ns2__ECCreditService * has binding name 'PointerTons2__ECCreditService' for type 'ns2:ECCreditService' */
#ifndef SOAP_TYPE_PointerTons2__ECCreditService
#define SOAP_TYPE_PointerTons2__ECCreditService (416)
#endif

/* ns2__ECDebitService * has binding name 'PointerTons2__ECDebitService' for type 'ns2:ECDebitService' */
#ifndef SOAP_TYPE_PointerTons2__ECDebitService
#define SOAP_TYPE_PointerTons2__ECDebitService (415)
#endif

/* ns2__ServiceFeeCalculateService * has binding name 'PointerTons2__ServiceFeeCalculateService' for type 'ns2:ServiceFeeCalculateService' */
#ifndef SOAP_TYPE_PointerTons2__ServiceFeeCalculateService
#define SOAP_TYPE_PointerTons2__ServiceFeeCalculateService (414)
#endif

/* ns2__CCDCCService * has binding name 'PointerTons2__CCDCCService' for type 'ns2:CCDCCService' */
#ifndef SOAP_TYPE_PointerTons2__CCDCCService
#define SOAP_TYPE_PointerTons2__CCDCCService (413)
#endif

/* ns2__CCAutoAuthReversalService * has binding name 'PointerTons2__CCAutoAuthReversalService' for type 'ns2:CCAutoAuthReversalService' */
#ifndef SOAP_TYPE_PointerTons2__CCAutoAuthReversalService
#define SOAP_TYPE_PointerTons2__CCAutoAuthReversalService (412)
#endif

/* ns2__CCAuthReversalService * has binding name 'PointerTons2__CCAuthReversalService' for type 'ns2:CCAuthReversalService' */
#ifndef SOAP_TYPE_PointerTons2__CCAuthReversalService
#define SOAP_TYPE_PointerTons2__CCAuthReversalService (411)
#endif

/* ns2__CCCreditService * has binding name 'PointerTons2__CCCreditService' for type 'ns2:CCCreditService' */
#ifndef SOAP_TYPE_PointerTons2__CCCreditService
#define SOAP_TYPE_PointerTons2__CCCreditService (410)
#endif

/* ns2__CCCaptureService * has binding name 'PointerTons2__CCCaptureService' for type 'ns2:CCCaptureService' */
#ifndef SOAP_TYPE_PointerTons2__CCCaptureService
#define SOAP_TYPE_PointerTons2__CCCaptureService (409)
#endif

/* ns2__CCIncrementalAuthService * has binding name 'PointerTons2__CCIncrementalAuthService' for type 'ns2:CCIncrementalAuthService' */
#ifndef SOAP_TYPE_PointerTons2__CCIncrementalAuthService
#define SOAP_TYPE_PointerTons2__CCIncrementalAuthService (408)
#endif

/* ns2__CCSaleReversalService * has binding name 'PointerTons2__CCSaleReversalService' for type 'ns2:CCSaleReversalService' */
#ifndef SOAP_TYPE_PointerTons2__CCSaleReversalService
#define SOAP_TYPE_PointerTons2__CCSaleReversalService (407)
#endif

/* ns2__CCSaleCreditService * has binding name 'PointerTons2__CCSaleCreditService' for type 'ns2:CCSaleCreditService' */
#ifndef SOAP_TYPE_PointerTons2__CCSaleCreditService
#define SOAP_TYPE_PointerTons2__CCSaleCreditService (406)
#endif

/* ns2__CCSaleService * has binding name 'PointerTons2__CCSaleService' for type 'ns2:CCSaleService' */
#ifndef SOAP_TYPE_PointerTons2__CCSaleService
#define SOAP_TYPE_PointerTons2__CCSaleService (405)
#endif

/* ns2__VerificationService * has binding name 'PointerTons2__VerificationService' for type 'ns2:VerificationService' */
#ifndef SOAP_TYPE_PointerTons2__VerificationService
#define SOAP_TYPE_PointerTons2__VerificationService (404)
#endif

/* ns2__OCTService * has binding name 'PointerTons2__OCTService' for type 'ns2:OCTService' */
#ifndef SOAP_TYPE_PointerTons2__OCTService
#define SOAP_TYPE_PointerTons2__OCTService (403)
#endif

/* ns2__CCAuthService * has binding name 'PointerTons2__CCAuthService' for type 'ns2:CCAuthService' */
#ifndef SOAP_TYPE_PointerTons2__CCAuthService
#define SOAP_TYPE_PointerTons2__CCAuthService (402)
#endif

/* ns2__ServiceFee * has binding name 'PointerTons2__ServiceFee' for type 'ns2:ServiceFee' */
#ifndef SOAP_TYPE_PointerTons2__ServiceFee
#define SOAP_TYPE_PointerTons2__ServiceFee (401)
#endif

/* ns2__JPO * has binding name 'PointerTons2__JPO' for type 'ns2:JPO' */
#ifndef SOAP_TYPE_PointerTons2__JPO
#define SOAP_TYPE_PointerTons2__JPO (400)
#endif

/* ns2__MerchantSecureData * has binding name 'PointerTons2__MerchantSecureData' for type 'ns2:MerchantSecureData' */
#ifndef SOAP_TYPE_PointerTons2__MerchantSecureData
#define SOAP_TYPE_PointerTons2__MerchantSecureData (399)
#endif

/* ns2__MerchantDefinedData * has binding name 'PointerTons2__MerchantDefinedData' for type 'ns2:MerchantDefinedData' */
#ifndef SOAP_TYPE_PointerTons2__MerchantDefinedData
#define SOAP_TYPE_PointerTons2__MerchantDefinedData (398)
#endif

/* ns2__PayPal * has binding name 'PointerTons2__PayPal' for type 'ns2:PayPal' */
#ifndef SOAP_TYPE_PointerTons2__PayPal
#define SOAP_TYPE_PointerTons2__PayPal (397)
#endif

/* ns2__OtherTax * has binding name 'PointerTons2__OtherTax' for type 'ns2:OtherTax' */
#ifndef SOAP_TYPE_PointerTons2__OtherTax
#define SOAP_TYPE_PointerTons2__OtherTax (396)
#endif

/* ns2__DecisionManager * has binding name 'PointerTons2__DecisionManager' for type 'ns2:DecisionManager' */
#ifndef SOAP_TYPE_PointerTons2__DecisionManager
#define SOAP_TYPE_PointerTons2__DecisionManager (395)
#endif

/* ns2__RecurringSubscriptionInfo * has binding name 'PointerTons2__RecurringSubscriptionInfo' for type 'ns2:RecurringSubscriptionInfo' */
#ifndef SOAP_TYPE_PointerTons2__RecurringSubscriptionInfo
#define SOAP_TYPE_PointerTons2__RecurringSubscriptionInfo (394)
#endif

/* ns2__Subscription * has binding name 'PointerTons2__Subscription' for type 'ns2:Subscription' */
#ifndef SOAP_TYPE_PointerTons2__Subscription
#define SOAP_TYPE_PointerTons2__Subscription (393)
#endif

/* ns2__BankInfo * has binding name 'PointerTons2__BankInfo' for type 'ns2:BankInfo' */
#ifndef SOAP_TYPE_PointerTons2__BankInfo
#define SOAP_TYPE_PointerTons2__BankInfo (392)
#endif

/* ns2__FundTransfer * has binding name 'PointerTons2__FundTransfer' for type 'ns2:FundTransfer' */
#ifndef SOAP_TYPE_PointerTons2__FundTransfer
#define SOAP_TYPE_PointerTons2__FundTransfer (391)
#endif

/* ns2__UCAF * has binding name 'PointerTons2__UCAF' for type 'ns2:UCAF' */
#ifndef SOAP_TYPE_PointerTons2__UCAF
#define SOAP_TYPE_PointerTons2__UCAF (390)
#endif

/* ns2__GECC * has binding name 'PointerTons2__GECC' for type 'ns2:GECC' */
#ifndef SOAP_TYPE_PointerTons2__GECC
#define SOAP_TYPE_PointerTons2__GECC (389)
#endif

/* ns2__BML * has binding name 'PointerTons2__BML' for type 'ns2:BML' */
#ifndef SOAP_TYPE_PointerTons2__BML
#define SOAP_TYPE_PointerTons2__BML (388)
#endif

/* ns2__Check * has binding name 'PointerTons2__Check' for type 'ns2:Check' */
#ifndef SOAP_TYPE_PointerTons2__Check
#define SOAP_TYPE_PointerTons2__Check (387)
#endif

/* ns2__Card * has binding name 'PointerTons2__Card' for type 'ns2:Card' */
#ifndef SOAP_TYPE_PointerTons2__Card
#define SOAP_TYPE_PointerTons2__Card (386)
#endif

/* ns2__Installment * has binding name 'PointerTons2__Installment' for type 'ns2:Installment' */
#ifndef SOAP_TYPE_PointerTons2__Installment
#define SOAP_TYPE_PointerTons2__Installment (385)
#endif

/* ns2__EncryptedPayment * has binding name 'PointerTons2__EncryptedPayment' for type 'ns2:EncryptedPayment' */
#ifndef SOAP_TYPE_PointerTons2__EncryptedPayment
#define SOAP_TYPE_PointerTons2__EncryptedPayment (384)
#endif

/* ns2__Pos * has binding name 'PointerTons2__Pos' for type 'ns2:Pos' */
#ifndef SOAP_TYPE_PointerTons2__Pos
#define SOAP_TYPE_PointerTons2__Pos (383)
#endif

/* ns2__DCC * has binding name 'PointerTons2__DCC' for type 'ns2:DCC' */
#ifndef SOAP_TYPE_PointerTons2__DCC
#define SOAP_TYPE_PointerTons2__DCC (382)
#endif

/* ns2__FundingTotals * has binding name 'PointerTons2__FundingTotals' for type 'ns2:FundingTotals' */
#ifndef SOAP_TYPE_PointerTons2__FundingTotals
#define SOAP_TYPE_PointerTons2__FundingTotals (381)
#endif

/* ns2__PurchaseTotals * has binding name 'PointerTons2__PurchaseTotals' for type 'ns2:PurchaseTotals' */
#ifndef SOAP_TYPE_PointerTons2__PurchaseTotals
#define SOAP_TYPE_PointerTons2__PurchaseTotals (380)
#endif

/* ns2__Item * has binding name 'PointerTons2__Item' for type 'ns2:Item' */
#ifndef SOAP_TYPE_PointerTons2__Item
#define SOAP_TYPE_PointerTons2__Item (378)
#endif

/* ns2__ShipFrom * has binding name 'PointerTons2__ShipFrom' for type 'ns2:ShipFrom' */
#ifndef SOAP_TYPE_PointerTons2__ShipFrom
#define SOAP_TYPE_PointerTons2__ShipFrom (377)
#endif

/* ns2__PersonalId * has binding name 'PointerTons2__PersonalId' for type 'ns2:PersonalId' */
#ifndef SOAP_TYPE_PointerTons2__PersonalId
#define SOAP_TYPE_PointerTons2__PersonalId (376)
#endif

/* ns2__ShipTo * has binding name 'PointerTons2__ShipTo' for type 'ns2:ShipTo' */
#ifndef SOAP_TYPE_PointerTons2__ShipTo
#define SOAP_TYPE_PointerTons2__ShipTo (375)
#endif

/* ns2__BillTo * has binding name 'PointerTons2__BillTo' for type 'ns2:BillTo' */
#ifndef SOAP_TYPE_PointerTons2__BillTo
#define SOAP_TYPE_PointerTons2__BillTo (374)
#endif

/* ns2__InvoiceHeader * has binding name 'PointerTons2__InvoiceHeader' for type 'ns2:InvoiceHeader' */
#ifndef SOAP_TYPE_PointerTons2__InvoiceHeader
#define SOAP_TYPE_PointerTons2__InvoiceHeader (373)
#endif

/* ns2__APDevice * has binding name 'PointerTons2__APDevice' for type 'ns2:APDevice' */
#ifndef SOAP_TYPE_PointerTons2__APDevice
#define SOAP_TYPE_PointerTons2__APDevice (372)
#endif

/* ns2__DecisionManagerTravelLeg * has binding name 'PointerTons2__DecisionManagerTravelLeg' for type 'ns2:DecisionManagerTravelLeg' */
#ifndef SOAP_TYPE_PointerTons2__DecisionManagerTravelLeg
#define SOAP_TYPE_PointerTons2__DecisionManagerTravelLeg (369)
#endif

/* ns2__DecisionManagerTravelData * has binding name 'PointerTons2__DecisionManagerTravelData' for type 'ns2:DecisionManagerTravelData' */
#ifndef SOAP_TYPE_PointerTons2__DecisionManagerTravelData
#define SOAP_TYPE_PointerTons2__DecisionManagerTravelData (368)
#endif

/* ns2__PaySubscriptionEvent * has binding name 'PointerTons2__PaySubscriptionEvent' for type 'ns2:PaySubscriptionEvent' */
#ifndef SOAP_TYPE_PointerTons2__PaySubscriptionEvent
#define SOAP_TYPE_PointerTons2__PaySubscriptionEvent (367)
#endif

/* ns2__Address * has binding name 'PointerTons2__Address' for type 'ns2:Address' */
#ifndef SOAP_TYPE_PointerTons2__Address
#define SOAP_TYPE_PointerTons2__Address (365)
#endif

/* std::string * has binding name 'PointerTons2__dateTime' for type 'ns2:dateTime' */
#ifndef SOAP_TYPE_PointerTons2__dateTime
#define SOAP_TYPE_PointerTons2__dateTime (364)
#endif

/* std::string * has binding name 'PointerToxsd__integer' for type 'xsd:integer' */
#ifndef SOAP_TYPE_PointerToxsd__integer
#define SOAP_TYPE_PointerToxsd__integer (362)
#endif

/* std::string * has binding name 'PointerTons2__boolean' for type 'ns2:boolean' */
#ifndef SOAP_TYPE_PointerTons2__boolean
#define SOAP_TYPE_PointerTons2__boolean (361)
#endif

/* std::string * has binding name 'PointerTostd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_PointerTostd__string
#define SOAP_TYPE_PointerTostd__string (360)
#endif

/* std::string * has binding name 'PointerTons2__amount' for type 'ns2:amount' */
#ifndef SOAP_TYPE_PointerTons2__amount
#define SOAP_TYPE_PointerTons2__amount (359)
#endif

/* struct _wsse__Security * has binding name 'PointerTo_wsse__Security' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsse__Security
#define SOAP_TYPE_PointerTo_wsse__Security (107)
#endif

/* struct ds__SignatureType * has binding name 'PointerTods__SignatureType' for type 'ds:SignatureType' */
#ifndef SOAP_TYPE_PointerTods__SignatureType
#define SOAP_TYPE_PointerTods__SignatureType (105)
#endif

/* struct wsc__SecurityContextTokenType * has binding name 'PointerTowsc__SecurityContextTokenType' for type 'wsc:SecurityContextTokenType' */
#ifndef SOAP_TYPE_PointerTowsc__SecurityContextTokenType
#define SOAP_TYPE_PointerTowsc__SecurityContextTokenType (104)
#endif

/* struct xenc__EncryptedKeyType * has binding name 'PointerToxenc__EncryptedKeyType' for type 'xenc:EncryptedKeyType' */
#ifndef SOAP_TYPE_PointerToxenc__EncryptedKeyType
#define SOAP_TYPE_PointerToxenc__EncryptedKeyType (103)
#endif

/* struct _wsse__BinarySecurityToken * has binding name 'PointerTo_wsse__BinarySecurityToken' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsse__BinarySecurityToken
#define SOAP_TYPE_PointerTo_wsse__BinarySecurityToken (102)
#endif

/* struct _wsse__UsernameToken * has binding name 'PointerTo_wsse__UsernameToken' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsse__UsernameToken
#define SOAP_TYPE_PointerTo_wsse__UsernameToken (101)
#endif

/* struct _wsu__Timestamp * has binding name 'PointerTo_wsu__Timestamp' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsu__Timestamp
#define SOAP_TYPE_PointerTo_wsu__Timestamp (100)
#endif

/* struct __wsc__DerivedKeyTokenType_sequence * has binding name 'PointerTo__wsc__DerivedKeyTokenType_sequence' for type '-wsc:DerivedKeyTokenType-sequence' */
#ifndef SOAP_TYPE_PointerTo__wsc__DerivedKeyTokenType_sequence
#define SOAP_TYPE_PointerTo__wsc__DerivedKeyTokenType_sequence (98)
#endif

/* ULONG64 * has binding name 'PointerToULONG64' for type 'xsd:unsignedLong' */
#ifndef SOAP_TYPE_PointerToULONG64
#define SOAP_TYPE_PointerToULONG64 (97)
#endif

/* struct wsc__PropertiesType * has binding name 'PointerTowsc__PropertiesType' for type 'wsc:PropertiesType' */
#ifndef SOAP_TYPE_PointerTowsc__PropertiesType
#define SOAP_TYPE_PointerTowsc__PropertiesType (93)
#endif

/* wsc__FaultCodeOpenEnumType has binding name 'wsc__FaultCodeOpenEnumType' for type 'wsc:FaultCodeOpenEnumType' */
#ifndef SOAP_TYPE_wsc__FaultCodeOpenEnumType
#define SOAP_TYPE_wsc__FaultCodeOpenEnumType (88)
#endif

/* struct _xenc__ReferenceList * has binding name 'PointerTo_xenc__ReferenceList' for type '' */
#ifndef SOAP_TYPE_PointerTo_xenc__ReferenceList
#define SOAP_TYPE_PointerTo_xenc__ReferenceList (87)
#endif

/* struct __xenc__union_ReferenceList * has binding name 'PointerTo__xenc__union_ReferenceList' for type '-xenc:union-ReferenceList' */
#ifndef SOAP_TYPE_PointerTo__xenc__union_ReferenceList
#define SOAP_TYPE_PointerTo__xenc__union_ReferenceList (86)
#endif

/* struct xenc__ReferenceType * has binding name 'PointerToxenc__ReferenceType' for type 'xenc:ReferenceType' */
#ifndef SOAP_TYPE_PointerToxenc__ReferenceType
#define SOAP_TYPE_PointerToxenc__ReferenceType (85)
#endif

/* struct xenc__EncryptionPropertyType * has binding name 'PointerToxenc__EncryptionPropertyType' for type 'xenc:EncryptionPropertyType' */
#ifndef SOAP_TYPE_PointerToxenc__EncryptionPropertyType
#define SOAP_TYPE_PointerToxenc__EncryptionPropertyType (83)
#endif

/* struct xenc__TransformsType * has binding name 'PointerToxenc__TransformsType' for type 'xenc:TransformsType' */
#ifndef SOAP_TYPE_PointerToxenc__TransformsType
#define SOAP_TYPE_PointerToxenc__TransformsType (82)
#endif

/* struct xenc__CipherReferenceType * has binding name 'PointerToxenc__CipherReferenceType' for type 'xenc:CipherReferenceType' */
#ifndef SOAP_TYPE_PointerToxenc__CipherReferenceType
#define SOAP_TYPE_PointerToxenc__CipherReferenceType (81)
#endif

/* struct xenc__EncryptionPropertiesType * has binding name 'PointerToxenc__EncryptionPropertiesType' for type 'xenc:EncryptionPropertiesType' */
#ifndef SOAP_TYPE_PointerToxenc__EncryptionPropertiesType
#define SOAP_TYPE_PointerToxenc__EncryptionPropertiesType (80)
#endif

/* struct xenc__CipherDataType * has binding name 'PointerToxenc__CipherDataType' for type 'xenc:CipherDataType' */
#ifndef SOAP_TYPE_PointerToxenc__CipherDataType
#define SOAP_TYPE_PointerToxenc__CipherDataType (79)
#endif

/* struct ds__KeyInfoType * has binding name 'PointerTo_ds__KeyInfo' for type '' */
#ifndef SOAP_TYPE_PointerTo_ds__KeyInfo
#define SOAP_TYPE_PointerTo_ds__KeyInfo (78)
#endif

/* struct xenc__EncryptionMethodType * has binding name 'PointerToxenc__EncryptionMethodType' for type 'xenc:EncryptionMethodType' */
#ifndef SOAP_TYPE_PointerToxenc__EncryptionMethodType
#define SOAP_TYPE_PointerToxenc__EncryptionMethodType (77)
#endif

/* struct ds__X509IssuerSerialType * has binding name 'PointerTods__X509IssuerSerialType' for type 'ds:X509IssuerSerialType' */
#ifndef SOAP_TYPE_PointerTods__X509IssuerSerialType
#define SOAP_TYPE_PointerTods__X509IssuerSerialType (64)
#endif

/* struct ds__RSAKeyValueType * has binding name 'PointerTods__RSAKeyValueType' for type 'ds:RSAKeyValueType' */
#ifndef SOAP_TYPE_PointerTods__RSAKeyValueType
#define SOAP_TYPE_PointerTods__RSAKeyValueType (63)
#endif

/* struct ds__DSAKeyValueType * has binding name 'PointerTods__DSAKeyValueType' for type 'ds:DSAKeyValueType' */
#ifndef SOAP_TYPE_PointerTods__DSAKeyValueType
#define SOAP_TYPE_PointerTods__DSAKeyValueType (62)
#endif

/* struct ds__TransformType * has binding name 'PointerTods__TransformType' for type 'ds:TransformType' */
#ifndef SOAP_TYPE_PointerTods__TransformType
#define SOAP_TYPE_PointerTods__TransformType (61)
#endif

/* struct ds__DigestMethodType * has binding name 'PointerTods__DigestMethodType' for type 'ds:DigestMethodType' */
#ifndef SOAP_TYPE_PointerTods__DigestMethodType
#define SOAP_TYPE_PointerTods__DigestMethodType (60)
#endif

/* struct ds__TransformsType * has binding name 'PointerTods__TransformsType' for type 'ds:TransformsType' */
#ifndef SOAP_TYPE_PointerTods__TransformsType
#define SOAP_TYPE_PointerTods__TransformsType (59)
#endif

/* int * has binding name 'PointerToint' for type 'xsd:int' */
#ifndef SOAP_TYPE_PointerToint
#define SOAP_TYPE_PointerToint (58)
#endif

/* struct ds__ReferenceType ** has binding name 'PointerToPointerTods__ReferenceType' for type 'ds:ReferenceType' */
#ifndef SOAP_TYPE_PointerToPointerTods__ReferenceType
#define SOAP_TYPE_PointerToPointerTods__ReferenceType (57)
#endif

/* struct ds__ReferenceType * has binding name 'PointerTods__ReferenceType' for type 'ds:ReferenceType' */
#ifndef SOAP_TYPE_PointerTods__ReferenceType
#define SOAP_TYPE_PointerTods__ReferenceType (56)
#endif

/* struct ds__SignatureMethodType * has binding name 'PointerTods__SignatureMethodType' for type 'ds:SignatureMethodType' */
#ifndef SOAP_TYPE_PointerTods__SignatureMethodType
#define SOAP_TYPE_PointerTods__SignatureMethodType (55)
#endif

/* struct ds__CanonicalizationMethodType * has binding name 'PointerTods__CanonicalizationMethodType' for type 'ds:CanonicalizationMethodType' */
#ifndef SOAP_TYPE_PointerTods__CanonicalizationMethodType
#define SOAP_TYPE_PointerTods__CanonicalizationMethodType (54)
#endif

/* struct _wsse__SecurityTokenReference * has binding name 'PointerTo_wsse__SecurityTokenReference' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsse__SecurityTokenReference
#define SOAP_TYPE_PointerTo_wsse__SecurityTokenReference (49)
#endif

/* struct ds__RetrievalMethodType * has binding name 'PointerTods__RetrievalMethodType' for type 'ds:RetrievalMethodType' */
#ifndef SOAP_TYPE_PointerTods__RetrievalMethodType
#define SOAP_TYPE_PointerTods__RetrievalMethodType (48)
#endif

/* struct ds__KeyValueType * has binding name 'PointerTods__KeyValueType' for type 'ds:KeyValueType' */
#ifndef SOAP_TYPE_PointerTods__KeyValueType
#define SOAP_TYPE_PointerTods__KeyValueType (46)
#endif

/* struct _c14n__InclusiveNamespaces * has binding name 'PointerTo_c14n__InclusiveNamespaces' for type '' */
#ifndef SOAP_TYPE_PointerTo_c14n__InclusiveNamespaces
#define SOAP_TYPE_PointerTo_c14n__InclusiveNamespaces (42)
#endif

/* struct ds__KeyInfoType * has binding name 'PointerTods__KeyInfoType' for type 'ds:KeyInfoType' */
#ifndef SOAP_TYPE_PointerTods__KeyInfoType
#define SOAP_TYPE_PointerTods__KeyInfoType (34)
#endif

/* struct ds__SignedInfoType * has binding name 'PointerTods__SignedInfoType' for type 'ds:SignedInfoType' */
#ifndef SOAP_TYPE_PointerTods__SignedInfoType
#define SOAP_TYPE_PointerTods__SignedInfoType (32)
#endif

/* _ds__SignatureValue has binding name '_ds__SignatureValue' for type '' */
#ifndef SOAP_TYPE__ds__SignatureValue
#define SOAP_TYPE__ds__SignatureValue (29)
#endif

/* struct ds__X509DataType * has binding name 'PointerTods__X509DataType' for type 'ds:X509DataType' */
#ifndef SOAP_TYPE_PointerTods__X509DataType
#define SOAP_TYPE_PointerTods__X509DataType (28)
#endif

/* struct _wsse__Embedded * has binding name 'PointerTo_wsse__Embedded' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsse__Embedded
#define SOAP_TYPE_PointerTo_wsse__Embedded (26)
#endif

/* struct _wsse__KeyIdentifier * has binding name 'PointerTo_wsse__KeyIdentifier' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsse__KeyIdentifier
#define SOAP_TYPE_PointerTo_wsse__KeyIdentifier (25)
#endif

/* struct _wsse__Reference * has binding name 'PointerTo_wsse__Reference' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsse__Reference
#define SOAP_TYPE_PointerTo_wsse__Reference (24)
#endif

/* struct wsse__EncodedString * has binding name 'PointerTowsse__EncodedString' for type 'wsse:EncodedString' */
#ifndef SOAP_TYPE_PointerTowsse__EncodedString
#define SOAP_TYPE_PointerTowsse__EncodedString (18)
#endif

/* struct _wsse__Password * has binding name 'PointerTo_wsse__Password' for type '' */
#ifndef SOAP_TYPE_PointerTo_wsse__Password
#define SOAP_TYPE_PointerTo_wsse__Password (17)
#endif

/* _XML has binding name '_XML' for type '' */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
#endif

/* _QName has binding name '_QName' for type 'xsd:QName' */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
#endif

/* char * has binding name 'string' for type 'xsd:string' */
#ifndef SOAP_TYPE_string
#define SOAP_TYPE_string (4)
#endif

/* std::vector<ns2__PaypalTransaction *>  has binding name 'std__vectorTemplateOfPointerTons2__PaypalTransaction' for type 'ns2:PaypalTransaction' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__PaypalTransaction
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__PaypalTransaction (621)
#endif

/* std::vector<ns2__MDDField *>  has binding name 'std__vectorTemplateOfPointerTons2__MDDField' for type 'ns2:MDDField' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__MDDField
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__MDDField (619)
#endif

/* std::vector<ns2__Service *>  has binding name 'std__vectorTemplateOfPointerTons2__Service' for type 'ns2:Service' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__Service
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__Service (617)
#endif

/* std::vector<ns2__Leg *>  has binding name 'std__vectorTemplateOfPointerTons2__Leg' for type 'ns2:Leg' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__Leg
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__Leg (615)
#endif

/* std::vector<ns2__PromotionGroupReply *>  has binding name 'std__vectorTemplateOfPointerTons2__PromotionGroupReply' for type 'ns2:PromotionGroupReply' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__PromotionGroupReply
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__PromotionGroupReply (602)
#endif

/* std::vector<ns2__DeniedPartiesMatch *>  has binding name 'std__vectorTemplateOfPointerTons2__DeniedPartiesMatch' for type 'ns2:DeniedPartiesMatch' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__DeniedPartiesMatch
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__DeniedPartiesMatch (519)
#endif

/* std::vector<ns2__Field *>  has binding name 'std__vectorTemplateOfPointerTons2__Field' for type 'ns2:Field' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__Field
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__Field (515)
#endif

/* std::vector<ns2__RuleResultItem *>  has binding name 'std__vectorTemplateOfPointerTons2__RuleResultItem' for type 'ns2:RuleResultItem' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__RuleResultItem
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__RuleResultItem (511)
#endif

/* std::vector<ns2__FXQuote *>  has binding name 'std__vectorTemplateOfPointerTons2__FXQuote' for type 'ns2:FXQuote' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__FXQuote
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__FXQuote (509)
#endif

/* std::vector<ns2__TaxReplyItem *>  has binding name 'std__vectorTemplateOfPointerTons2__TaxReplyItem' for type 'ns2:TaxReplyItem' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__TaxReplyItem
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__TaxReplyItem (506)
#endif

/* std::vector<ns2__PromotionGroup *>  has binding name 'std__vectorTemplateOfPointerTons2__PromotionGroup' for type 'ns2:PromotionGroup' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__PromotionGroup
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__PromotionGroup (499)
#endif

/* std::vector<ns2__RequestReserved *>  has binding name 'std__vectorTemplateOfPointerTons2__RequestReserved' for type 'ns2:RequestReserved' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__RequestReserved
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__RequestReserved (456)
#endif

/* std::vector<ns2__Item *>  has binding name 'std__vectorTemplateOfPointerTons2__Item' for type 'ns2:Item' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__Item
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__Item (379)
#endif

/* std::vector<char *>  has binding name 'std__vectorTemplateOf_XML' for type '' */
#ifndef SOAP_TYPE_std__vectorTemplateOf_XML
#define SOAP_TYPE_std__vectorTemplateOf_XML (371)
#endif

/* std::vector<ns2__DecisionManagerTravelLeg *>  has binding name 'std__vectorTemplateOfPointerTons2__DecisionManagerTravelLeg' for type 'ns2:DecisionManagerTravelLeg' */
#ifndef SOAP_TYPE_std__vectorTemplateOfPointerTons2__DecisionManagerTravelLeg
#define SOAP_TYPE_std__vectorTemplateOfPointerTons2__DecisionManagerTravelLeg (370)
#endif

/* std::vector<std::string>  has binding name 'std__vectorTemplateOfstd__string' for type 'xsd:string' */
#ifndef SOAP_TYPE_std__vectorTemplateOfstd__string
#define SOAP_TYPE_std__vectorTemplateOfstd__string (366)
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of soapStub.h */
